<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Programming Basics Continuation Course, Spring 2012</title>
<link rel="stylesheet" href="stylesheets/common.css" type="text/css" media="screen, print" />
<link rel="stylesheet" href="stylesheets/menu.css" type="text/css" media="screen" />
<link rel="stylesheet" href="stylesheets/shjs/sh_style.css" type="text/css" media="screen, print" />
<link rel="stylesheet" href="stylesheets/exercises.css" type="text/css" media="screen, print" />

<script type="text/javascript" src="javascripts/jquery-1.7.1.min.js"></script>

<script type="text/javascript" src="javascripts/exercises2.js"></script>
<script type="text/javascript" src="javascripts/common-new.js"></script>

<script type="text/javascript" src="javascripts/jquery.easing.js"></script>
<script type="text/javascript" src="javascripts/shjs/sh_main.min.js"></script>
<script type="text/javascript" src="javascripts/shjs/sh_java.min.js"></script>
</head>
<body>
<h1>Advanced programming course</h1>

<p>Arto Vihavainen and Matti Luukkainen</p>

<div id="toc" class="menu" data-first-chapter-index="1" data-first-exercise-index="109">
  <div id="materiaali_toc"></div>
  <div id="tehtavat_toc"></div>
</div>

<p><strong><big>Note for the reader</big></strong></p>

<section class="viikkoraja" id="0">
  <div div class="viikkoraja-mooc" id="Note for the reader" tekija="Arto Vihavainen, Matti Luukkainen">

    <p>This is direct continuation to the programming basics course Object-Oriented Programming with Java, part 1<a href="http://mooc.fi/programming-part1">material</a>.</p>

    <p>This material is meant for the University of Helsinki Department of Computer Science advanced programming course, and released here as an Massive Open Online Course. The material is based on courses in 2012, 2011, and 2010, of which content has been affected by Matti Paksula, Antti Laaksonen, Pekka Mikkola, Juhana Laurinharju, Martin PÃ¤rtel, Joel Kaasinen  and Mikael Nousiainen.</p>

    <p>Read the material so that you do all of the examples you read yourself. It's worth making small changes to the examples and observe how the changes affect the program. At first you might think that doing the examples yourself and editing them too would slow down your learning. However, this isn't true at all. As far as we know, no one has yet learned to program by just reading (or by just listening to a lecture). Learning is based substantially on actively doing and growing a routine. The examples, and especially doing your own experiments, are one of the best ways to truly internalize the read text.</p>

    <p>Try to do assignments, or at least to try them out as you read the text. If you can't get an assignment pass right off the bat, don't get depressed, since you'll be always able to get help with the assignment at the workshop.</p>

    <p>The text isn't meant to be just read once. You'll most certainly have to return to parts you've already read, or to assignments you've already done. This text doesn't contain everything essential related to programming. As a matter of fact, no book exists that would have everything essential. So you will in every case - on your programming career - have to find information on your own. The excersises of the course already hold some instructions on how and where you'd be able to find useful information.</p>


    <p>The course picks up where the programming basics left off, and everything learned in the programming basics course is now assumed to be known. It's a good idea to go and check the <a href="../ohpe/index.html">material</a> of the programming basics course.</p>


  </div>
</section>

<section class="viikkoraja" id="1" >
  <div class="viikkoraja">Week1</div>
  <div class="viikkoraja-mooc" id="Week 7" deadline=" " data-first-chapter-index="33" data-first-exercise-index="108" data-first-week-index="7"  data-first-chapter-index-mooc="33" data-first-exercise-index-mooc="108" data-first-week-index-mooc="7" tekija="Arto Vihavainen, Matti Luukkainen">


    <h2>Recapping programming basics</h2>

    <p>In this chapter we briefly recap a few concepts we became familiar with in Part 1. You can familiarize yourself with the programming basics course material <a href="http://mooc.fi/programming-part1">here</a>.</p>


    <h3>Program, commands and variables</h3>

    <p>A computer program consists of a series of commands that a computer runs one at a time, from top to bottom. The commands always have a predefined structure and semantics. In Java - the programming language we use in this course - the commands are read from top to bottom, left to right. Programming courses are traditionally started by introducing a program that prints the string <code>Hello World!</code>. Below is a command written in Java that prints the <code>Hello World!</code> string.</p>

    <pre class="sh_java">
        System.out.println("Hello World!");
    </pre>

    <p>In the command the method <code>println</code> - which belongs to the <code>System</code> class - gets called, which prints the string passed in to it as a parameter, and after that a linebreak. The method is given the string <code>Hello World!</code> as a parameter; consequently the program prints out <code>Hello World!</code> followed by a linebreak.</p>

    <p>Variables can be used as part of the functionality of the program. Below is a program which introduces the variable <code>length</code> of the integer type. The value 197 is set to this variable on the next line. After this the value <code>179</code> of the variable <code>length</code> is printed.</p>

    <pre class="sh_java">
        int length;
        length = 179;
        System.out.println(length);
    </pre>

    <p>The execution of the program above would happen one line at a time. First the line <code>int length;</code> is executed, in which the variable <code>length</code> is introduced. Next the line <code>length = 179;</code> is executed, in which we set the value <code>179</code> to the variable that was introduced on the previous line. After this the line <code>System.out.println(length);</code> is run, in which we call the print method we saw earlier. To this method we give the variable <code>length</code> as a parameter. The method prints the content - the value - of the variable <code>length</code>, which is <code>179</code>.</p>

    <p>In the program above we really wouldn't have to introduce the variable <code>length</code> on one line and then set its value on the next. The introduction of a variable and setting its value can be done on the same line.</p>

    <pre class="sh_java">
        int length = 179;
    </pre>

    <p>When executing the above line, the variable <code>length</code> is introduced and as it is introduced the value <code>179</code> is set to it.</p>

    <p>In reality all information within a computer is represented as a series of bits - ones and zeros. Variables are an abstraction offered by the programming language with which we can handle different values more easily. The variables are used to store values and to maintain the state of the program. In Java, we have the primitive variable types <code>int</code> (integer), <code>double</code> (floating-point), <code>boolean</code> (truth value), <code>char</code> (character), and the reference variable types <code>String</code> (character string), <code>ArrayList</code> (array), and all classes. We'll return to primitive data type variables and to reference type variables and their differences later.</p>


    <h3>Comparing variables and reading input</h3>

    <p>The functionality of programs is built with the help of control structures. Control structures make different functions possible depending on the variables of the program. Below, an example of an <code>if - else if - else</code> control structure, in which a different function is executed depending on the result of the comparison. In the example a string <code>Accelerate</code> is printed if the value of the variable <code>speed</code> is smaller than 110, the string <code>Break</code> if the <code>speed</code> is greater than 120, and the string <code>Cruising</code> in other cases.</p>

    <pre class="sh_java">
int speed = 105;

if (speed &lt; 110) {
    System.out.println("Accelerate");
} else if (speed &gt; 120) {
    System.out.println("Break");
} else {
    System.out.println("Cruising");
}
    </pre>

    <p>Because in the example above the value of the variable <code>speed</code> is 105, the program will always print the string <code>Accelerate</code>. Remember that the comparison of strings is done with the <code>equals</code> method that belongs to the <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" target="_blank">String</a> class. Below is an example in which an object created from Java's <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a> class is used to read the input of a user. The program checks if the strings entered by the user are equal.</p>

    <pre class="sh_java">
Scanner reader = new Scanner(System.in);

System.out.print("Enter the first string: ");
String first = reader.nextLine();

System.out.print("Enter the second string: ");
String second = reader.nextLine();

System.out.println();

if (first.equals(second)) {
    System.out.println("The strings you entered are the same!");
} else {
    System.out.println("The strings you entered weren't the same!");
}
    </pre>

    <p>The functionality of the program depends on the user's input. Below is an example; the red text is user input.</p>

    <pre>
Enter the first string: <font color="red">carrot</font>
Enter the second string: <font color="red">lettuce</font>

The strings you entered weren't the same!
    </pre>

    <h3>Loops</h3>

    <p>Repetition is often required in programs. First we make a so-called <code>while-true-break</code> loop, which we run until the user inputs the string <code>password</code>. The statement <code>while(true)</code> begins the loop, which will then be repeated until it runs into the keyword <code>break</code>.</p>

    <pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        while (true) {
            System.out.print("Enter password: ");
            String password = reader.nextLine();

            if (password.equals("password")) {
                break;
            }
        }

        System.out.println("Thanks!");
    </pre>


    <pre>
Enter password: <font color="red">carrot</font>
Enter password: <font color="red">password</font>
Thanks!
    </pre>


    <p>You can also pass a comparison to a <code>while</code> loop instead of the boolean <code>true</code>. Below, the user input is printed so that there are stars above and below it.</p>

    <pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter string: ");
        String characterString = reader.nextLine();

        int starNumber = 0;
        while (starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();

        System.out.println(characterString);

        starNumber = 0;
        while (starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();
    </pre>


    <pre>
Enter string: <font color="red">carrot</font>
******
carrot
******
    </pre>

    <p>The example above should make you feel a little bad inside. The bad feelings are hopefully because you see that the example violates the rules learned in the programming basics. The example has unneccessary repetition which should be removed with the help of methods.</p>

    <p>In addition to the while-loop we also have two versions of the <code>for-loop</code> at our disposal. The newer <code>for-loop</code> is used for going through lists.</p>

    <pre class="sh_java">
        ArrayList&lt;String&gt; greetings = new ArrayList&lt;String&gt;();
        greetings.add("Hei");
        greetings.add("Hallo");
        greetings.add("Hi");

        for (String greet: greetings) {
            System.out.println(greet);
        }
    </pre>

    <pre>
Hei
Hallo
Hi
    </pre>

    <p>The more traditional <code>for-loop</code> is used in situations similar to where you would use a <code>while-loop</code>. It can, for example, be used to go through arrays. In the following example all values in the array <code>values</code> will be multiplied by two and then finally printed using the newer <code>for-loop.</code></p>

    <pre class="sh_java">
        int[] values = new int[] {1, 2, 3, 4, 5, 6};

        for (int i = 0; i &lt; values.length; i++) {
            values[i] = values[i] * 2;
        }

        for (int value: values) {
            System.out.println(value);
        }
    </pre>

    <pre>
2
4
6
8
10
12
    </pre>

    <p>The traditional <code>for-loop</code> is very useful in cases where we go through indices one at a time. The loop below will go through the characters of a character string one by one, and prints the character string <code>Hip!</code> every time we encounter the character <code>a</code>.</p>

    <pre class="sh_java">
        String characterString = "saippuakauppias";
        for (int i = 0; i &lt; characterString.length(); i++) {
            if (characterString.charAt(i) == 'a') {
                System.out.println("Hip!");
            }
        }
    </pre>

    <pre>
Hip!
Hip!
Hip!
Hip!
    </pre>

    <h3>Methods</h3>

    <p>Methods are a way of chopping up the functionality of a program into smaller entities. All Java programs start their execution from the <code>main</code> program method, which is defined with the statement <code>public static void main(String[] args)</code>. This statement defines a static method - that is a method which belongs to the <em>class</em> - which receives a character string array as its parameter.</p>

    <p>The program defines methods to abstract the functionalities of the program. When programming, one should try to achieve a situation in which the program can be looked at from a <em>higher level</em>, in such a case the main method consists of calls to a group of self-defined, well-named methods. The methods then specify the functionality of the program and perhaps are based on calls to other methods.</p>

    <p>Methods that are defined using the keyword <code>static</code> belong to the <em>class</em> that holds the method, and work as so-called support methods. The methods that are defined without the keyword <code>static</code> belong to the instances - <em>the objects</em> - created from the class and can modify the state of that individual object.</p>

    <p>A method always has a visibility modifier (<code>public</code>, visible to 'everyone', or <code>private</code>, only visible within its class), a return type (in the <code>main</code> method this is <code>void</code>, which returns nothing) and a name. In the following code we create a method which belongs to a class, <code>public static void print(String characterString, int times)</code>. This method prints a character string the defined amount of times. This time we use the method <code>System.out.print</code>, which works just like <code>System.out.println</code>, but doesn't print a linebreak.</p>

    <pre class="sh_java">
        public static void print(String characterString, int times) {
            for (int i = 0; i &lt; times; i++) {
                System.out.print(characterString);
            }
        }
    </pre>

    <p>The method above prints the character string it receives as a parameter an amount of times equal to the integer - which was also passed in as a parameter.</p>

    <p>In the section on loops we noticed that the code had some nasty copy-paste stuff in it. With the help of methods, we can move the printing of stars to a separate method. We create a method <code>public static void printStars(int times)</code>, which prints the amount of stars it receives as a parameter. The method uses a <code>for</code> loop instead of a <code>while</code>.</p>

    <pre class="sh_java">
        public static void printStars(int times) {
            for (int i = 0; i &lt; times; i++) {
                System.out.print("*");
            }
            System.out.println();
        }
    </pre>

    <p>When making use of a method, our previous (and hideous) example now looks like the following.</p>

    <pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter characterString: ");
        String characterString = reader.nextLine();

        printStars(characterString.length());
        System.out.println(characterString);
        printStars(characterString.length());

    </pre>


    <h3>Class</h3>

    <p>Methods can abstract a program up to a certain point, but as the program becomes larger it's sensible to chop down the program even further into smaller and more logical entities. With the help of classes, we can define higher level concepts of a program and functionalities related to those concepts. Every Java program requires a class in order to work, so the <code>Hello World!</code> example wouldn't work without the class definition. A class is defined with the keywords <code>public class nameOfTheClass</code>.</p>

    <pre class="sh_java">
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
    </pre>

    <p>In a program, classes are used to define concepts and functionalities related to those concepts. Objects can be created from a class and are the embodiments of that class. Every object that belongs to a certain class has the same structure, but the variables belonging to each objects can be different. The methods of objects handle the <em>state</em> of the object, that is, the variables of the object.</p>

    <p>Let's inspect the class <code>Book</code> below; the class has the object variables <code>name</code> (String) and <code>publishingYear</code> (integer).</p>

    <pre class="sh_java">
        public class Book {
            private String name;
            private int publishingYear;

            public Book(String name, int publishingYear) {
                this.name = name;
                this.publishingYear = publishingYear;
            }

            public String getName() {
                return this.name;
            }

            public int getPublishingYear() {
                return this.publishingYear;
            }
        }
    </pre>

    <p>The definition in the beginning, <code>public class Book</code>, tells the name of the class. This is followed by the definitions of object variables. Object variables are variables which for each of the objects created from the class are their own -- the object variables of one object are unrelated to the state of the same variables of another object. It's usually appropriate to hide the object variables from the users of the class, to define the visibility modifier <code>private</code> for them. If the visibility modifier is set to <code>public</code>, the user of the object will be able to directly access the object variables.</p>

    <p>Objects are created from a class with a <em>constructor</em>. A constructor is a method that initializes an object (creates the variables belonging to the object) and executes the commands that are within the constructor. The constructor is always named the same as the class that has the constructor in it. In the constructor <code>public Book(String name, int publishingYear)</code> a new object is created from the class <code>Book</code> and its variables are set to the values that were passed in as parameters.</p>

    <p>Two methods that handle the information in the object are also defined for the class above. The method <code>public String getName()</code> returns the name of the object in question. The method <code>public int getPublishingYear()</code> returns the publishing year of the object in question.</p>

    <h3>Object</h3>

    <p><em>Objects</em> are created with the help of the constructor that is defined within a class. In the program code the costructor is called with the <code>new</code> command, which returns a reference to the new object. Objects are instances created from classes. Let's inspect a program that creates two different books, after which it prints the values returned by the <code>getName</code> methods belonging to the objects.</p>

    <pre class="sh_java">
        Book senseAndSensibility = new Book("Sense and Sensibility", 1811);
        Book prideAndPrejudice = new Book("Pride and Prejudice", 1813);

        System.out.println(senseAndSensibility.getName());
        System.out.println(prideAndPrejudice.getName());
    </pre>

    <pre>
Sense and Sensibility
Pride and Prejudice
    </pre>

    <p>So, each object has its own internal state. The state is formed from object variables that belong to the object. Object variables can be both primitive type variables and reference type variables. If reference type variables belong to the objects, it is possible that other objects also refer to the same referenced objects! Let's visualize this with the bank example, in which there are accounts and persons.</p>

    <pre class="sh_java">
        public class Account {
            private String accountID;
            private int balanceAsCents;

            public Account(String accountID) {
                this.accountID = accountID;
                this.balanceAsCents = 0;
            }

            public void deposit(int sum) {
                this.balanceAsCents += sum;
            }

            public int getBalanceAsCents() {
                return this.balanceAsCents;
            }

            // .. other methods related to an account
        }
    </pre>

    <pre class="sh_java">
        import java.util.ArrayList;

        public class Person {
            private String name;
            private ArrayList&lt;Account&gt; accounts;

            public Person(String name) {
                this.name = name;
                this.accounts = new ArrayList&lt;Account&gt;();
            }

            public void addAccount(Account account) {
                this.accounts.add(account);
            }

            public int moneyTotal() {
                int total = 0;
                for (Account account: this.accounts) {
                    total += account.getBalanceAsCents();
                }

                return total;
            }

            // ... other methods related to a person
        }
    </pre>

    <p>Each object created from the <code>Person</code> class has its own name and its own list of accounts. Next, let's create two persons and two accounts. One of the accounts is owned by only one person and the other one is shared.</p>

    <pre class="sh_java">
        Person matti = new Person("Matti");
        Person maija = new Person("Maija");

        Account salaryAccount = new Account("NORD-LOL");
        Account householdAccount = new Account("SAM-LOL");

        matti.addAccount(salaryAccount);
        matti.addAccount(householdAccount);
        maija.addAccount(householdAccount);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        salaryAccount.deposit(150000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        householdAccount.deposit(10000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();
    </pre>

    <pre>
Money on Matti's accounts: 0
Money on Maija's accounts: 0

Money on Matti's accounts: 150000
Money on Maija's accounts: 0

Money on Matti's accounts: 160000
Money on Maija's accounts: 10000
    </pre>

    <p>Initially, the accounts of both persons are empty. When money is added to the salaryAccount - which <code>matti</code> has a reference to - the amount of money on Matti's accounts grows. When money is added to the householdAccount <em>the amount of money each person has grows</em>. This is because both Matti and Maija have "access" to the householdAccount, so in each of the persons' object variable <code>accounts</code>, there's a reference to the householdAccount.</p>


    <h3>The structure of a program</h3>

    <p>A program should be clear and easy to understand for both the original writer and others. The most important aspects of a clear program are class structure and good naming conventions. Each class should have a single, clearly defined responsibility. Methods are used to reduce repetition and to create a structure for the internal functionality of the class. A method should also have a clear responsibility to ensure it stays short and simple. Methods that do many things should be divided into smaller helper methods, which are called by the original method. A good programmer writes code that can be understood even weeks after it was originally written.</p>

    <p>Good, understandable code uses descriptive naming of variables, methods and classes, and consistent indentation. Let's look at the example below, a small program for buying and selling goods. Even though the only thing available is carrots, with no bookkeeping, the user interface could be extended to use a storage class to keep track of items.

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else if (command.equals("buy")) {
                String line = null;
                while(true) {
                    System.out.print("What to buy: ");
                    line = reader.nextLine();
                    if(line.equals("carrot")) {
                        break;
                    } else {
                        System.out.println("Item not found!");
                    }
                }

                System.out.println("Bought!");
            } else if (command.equals("sell")) {
                String line = null;
                while(true) {
                    System.out.print("What to sell: ");
                    line = reader.nextLine();
                    if(line.equals("carrot")) {
                        break;
                    } else {
                        System.out.println("Item not found!");
                    }
                }

                System.out.println("Sold!");
            }
        }
    }
}
    </pre>

    <p>This example has numerous problems. The first problem is the long <code>start</code> method. It can be shortened by moving most of the command handling to a separate method.</p>

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else {
                handleCommand(command);
            }
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String line = null;
            while(true) {
                System.out.print("What to buy: ");
                line = reader.nextLine();
                if(line.equals("carrot")) {
                    break;
                } else {
                    System.out.println("Item not found!");
                }
            }

            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String line = null;
            while(true) {
                System.out.print("What to sell: ");
                line = reader.nextLine();
                if(line.equals("carrot")) {
                    break;
                } else {
                    System.out.println("Item not found!");
                }
            }

            System.out.println("Sold!");
        }
    }
}
    </pre>

    <p><code>handleCommand</code> still has some repetition for reading the user input. Both buying and selling first print a character string with the question, then take input from the user. If the input is incorrect (other than "carrot"), "Item not found!" is printed. We will create a new method, <code>public String readInput(String question)</code>, to handle this. Note that if the program used some other object to keep track of inventory, we would compare user input to the inventory's contents instead.</p>

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else {
                handleCommand(command);
            }
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String input = readInput("What to buy: ");
            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String input = readInput("What to sell: ");
            System.out.println("Sold!");
        }
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            } else {
                System.out.println("Item not found!");
            }
        }
    }
}
    </pre>

    <p>The program is now divided into appropriate parts. There are still a few things, other than implementing more methods, we can do to improve readability. The <code>start</code> method has an <code>if</code> branch that ends in <code>break</code>, which exits the loop. We can remove the unnecessary <code>else</code> branch, simply moving the <code>handleCommand</code> method to be called after the <code>if</code> statement. The program still works exactly as before, but the method is now shorter and easier to read. A similar situation exists in the <code>readInput</code> method, so we will clean it up too.</p>

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            }

            handleCommand(command);
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String input = readInput("What to buy: ");
            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String input = readInput("What to sell: ");
            System.out.println("Sold!");
        }
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            }

            System.out.println("Item not found!");
        }
    }
}
    </pre>


    <p>Dividing a program into smaller parts, like we did above, is called <em>refactoring</em>. It does not change how the program works, but the internal structure is changed to be more clear and easier to maintain. The current version is clearer than the original, but it can be improved further. For example, <code>handleCommand</code> can be further divided into two different methods, one for handling buying and the other for selling.</p>

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            }

            handleCommand(command);
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            commandBuy();
        } else if (command.equals("sell")) {
            commandSell();
        }
    }

    public void commandBuy() {
        String input = readInput("What to buy: ");
        System.out.println("Bought!");
    }

    public void commandSell() {
        String input = readInput("What to sell: ");
        System.out.println("Sold!");
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            } else {
                System.out.println("Item not found!");
            }
        }
    }
}
    </pre>

    <p>The program now has a clear structure with descriptively named methods. Every method is short and has a small task to handle. Note that refactoring the code did not add any new functionality, it merely changed the way the program works internally.</p>

    <h3>Programming and the importance of practicing</h3>

    <p>As far as we know, nobody has yet learned programming by listening to lectures. To develop the skill required in programming, it is essential to practice both what you have learned earlier and things that are new to you. Programming can be compared to speaking languages or playing an instrument, both of which can only be learned by doing. Master violinists are probably not good at playing <em>only</em> because they practice a lot. Playing an instrument is fun, which makes one more motivated to practice. The same applies to programming.</p>

    <p>As Linus Torvalds said, <em>"Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program"</em>.</p>

    <p>Dr. Luukkainen has written a list of instructions for new programmers to follow when learning to program. Follow this advice to become a great programmer!</p>

    <ul>
      <li> Take small steps
      <ul>
        <li> Divide the problem you are trying to solve into smaller parts and solve them <strong>one at a time</strong> </li>
        <li> Keep testing that your solution is moving in the right direction, ensuring that you have solved the current part correctly</li>
      </ul></li>
      <li> Keep the code as clean as you can
      <ul>
        <li> use proper indentation </li>
        <li> use descriptive names for variables, methods, classes, everything</li>
        <li> keep all methods short, including <code>main</code> </li>
        <li> write methods that only do one thing </li>
        <li> <strong>remove all copy-paste code by refactoring (or don't copy and paste code in the first place!)</strong></li>
        <li> replace "bad" and unclear code with clean, easy to read code </li>
      </ul></li>
    </ul>



    <h3>Visibility</h3>

    <p>Until now, we have been using two different keywords to define the <em>visibility</em> of methods and instance variables. <code>public</code> makes the method or instance variable visible and accessable to everyone. Methods and constructors are usually marked as public, so that they can be called from outside the class.</p>

    <p>Declaring a method or instance variable <code>private</code> hides it from the outside, making it only accessible from inside the same class.</p>

    <pre class="sh_java">
public class Book {
    private String name;
    private String contents;

    public Book(String name, String contents) {
        this.name = name;
        this.contents = contents;
    }

    public String getName() {
        return this.name;
    }

    public String getContents() {
        return this.contents;
    }

    // ...
}
    </pre>

    <p>The instance variables in the Book class above can only be accessed with the public methods <code>getName</code> and <code>getContents</code>. Fields declared as private are only accessible in code inside the class. Methods can also be declared as private, which prevents them from being called outside the class.</p>


    <p>Now it's time to start practicing!</p>

    <div class="tehtavat" id="viikko7">
      <div class="tehtava">
        <h3>Smileys</h3>

        <p>Create the support method <code>private static void printWithSmileys(String characterString)</code> for the class <code>Smileys</code> which comes with the assignment template. The method is to print the given character string surrounded with smileys. Use the character string <code>:)</code> as the smiley.</p>

        <pre class="sh_java">
printWithSmileys("\\:D/");
        </pre>

        <pre>
:):):):):)
:) \:D/ :)
:):):):):)
        </pre>

        <p>Note, that the character string must have \\ so we can print the symbol \.</p>

        <p><em>Note!</em> if the length of the character string is an odd number, add an extra space on the right side of the given character string.</p>

        <pre class="sh_java">
printWithSmileys("\\:D/");
printWithSmileys("87.");
        </pre>

        <pre>
:):):):):)
:) \:D/ :)
:):):):):)
:):):):):)
:) 87.  :)
:):):):):)
        </pre>

        <p>It's a good idea to first think how many smileys should be printed for a character string of a certain length. The length of a character string can be found out with the method <code>length</code> which belongs to it. A loop is helpful for printing the top and bottom smiley rows, the middle row can be handled with a normal print command. You can check if a length is an odd number with the help of a remainder <code>characterString.length() % 2 == 1</code>.</p>
      </div>
      <div class="tehtava">
        <h3>Character String Changer</h3>

        <p>In this assignment we create a character string changer, which consists of two classes. The class <code>Changer</code> turns a single character to another one. The Changer holds a number of Changes and changes character strings with the help of Change objects it holds.</p>

        <h4>Change-class</h4>

        <p>Create a class <code>Change</code>, that has the following functionalities:</p>

        <ul>
          <li> constructor <code>public Change(char fromCharacter, char toCharacter)</code> that creates an object that makes changes from character <code>fromCharacter</code> to <code>toCharacter</code></li>
          <li> method <code>public String change(String characterString)</code> returns the changed version of the given character string</li>
        </ul>

        <p>The class is used in the following way:</p>

        <pre class="sh_java">
  String word = "carrot";
  Change change1 = new Change('a', 'b');
  word = change1.change(word);

  System.out.println(word);

  Change Change2 = new Change('r', 'x');
  word = Change2.change(word);

  System.out.println(word);
        </pre>

        <p>The example above would print:</p>

        <pre>
  cbrrot
  cbxxot
        </pre>

        <p><strong>Tip:</strong> you can handle replacing characters in two ways, either with the help of a method in the class <code>String</code> (look for it yourself!) or by going through the character string character by character while forming the changed character string.</p>

        <p>If you don't use the ready-made method of String, it is good to remember that even though you compare character strings with the command <code>equals</code> you compare single characters with the == operator:</p>

        <pre class="sh_java">
  String word = "carrot";

  String replacedA = "";
  for ( int i=0; i &lt; word.length(); i++) {
     char character = word.charAt(i);
     if ( character == 'a' ) {
        replacedA += '*'
     }  else {
        replacedA += character;
     }
  }

  System.out.println(replacedA);  // prints c*rrot
        </pre>

        <h4>Changer-class</h4>

        <p>Create the class <code>Changer</code>, with the following functions:</p>

        <ul>
          <li> constructor <code>public Changer()</code> creates a new changer</li>
          <li> method <code>public void addChange(Change change)</code> adds a new Change to the Changer</li>
          <li> method <code>public String change(String characterString)</code> executes all added Changes for the character string in the order of their adding and returns the changed character string</li>
        </ul>

        <p>The class is used in the following way:</p>

        <pre class="sh_java">
  Changer scandiesAway = new Changer();
  scandiesAway.addChange(new Change('Ã¤', 'a'));
  scandiesAway.addChange(new Change('Ã¶', 'o'));
  System.out.println(scandiesAway.change("Ã¤Ã¤liÃ¶ Ã¤lÃ¤ lyÃ¶, Ã¶Ã¶liÃ¤ lÃ¤ikkyy"));
        </pre>

        <p>The above example would print:</p>

        <pre>
  aalio ala lyo, oolia laikkyy
        </pre><!-- TODO -->

        <p><strong>Tip:</strong> It's a good idea to store the Changes to a list object variable of Changer (in the same fashion as on the basics course we stored players to a team, phone numbers to a phone book or books to a library, for example) A Changer is executed so that the changes are done to the character string one at a time as in the following example:</p>

        <pre class="sh_java">
    ArrayList&lt;Change&gt; changes = new ArrayList&lt;Change&gt;();

    changes.add( new Change('a', 'b') );
    changes.add( new Change('k', 'x') );
    changes.add( new Change('o', 'Ã¥') );

    String word = "carrot";

    for (Change Change : changes) {
        word = Change.change(word);
    }

    System.out.println(word);  // print pÃ¥rxxbnb
        </pre>

        <p><strong>REMINDER</strong> when you add an ArrayList, a Scanner or a Random, Java doesn't recognize the class unless you "import" it by adding the following lines to the beginning:</p>

        <pre class="sh_java">
import java.util.ArrayList;    // imports ArrayList
import java.util.*;            // imports all tools from java.util, including ArrayList, Scanner ja Random
        </pre>
      </div>
      <div class="tehtava">
        <h3>Calculator</h3>

        <p>In this assignment, we make a simple calculator, similar to the one made in the material of programming basics' week 1. This time however, we pay attention to the structure of the program. Especially we will make the <em>main</em>-method (the main program) very light. The main program method doesn't actually do anything else than just start the program:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        calculator.start();
    }
}
        </pre>

        <p>What the main program here does is it just creates the object that implements the actual application logic and then starts it. This is the proper way of creating programs and from now on we'll try to achieve this structure.</p>

        <h4>Reader</h4>

        <p>In order to communicate with the user, the calculator needs a Scanner-object. As we've seen, reading integers with a Scanner is a little laborious. We now create a separate class <code>Reader</code> that encapsulates a Scanner-object.</p>

        <p>Implement the class <code>Reader</code> and add the following methods to it</p>

        <ul>
          <li><code>public String readString()</code></li>
          <li><code>public int readInteger()</code></li>
        </ul>

        <p>Within the Reader there should be a Scanner-object as an instance variable, which the methods use in the old familiar way we know from programming basics. Remember that when reading integers, it's good to first read the entire line and then turn that in to an integer. Here we can utilize the method <code>parseInt</code> of the <code>Integer</code>-class.</p>

        <h4>Application body</h4>

        <p>The calculator works like this:</p>

        <pre>
command: <font color="red">sum</font>
value1: <font color="red">4</font>
value2: <font color="red">6</font>
sum of the values 10

command: <font color="red">product</font>
value1: <font color="red">3</font>
value2: <font color="red">2</font>
product of the values 6

command: <font color="red">end</font>
        </pre>

        <p>Implement the class <code>Calculator</code> to take care of the application logic of your program, and for that class a method <code>public void start()</code> which looks exactly like this:</p>

        <pre class="sh_java">
    public void start() {
        while (true) {
            System.out.print("command: ");
            String command = reader.readString();
            if (command.equals("end")) {
                break;
            }

            if (command.equals("sum")) {
                sum();
            } else if (command.equals("difference")) {
                difference();
            } else if (command.equals("product")) {
                product();
            }
        }

        statistics();
    }
        </pre>

        <p>The calculator has the operations <code>sum, difference, product</code>.</p>

        <p>Finish the bodies for the methods <code>sum</code>, <code>difference</code>, <code>product</code> and <code>stasistics</code>. All of them are to be of the type <code>private void</code> which means that the methods are available only for internal use in the calculator.</p>

        <p>Add an instance variable of the type <code>Reader</code> for the calculator and create the reader in the constructor. <em>The calculator may not have a separate Scanner-type variable!</em></p>

        <h4>Implementation of the application logic</h4>

        <p>Now implement the methods <code>sum</code>, <code>difference</code> and <code>product</code> so that they work according to the example above. In the example, first a command is asked from the user and then two values. The desired operation is then executed and the value of the operation is printed. Notice that asking the user for the values happens within the methods <code>sum</code>, <code>difference</code> and <code>product</code>! The methods use the Reader-object to ask the values, so the body of the methods is as follows:</p>

        <pre class="sh_java">
    private void sum() {
       System.out.print("value1: ");
       int value1 = // read the value using the Reader-object
       System.out.print("value2: ");
       int value2 = // read the value using the Reader-object
       // print the value according to the example above
    }
        </pre>

        <h4>Statistics</h4>

        <p>After the <code>while</code>-loop in the <code>start</code>-method, the method <code>statistics</code> is called. The method is meant to print the amount of operations done with the Calculator-object:</p>

        <pre>
command: <font color="red">sum</font>
value1: <font color="red">4</font>
value2: <font color="red">6</font>
sum of the values 10

command: <font color="red">product</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
product of the values 6

command: <font color="red">end</font>
Calculations done 2
        </pre>

        <p>Implement the method <code>private void statistics()</code>, and make the required changes to the code of the Calculator-class in order to collect the statistics.</p>

        <p>Note: if an invalid command is given to the program (something other than sum, difference, product or end), the calculator will not react to the command in any way, but instead continues by asking the next command. Statistics is not to count an invalid command as a completed calculation.</p>

        <pre>
command: <font color="red">integral</font>
command: <font color="red">difference</font>
value1: <font color="red">3</font>
value2: <font color="red">2</font>
difference of the values 1

command: <font color="red">end</font>
Calculations done 1
        </pre>

        <p><strong>Bonus assignment (not tested):</strong> Reading the user input is repeated in the same way in all three operation implementing methods. Remove the repetition from your code with the help of a support method. The method can return the two values asked from the user in an array, for example.</p>

      </div>
    </div>


    <h2>Primitive- and reference-type variables</h2>

    <p>Java is a strongly typed language, what this means is that all of its variables have a <em>type</em>. The types of the variables can be divided in to two categories: <strong>primitive-type and reference-type variables</strong>. Both types of variables have their own "slot", which holds the information belonging to them. Primitive-type variables hold the concrete <em>value</em> in their slot, while the reference-type variables hold a <em>reference</em> to a concrete <em>object</em>.</p>

    <h3>Primitive-type variables</h3>

    <p>The value of a primitive type variable is saved in a slot created for the variable. Each primitive-type variable has its own slot and its own value. A variable's slot is created when it is introduced (<code>int number;</code>, for example). A value is set to a slot with the assignment operator <code>=</code>. Below is an example of the introduction of a primitive-type <code>int</code> (integer) variable and setting of its value in the same expression.</p>

    <pre class="sh_java">
int number = 42;
    </pre>

    <p>Primtive type variables, among others, are <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code> and the more rarely used <code>short</code>, <code>float</code>, <code>byte</code> and <code>long</code>. Another primitive-type is <code>void</code>, but it doesn't have its own slot or value. The <code>void</code>-type is used when we want to express that a method doesn't return a value.</p>

    <p>Next we introduce two primitive-type variables and set values to them.</p>

    <pre class="sh_java">
int five = 5;
int six = 6;
    </pre>

    <p>The primitive-type variables introduced above are named <code>five</code> and <code>six</code>. When introducing the variable <code>five</code> the value 5 is set to the <em>slot</em> that was created for it (<code>int five = 5;</code>).  When introducing the variable <code>six</code> the value 6 is set to the <em>slot</em> that was created for it (<code>int six = 6;</code>). The variables <code>five</code> and <code>six</code> are both of the type <code>int</code>, or integers.</p>

    <p>Primitive-type variables can be visualized as boxes that both have the values belonging to them saved in to them:</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/primitive-five-and-six.png" /></p>

    <p>Next lets inspect how the values of primitive-type variables get copied.</p>

    <pre class="sh_java">
int five = 5;
int six = 6;

five = six; // the variable 'five' now holds the value 6 - the value that was in the variable 'six'.
six = 64; // the variable 'six' now holds the value 64

// the variable 'five' still holds the value 6
    </pre>

    <p>Above we introduce the variables <code>five</code> and <code>six</code> and we set values to them. After this the value held in the slot of the variable <code>six</code> is copied to the slot of the variable <code>five</code> (<code>five = six;</code>). If the value of the variable <code>six</code> is changed after this point the value in the variable <code>five</code> remains unaffected: the value of the variable <code>five</code> is in its own slot and is not related to the value in the slot of the variable <code>six</code> in any way. The end situation as a picture:</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/primitive-five-and-six-64.png" /></p>

    <h4>Primitive type variable as a method parameter and return value</h4>

    <p>When a primitive type variable is passed to a method as a parameter, the method parameter is set to the value in the given variable's slot. In practice, the method parameters also have their own slots to which the value is copied, like in an assignment expression. Let us consider the following method <code>addToValue(int value, int amount)</code>.</p>

    <pre class="sh_java">
public int addToValue(int value, int amount) {
    return value + amount;
}
    </pre>

    <p>The method <code>addToValue</code> is given two parameters: <code>value</code> and <code>amount</code>. The method returns a new value, which is the sum of the given parameters. Let us investigate how the method is called.</p>

    <pre class="sh_java">
int myValue = 10;
myValue = addToValue(myValue, 15);
// the variable 'myValue' now holds the value 25
    </pre>

    <p>In the example, <code>addToValue</code> is called using the variable <code>myValue</code> and the value <code>15</code>. These are copied to the method parameters <code>value</code>, which will hold the value 10 (the contents of <code>myValue</code>), and <code>amount</code>, which wil hold the value 15. The method returns the sum of <code>value</code> and <code>amount</code>, which is equal to <code>10 + 15 = 25</code>.</p>

    <p>Note! In the previous example, the value of the variable <code>myValue</code> is changed only because it is assigned the return value of <code>addToValue</code> (<code>myValue = addToValue(myValue, 15);</code>). If the call to <code>addToValue</code> were as follows, the value of the variable <code>myValue</code> would remain unchanged.</p>

    <pre class="sh_java">
int myValue = 10;
addToValue(myValue, 15);
// the variable 'myValue' still holds the value 10
    </pre>

    <h4>Minimum and maximum values</h4>

    <p>Each primitive data type can represent a specific range of values limited by its minimum and maximum value, which are the smallest and largest values representable by the type. This is because a predefined data size is used for the internal represetantion of the type in Java (and most other programming languages).</p>

    <p>The minimum and maximum values for a few Java primitive types are:</p>

    <p>
    <table cellspacing="5" >
      <tr><th>Data type</th><th>Description</th><th>Minimum value</th><th>Max value</th></tr>
      <tr><td>int</td><td>Integer</td><td>-2 147 483 648 (<code>Integer.MIN_VALUE</code>)</td><td>2 147 483 647 (<code>Integer.MAX_VALUE</code>)</td></tr>
      <tr><td>long</td><td>Long interger</td><td>-9 223 372 036 854 775 808 (<code>Long.MIN_VALUE</code>)</td><td>9 223 372 036 854 775 807 (<code>Long.MAX_VALUE</code>)</td></tr>
      <tr><td>boolean</td><td>Truth value</td><td colspan=2><code>true</code> or <code>false</code></td></tr>
      <tr><td>double</td><td>Floating point</td><td><code>Double.MIN_VALUE</code></td><td><code>Double.MAX_VALUE</code></td></tr>
    </table>
    </p>

    <p><strong>Rounding errors</strong></p>

    <p>When using floating point data types, it is important to keep in mind that floating point types are always an <em>approximation</em> of the actual value. Because floating point types use a predefined data size to represent the value similarly to all other primitive data types, we may observe quite surprising rounding errors. For example, consider the following case.</p>

    <pre class="sh_java">
double a = 0.39;
double b = 0.35;
System.out.println(a - b);
    </pre>

    <p>The example prints the value <code>0.040000000000000036</code>. Programming languages usually include tools to more accurately handle floating point numbers. In Java, for example, the class <em>BigDecimal</em> can be used to store infinitely long floating point numbers.</p>

    <p>When comparing floating point numbers, rounding errors are usually taken into account by comparing the distance between the values. For example, with the variables in the previous example, the expression <code>a - b == 0.04</code> does not produce the expected result due to a rounding error.</p>

    <pre class="sh_java">
double a = 0.39;
double b = 0.35;

if((a - b) == 0.04) {
    System.out.println("Successful comparison!");
} else {
    System.out.println("Failed comparison!");
}
    </pre>

    <pre>
Failed comparison!
    </pre>

    <p>One method to calculate the distance between two values is as follows. The helper function <code>Math.abs</code> returns the absolute value of the value passed to it.</p>

    <pre class="sh_java">
double a = 0.39;
double b = 0.35;

double distance = 0.04 - (a - b);

if(Math.abs(distance) &lt; 0.0001) {
    System.out.println("Successful comparison!");
} else {
    System.out.println("Failed comparison!");
}
    </pre>
    <pre>
Successful comparison!
    </pre>
    <h3>Reference-Type Variables</h3>

    <p>Reference-type variables memorize the information which has been assigned to them "on the other end of the line". Reference-type variables contain a reference to the location where the information is stored. Differently from primitive-type variables, reference-type variable do not have a limited scope because their value or <em>information</em> is stored at the referenced location. Another substantial difference between primitive-type and reference-type variables is that various different reference-type variables can point to the same object.</p>

    <!--
        <p>Reference-type variables are objects which are created through the <code>new</code> keyword. The value of a reference-type variable is still assigned using the operator <code>=</code>; however, the <code>new</code> operator creates an object and returns the reference to that object. The reference is stored within the variable, and it becomes its value.</p>
-->

    <p>Let us have a look at two reference-type variables. In the following examples we make use of the class <em>Calculator</em>:</p>

    <pre class="sh_java">
public class Calculator {
    private int value;

    public Calculator(int originalValue) { // Contructor
        this.value = originalValue;
    }

    public void increaseValue() {
        this.value = this.value + 1;
    }

    public int getValue() {
        return value;
   }
}
    </pre>

    <p>Main:</p>

    <pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);
    </pre>

    <p>In the examples we first create a reference-type variable called <code>bonusCalculator</code>. The <code>new</code> operator tells that we define storage space for the information to be assigned to the variable, then we execute the code which follows the <code>new</code> operator, and we return a reference to the object that has been so created. The reference which is returned is assigned to the <code>bonusCalculator</code> variable through the <code>=</code> equal sign. The same thing happens with the variable called <code>axeCalculator</code>. If we want to think about it with pictures, we can imagine a reference-type variable as it were a box, the variable itself, with a line or an arrow, which starts at the box and points to an object. In fact, the variable does not contain the object, but it points to the object information. </p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/reference-type-calculators.png" /></p>

    <p>Next, let us have a look at how a reference-type object is duplicated.</p>

    <pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                                 // that is to say, a reference to a Calculator-type object which received the value 6 in its constructor
                                 // is copied to the variable bonusCalculator
    </pre>

    <p>When we copy a reference-type variable (see above <code>bonusCalculator =  axeCalculator;</code>), the reference to the variable duplicates as well. In this case, a reference to the <code>axeCalculator</code> variable slot is copied to the <code>bonusCalculator</code> variable slot. Now, both the objects point to the same place!</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/reference-type-calculators-ref-changed.png" /></p>

    <p>Let us continue with the example above and let us set a new reference to the variable <code>axeCalculator</code>; this new reference will point to a new object created by the command <code>new Calculator(10)</code>.</p>

    <pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                                 // that is to say, a reference to a Calculator-type object which received the value 6 in its constructor
                                 // is copied to the variable

axeCalculator = new Calculator(10); // a new reference is assigned to the axeCalculator variable
                                    // which points to the object created by the command new Calculator(10)

// the bonusCalculator variable still contains a reference to the Calculator object which received value 6 in its parameter
    </pre>

    <p>In these examples, we do the same operations which were shown in the assignment example in the primitive-type variables section. In the very last example, we copied the reference of reference-type variables, whereas in the primitive-type variables section we copied the value of primitive-type variables. In both cases, we copy the contents of a slot: the primitive-type variable slot contains a value, whereas the reference-type variable slot contains a reference.</p>

    <p>At the end of the previous example no variable points to the Calculator object which received value 5 in its constructor. Java's garbage collection deletes such useless objects from time to time. Our final situation looks like the following:</p>


    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/reference-type-calculators-3rd-object.png" /></p>

    <p>Let us have a look to a third example still, and let us focus on an essential difference between primitive-type and reference-type variables.</p>

    <pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                                 // that is to say, a reference to a Calculator-type object which received the value 6 in its constructor
                                 // is copied to the variable

axeCalculator.increaseValue(); // we increase by one the value of the object referenced by axeCalculator

System.out.println(bonusCalculator.getValue());
System.out.println(axeCalculator.getValue());
    </pre>

    <pre>
7
7
    </pre>

    <p>Both <code>bonusCalculator</code>and <code>axeCalculator</code> point to the same object, after we have run the command <code>bonusCalculator = axeCalculator;</code>, and therefore, now they both have the same value 7, even though we have increased only one of them.</p>

    <p>The situation might be clear if we look at the following picture. The method <code>axeCalculator.increaseValue()</code> increases by one the <code>value</code> variable of the object pointing to the <code>axeCalculator</code> variable. Because <code>bonusCalculator</code> points to the same object, the method <code>bonusCalculator.getValue()</code> returns the same value which was increased by the method <code>axeCalculator.increaseValue()</code>.</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/reference-type-calculators-val-changed.png" /></p>

    <p>In the following example, three reference-type variables all point to the same <code>Calculator</code> object.</p>

    <pre class="sh_java">
Calculator bonus = new Calculator(5);
Calculator ihq = bonus;
Calculator lennon = bonus;
    </pre>

    <p>In the example, we create only one <code>Calculator</code> object, but all the three <code>Calculator</code> variables point to that same one. Therefore, <code>bonus</code>, <code>ihq</code>, and <code>lennon</code> method calls all modify the same object. To tell it once again: when reference-type variables are copied, their references also duplicate. The same concept in a picture:</p>


    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/three-calculators-1.png" /></p>

    <p>Let's use this example to focus on duplication once more.</p>

    <pre class="sh_java">
Calculator bonus = new Calculator(5);
Calculator ihq = bonus;
Calculator lennon = bonus;

lennon = new Calculator(3);
    </pre>

    <p>The modification of the <code>lennon</code> variable contents â that is to say the change of reference â does not affect the references of either <code>bonus</code> or <code>ihq</code>. When we assign a value to a variable, we <em>only</em> change the contents of that variable's own slot. The same concept in a picture:</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/three-calculators-2.png" /></p>

    <h4>A Reference-Type Variables and Method Parameters</h4>

    <p>When a reference-type variable is given to a method as its parameter, we create a method parameter which is the copy of the reference of a variable. In other words, we copy the reference to the parameter's own slot. Differently from what happens with original-type variables, we copy the reference and not their value. In fact, we can modify the object behind the reference even from within the method. Let us take the method <code>public void addToCalculator(Calculator calculator, int amount)</code>.</p>

    <pre class="sh_java">
public void addToCalculator(Calculator calculator, int amount) {
    for (int i = 0; i &lt; amount; i++) {
        calculator.increaseValue();
    }
}
    </pre>

    <p>We give two parameters to the method <code>addToCalculator</code> â a reference-type value and an original-type variable. The contents of both variable slots are copied to method parameter slots. The reference-type parameter <code>calculator</code> receives a copy of a reference, whereas the original-type parameter <code>amount</code> receives the copy of value. The method will call the <code>increaseValue()</code> method of the <code>Calculator</code>-type parameter, and it will do it as many times as the value of the <code>amount</code> variable. Let us analyze the method call a little more deeply.</p>

    <pre class="sh_java">
int times = 10;

Calculator bonus = new Calculator(10);
addToCalculator(bonus, times);
// the bonus variable value is now 20
    </pre>

    <p>In the example we call the <code>addToCalculator</code> method, whose given variables are <code>bonus</code> and <code>times</code>. This means that the reference of the reference-type variable <code>bonus</code> and the value of the original-type variable <code>times</code>  (which is <code>10</code>) are copied as parameters whose names are <code>calculator</code> and <code>amount</code>, respectively. The method executes the <code>increaseValue()</code> method of the <code>calculator</code> variable a number of times which equals the value of <code>amount</code>. See the following picture:</p>


    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/refs-main-and-method-world.png" /></p>

    <p><em>The method contains variables which are completely separated from the main program!</em></p>

    <p>As far as the reference-type variable is concerned, a reference duplicates and it is given to the method, and the variable inside the method will still point to the same object. As far as the original-type variable is concerned, a value is copied, and the variable inside the method will have its completely independent value.</p>

    <p>The method recognises the calculator which the <code>bonus</code> variable points to, and the alterations made by the method have a direct impact on the object. The situation is different with original-type variables, and the method only receives a copy of the value of the <code>times</code> variable. In fact, it is not possible to modify the value of original-type variables directly within a method.</p>

    <h4>A method which returns a reference-type variable</h4>

    <p>When a method returns a reference-type variable, it returns the reference to an object located elsewhere. Once the reference is returned by a method, it can be assigned to a variable in the same way as a normal assignment would happen, through the equal sign (=). Let us have a look at the method <code>public Calculator createCalculator(int startValue)</code>, which creates a new reference-type variable.</p>

    <pre class="sh_java">
public Calculator createCalculator(int startValue) {
    return new Calculator(startValue);
}
    </pre>

    <p>The creteCalculator method creates an object and returns its <code>newCalculator</code> reference. By calling the method, we always create a new object. In the following example we create two different <code>Calculator</code>-type objects.</p>

    <pre class="sh_java">
Calculator bonus  = createCalculator(10);
Calculator lennon = createCalculator(10);
    </pre>

    <p>The method <code>createCalculator</code> always creates a new <code>Calculator</code>-type object. With the first call, <code>Calculator bonus  = createCalculator(10);</code> we assign the method return reference to the <code>bonus</code> variable. With the second call, we create another reference and we assign it to the <code>lennon</code> variable. The variables <code>bonus</code> and <code>lennon</code> do not contain the same reference because the method creates a new object in both cases, and it returns the reference to that particular object.</p>


    <h2 id="stat_ja_ei">Static and Non-Static</h2>


    <p>Let's further investigate a topic we introduced in the 30th section of Introduction to Programming. The static or non-static nature of a variable or of a method depends on their scope. Static methods are always related to their class, whereas non-static methods can modify the variables of the object itself.</p>

    <h3>Static, Class Libraries and Final</h3>

    <p>The methods which receive the definition static are not related to objects but to classes. it is possible to define class-specific variables by adding the word <code>static</code> to their name. For instance, <code>Integer.MAX_VALUE</code>, <code>Long.MIN_VALUE</code> and <code>Double.MAX_VALUE</code> are all static methods. Static methods are called via their class name, for instance <code>ClassName.variable</code> or <code>ClassName.method()</code>.</p>

    <p>We call <em>class library</em> a class which contains common-use methods and variables. For instance, Java <code>Math</code> class is a class library. It provides the <code>Math.PI</code> variable, inter alia. Often, creating your own class libraries can prove useful. Helsinki Regional Transport Authority (Finnish: Helsingin Seudun Liikenne, HSL) could use a class library to keep its ticket prices at its fingertips.</p>

    <pre class="sh_java">
public class HslPrices {
    public static final double SINGLETICKET_ADULT = 2.50;
    public static final double TRAMTICKET_ADULT = 2.50;
}
    </pre>

    <p>The keyword <code>final</code> in the variable definition tells that once we assign a value to a variable, we can not assign a new one to it. Final-type variables are constant, and they always have to have a value. For instance, the class variable which tells the greatest integer, <code>Integer.MAX_VALUE</code>, is a constant class variable.</p>

    <p>Once we have the class presented above, <code>HslPrices</code>, all the programs which need the single or tram-ticket price can have access to it through the class <code>HslPrices</code>. With the next example, we present the class <code>Person</code>, which has the method <code>enoughMoneyForSingleTicket()</code>, which makes use of the ticket price found in the class <code>HslPrices</code>.</p>

    <pre class="sh_java">
public class Person {
    private String name;
    private double money;
    // more object variables

    // constructor

    public boolean enoughMoneyForSingleTicket() {
        if(this.money >= HslPrices.SINGLETICKET_ADULT) {
            return true;
        }

        return false;
    }

    // the other methods regarding the class Person
}
    </pre>

    <p>The method <code>public boolean enoughMoneyForSingleTicket()</code> compares the object variable <code>money</code> of class <code>Person</code> to the static variable <code>SINGLETICKET_ADULT</code> of class <code>HslPrices</code>. The method <code>enoughMoneyForSingleTicket()</code> can be called only through an object reference. For instance:</p>

    <pre class="sh_java">
Person matti = new Person();

if (matti.enoughMoneyForSingleTicket()) {
    System.out.println("I'll buy a ticket.");
} else {
    System.out.println("Fare dodging, yeah!");
}
    </pre>

    <p>Note the naming convention! All <em>constants</em>, i.e. all variable which are provided with the definition final, are written with CAPITAL_LETTERS_AND_UNDERLINE_CHARACTERS.</p>

    <p>Static methods function analogously. For instance, the class <code>HslPrices</code> could <em>encapsulate</em> the variables and only provide <em>accessors</em>. We call accessors the methods which allow us to either read a variable value or to assign them a new one.</p>

    <pre class="sh_java">
public class HslPrices {
    public static final double SINGLETICKET_ADULT = 2.50;
    public static final double TRAMTICKET_ADULT = 2.50;

  public static double getSingleTicketPrice() {   // Accessor
    return SINGLETICKET_ADULT;
  }

  public static double getTramTicketPrice() {   // Accessor
    return TRAMTICKET_ADULT;
  }
}
    </pre>

    <p>In such cases, when we code a class such as <code>Person</code>, we can't call the variable straight, but we have to get it through the method <code>getSingleTicketPrice()</code>.</p>

    <pre class="sh_java">
public class Peson {
    private String name;
    private double money;
    // other object variables

    // constructor

    public boolean enoughMoneyForSingleTicket() {
        if(this.money >= HslPrices.giveSingleTicketPrice()) {
            return true;
        }

        return false;
    }

    // other methods regarding the class Person
}
    </pre>


    <p>Even though Java allows for static variable use, we do not usually require it. Often, using static methods causes problems with the program structure, because static variables are as inconvenient as <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">global variables</a>. <b>The only static variables we use in this course are constant, i.e. final!</b></p>

    <h3>Non-Static</h3>

    <p>Non-static methods and variables are related to objects. The object variables, or attributes, are defined at the beginning of the class. When an object is created with the <code>new</code> operator, we allocate storage space for all its object variables. The variable values are personal of the object, which means that every object receives personal variable values. Let us focus again on the class <code>Person</code>, which has the object variable <code>name</code> and <code>money</code>.</p>

    <pre class="sh_java">
public class Person {
  private String name;
  private double money;

  // other details
}
    </pre>

    <p>When we create a new instance of class <em>Person</em>, we also initialize its variables. If we do not initialize the reference-type variable <code>name</code>, it receives value <em>null</em>. Let us add the <em>constructor</em> and a couple of methods to our class <em>Person</em>.</p>

    <pre class="sh_java">
public class Person {
  private String name;
  private double money;

    // constructor
    public Person(String name, double money) {
        this.name = name;
        this.money = money;
    }

    public String getName() {
        return this.name;
    }

    public double getMoney() {
        return this.money;
    }

    public void addMoney(double amount) {
        if(amount &gt; 0) {
          this.money += amount;
        }
    }

    public boolean enoughMoneyForSigleTicket() {
        if(this.money >= HslPrices.getSingleTicketPrice()) {
            return true;
        }

        return false;
    }
}
    </pre>

    <p>The constructor <code>Person(String name, double money)</code> creates a new Person object, and it returns its reference. The method <code>getName()</code> returns the reference to a <code>name</code> object, and the <code>getMoney()</code> method returns the original-type variable <code>money</code>. The method <code>addMoney(double amount)</code> receives as parameter an amount of money, and it adds it to the <code>money</code> object variable if the parameter's value is greater than 0.</p>

    <p>Object methods are called through their object reference. The following code example creates a new Person object, increases its money, and prints its name, at the end. Note that the method calls follow the pattern <code>objectName.methodName()</code></p>

    <pre class="sh_java">
Person matti = new Person("Matti", 5.0);
matti.addMoney(5);

if (matti.enoughMoneyForSingleTicket()) {
    System.out.println("I'll buy a single ticket.");
} else {
    System.out.println("Fare dodging, yeah!");
}
    </pre>

    <p>The example prints "<code>I'll buy a single ticket.</code>"</p>

    <h4>Class Methods</h4>

    <p>Non-static class methods can be also called without specifying the object which indicates the class. In the following example, the <code>toString()</code> method points to the class <code>Person</code>, which calls the object method <code>getName()</code>.</p>

    <pre class="sh_java">
public class Person {
    // earlier written content

    public String toString() {
        return this.getName();
    }
}
    </pre>

    <p>The <code>toString()</code> method calls the class method <code>getName()</code>, which belongs to the object in question. The <code>this</code> prefix emphasizes that the call refers precisely to this object.</p>

    <p>Non-static methods can also call static methods, that is the class-specific ones. On the other hand, static methods can not call non-static methods without a reference to the object itself, which is essential to retrieve the object information.</p>


    <h4>A Variable within a Method</h4>

    <p>The variables which are defined inside a method are auxiliary variables used during the method execution, and they are not to be confused with object variables. The example below shows how a local variable is created inside a method. The <code>index</code> variable exists and is accessible only during the method execution.</p>

    <pre class="sh_java">
public class ... {
    ...

    public static void printTable(String[] table) {
        int index = 0;

        while(index &lt; table.length) {
            System.out.println(table[index]);
            index++;
        }
    }
}
    </pre>

    <p>In the <code>printTable()</code> method, we create the auxiliary variable <code>index</code> which we use to parse the table. The variable <code>index</code> exists only during the method execution.</p>


    <div class="tehtavat">
      <div class="tehtava">
        <h3>Thing, Suitcase, and Container</h3>

        <p>In these exercises, we create the classes <code>Thing</code>, <code>Suitcase</code>, and <code>Container</code>, and we train to use objects which contain other objects.</p>

        <h4 class="req">Class Thing</h4>

        <p>Create the class <code>Thing</code> whose objects can represent different kinds of things. The information to store are the thing's name and weight (kg).</p>

        <p>Add the following methods to your class:</p>

        <ul>
          <li>A construsctor, which is given the thing's name and weight as parameter</li>
          <li><code>public String getName()</code>, which returns the thing's name</li>
          <li><code>public int getWeight()</code>, which returns the thing's weight</li>
          <li><code>public String toString()</code>, which returns a string in the form "name (weight kg)"</li>
        </ul>

        <p>Below, you find an example of how to use the class:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);

        System.out.println("Book name: " + book.getName());
        System.out.println("Book weight: " + book.getWeight());

        System.out.println("Book: " + book);
        System.out.println("Mobile: " + mobile);
    }
}
        </pre>

        <p>The program output should look like the following:</p>

        <pre>
Book name: Happiness in Three Steps
Book weight: 2
Book: Happiness in Three Steps (2 kg)
Mobile: Nokia 3210 (1 kg)
        </pre>

        <h4 class="req">Class Suitcase</h4>

        <p>Create the class <code>Suitcase</code>. <code>Suitcase</code> has <code>things</code> and a maximum weight limit, which defines the greatest total allowed weight of the things contained within the <code>Suitcase</code> object.</p>

        <p>Add the following methods to your class:</p>

        <ul>
          <li> A constructor, which is given a maximum weight limit</li>
          <li><code>public void addThing(Thing thing)</code>, which adds the <code>thing</code> in the parameter to your suitcase. The method does not return any value.</li>
          <li><code>public String toString()</code>, which returns a string in the form "x things (y kg)"</li>
        </ul>

        <p>The <code>things<code> are saved into an <code>ArrayList</code> object:</p>

            <pre class="sh_java">
ArrayList&lt;Thing&gt; things = new ArrayList&lt;Thing&gt;();
            </pre>

            <p>The class <code>Suitcase</code> has to make sure the thing's weight does not cause the total weight to exceed the maximum weight limit. The method <code>addThing</code> should not add a new thing if the total weight happens to exceed the maximum weight limit.</p>

            <p>Below, you find an example of how the class can be used:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in three steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase suitcase = new Suitcase(5);
        System.out.println(suitcase);

        suitcase.addThing(book);
        System.out.println(suitcase);

        suitcase.addThing(mobile);
        System.out.println(suitcase);

        suitcase.addThing(brick);
        System.out.println(suitcase);
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
0 things (0 kg)
1 things (2 kg)
2 things (3 kg)
2 things (3 kg)
            </pre>

            <h4>Language Check</h4>

            <p>"0 things" or "1 things" is not really proper English &ndash; it would be better to say "empty" or "1 thing". Implement this change in the class <code>Suitcase</code>.</p>

            <p>Now, the output of the previous program should look like the following:</p>

            <pre>
empty (0 kg)
1 thing (2 kg)
2 things (3 kg)
2 things (3 kg)
            </pre>

            <h4 class="req">Every Thing</h4>

            <p>Add the following methods to <code>Suitcase</code>:</p>

            <ul>
              <li> <code>printThings</code>, which prints out all the <code>things</code> inside the suitcase</li>
              <li> <code>totalWeight</code>, which returns the total weight of the <code>things</code> in your suitcase</li>
            </ul>

            <p>Below, there is an example of how the class can be used:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase suitcase = new Suitcase(10);
        suitcase.addThing(book);
        suitcase.addThing(mobile);
        suitcase.addThing(brick);

        System.out.println("Your suitcase contains the following things:");
        suitcase.printThings();
        System.out.println("Total weight: " + suitcase.totalWeight() + " kg");
    }
}
            </pre>

            <p>The program output should now look like the following:</p>

            <pre>Your suitcase contains the following things:
Happiness in Three Steps (2 kg)
Nokia 3210 (1 kg)
Brick (4 kg)
Total weight: 7 kg
            </pre>


            <p>Modify your class also so that you use only two object variables. One contains the maximum weight, the other is a list with the things in your suitcase.</p>

            <h4 class="req">The heaviest Thing</h4>

            <p>Now, add the method <code>heaviestThing</code> to your class <code>Suitcase</code>, which returns the thing which weighs the most. If there are more than one <code>thing</code> with the same weight, the method can return either one. The method has to return an object reference. If the suitcase is empty, the method returns <em>null</em>.</p>

            <p>Here is an usage example of the class:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase suitcase = new Suitcase(10);
        suitcase.addThing(book);
        suitcase.addThing(mobile);
        suitcase.addThing(brick);

        Thing heaviest = suitcase.heaviestThing();
        System.out.println("The heaviest thing: " + heaviest);
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
The heaviest thing: Brick (4 kg)
            </pre>

            <h4 class="req">Container</h4>

            <p>Create the class <code>Container</code>, which has the following methods:</p>

            <ul>
              <li> a constructor which is given the maximum weight limit</li>
              <li> <code>public void addSuitcase(Suitcase suitcase)</code>, which adds the suitcase as a parameter to the container</li>
              <li> <code>public String toString()</code> which returns a string in the form "x suitcases (y kg)"</li>
            </ul>

            <p>Store the suitcase with a suitable <code>ArrayList</code> construction.</p>

            <p>The class <code>Container</code> has to make sure the <code>thing</code>'s total weight does not overcome the maximum weight limitation. The method <code>addSuitcase</code> should not add a new suitcase if the total weight happens to exceed the maximum weight limit.</p>

            <p>Below, there is an example of how the class can be used:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase tomsCase = new Suitcase(10);
        tomsCase.addThing(book);
        tomsCase.addThing(mobile);

        Suitcase georgesCase = new Suitcase(10);
        georgesCase.addThing(brick);

        Container container = new Container(1000);
        container.addSuitcase(tomsCase);
        container.addSuitcase(georgesCase);

        System.out.println(container);
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
2 suitcases (7 kg)
            </pre>

            <h4 class="req">The Container Contents</h4>

            <p>Add the method <code>public void printThings()</code> to your <code>Container</code>; the method prints out all the things inside the container's suitcases.</p>

            <p>Below is an example of how the class can be used:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase tomsCase = new Suitcase(10);
        tomsCase.addThing(book);
        tomsCase.addThing(mobile);

        Suitcase georgesCase = new Suitcase(10);
        georgesCase.addThing(brick);

        Container container = new Container(1000);
        container.addSuitcase(tomsCase);
        container.addSuitcase(georgesCase);

        System.out.println("There are the following things in the container suitcases:");
        container.printThings();
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
There are the following things in the container suitcases:
Happiness in Three Steps (2 kg)
Nokia 3210 (1 kg)
Brick (4 kg)
            </pre>

            <h4>A Lot of Bricks</h4>

            <p>Let's check that our container works fine and we can still not exceed the maximum weight limit. In the <code>Main</code> class, create the method <code>public static void addSuitcasesFullOfBricks(Container container)</code>, which adds 100 suitcases into the container it receives as parameter; there is one brick in each suitcase. The bricks weight will then increase by one each time until the weight becomes 100 kg.</p>

            <p>The program body is the following:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] Container) {
        Container container = new Container(1000);
        addSuitcasesFullOfBricks(container);
        System.out.println(container);
    }

    public static void addSuitcasesFullOfBricks(Container container) {
        // adding 100 suitcases with one brick in each
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
44 suitcases (990 kg)
            </pre>

          </div>
        </div>

        <h2 id="hashmap">HashMap</h2>

        <p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html">HashMap</a> is one of Java's most useful data structures. The idea behind HashMap is we define an index for an object key - a unique value, for instance a social security number, a student number, or a phone number. We call <em>hashing</em> the process of changing a key into an index, or simply to define an index. The hashing happens thanks to a particular function which makes sure that we get always the same index with a known key.</p>

        <p>Adding and retrieving items based on the keys allows for a particularly quick search process. Instead of parsing the table items one by one (in the worst case we would have to go through all the items), and instead of looking for a value with a binary search (in which case we would have to go through a number of items which would depend on the logarithm of the table size), we can look at only one table index and check whether a value is mapped to that index.</p>

        <p>HashMap uses the <code>Object</code> class <code>hashCode()</code> method to find a key value. Every HashMap subclass will <em>inherit</em> the <code>hashCode()</code> method. However, we will not go deep into HashMap workings in this course. We will return to inheritance in week 10.</p>


        <p>Java's <code>HashMap</code> class encapsulates - or hides - the way it works, and it returns made-up methods ready to use.</p>

        <p>When we create a HashMap we need two <em>type parameters</em>, a type for the key variable, and a type for the stored object. The following example uses a <code>String</code>-type object as key, and a <code>String</code>-type object as the stored object.</p>


        <pre class="sh_java">
HashMap&lt;String, String&gt; numbers = new HashMap&lt;String, String&gt;();
numbers.put("One", "Yksi");
numbers.put("Two", "Kaksi");

String translation = numbers.get("One");
System.out.println(translation);

System.out.println(numbers.get("Two"));
System.out.println(numbers.get("Three"));
System.out.println(numbers.get("Yksi"));
        </pre>

        <pre>
Yksi
Kaksi
null
null
        </pre>


        <p>In the example, we create a HashMap where both the key and the stored object are strings. We add information to the HashMap with the <code>put()</code> method, which receives the references to the key and to the stored object as parameter. The method <code>get()</code> returns either the reference to the key given as parameter or a <code>null</code> value in case the key was not found.</p>

        <p>Each key is mapped to one value, within the HashMap. If we store a new value with an already existing key, the old value is lost.</p>

        <pre class="sh_java">
HashMap&lt;String, String&gt; numbers = new HashMap&lt;String, String&gt;();
numbers.put("One", "Yksi");
numbers.put("Two", "Kaksi");
numbers.put("One", "Uno");

String translation = numbers.get("One");
System.out.println(translation);

System.out.println(numbers.get("Two"));
System.out.println(numbers.get("Three"));
System.out.println(numbers.get("Yksi"));
        </pre>

        <p>Because the key "<code>One</code>" is assigned a new value, the print output of the example is like the following.</p>

        <pre>
Uno
Kaksi
null
null
        </pre>

        <div class="tehtavat">
          <div class="tehtava">
            <h3>Nicknames</h3>

            <p>Create a <code>HashMap&lt;String,String&gt;</code> object in the <code>main</code> method. Store the following people's names and nicknames into the HashMap, the name being the key and the nickname its value. Use only lower case letters.</p>

            <ul>
              <li>matti's nickname is mage</li>
              <li>mikael's nickname is mixu</li>
              <li>arto's nickname is arppa</li>
            </ul>

            <p>Then, retrieve mikael's nickname and print it.</p>

            <p>The tests require you write lower case names.</p>

          </div>
        </div>
        <h3 id="kirjastotietokanta">Book Search through HashMap</h3>

        <p>Let us go deeper into HashMap workings with the help of the following example. Books can be retrieved based on their name, which acts as book key. If we find a book for the given name, we obtain the respective reference, as well as the book details. Let us create the example class <code>Book</code>, which has a name and the book contents as object variables.</p>

        <pre class="sh_java">
public class Book {
    private String name;
    private String contents;
    private int publishingYear;

    public Book(String name, int publishingYear, String contents) {
        this.name = name;
        this.publishingYear = publishingYear;
        this.contents = contents;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    public void setPublishingYear(int publishingYear) {
        this.publishingYear = publishingYear;
    }

    public String getContents() {
        return this.contents;
    }

    public void setContents(String contents) {
        this.contents = contents;
    }

    public String toString() {
        return "Name: " + this.name + " (" + this.publishingYear + ")\n"
                + "Contents: " + this.contents;
    }
}
        </pre>

        <p>In the following example, we create a HashMap which makes use of the book name - a String-type object - and stores the references which point to <code>Book</code>-objects.</p>

        <pre class="sh_java">
HashMap&lt;String, Book&gt; bookCollection = new HashMap&lt;String, Book&gt;();
        </pre>

        <p>The HashMap above has a <code>String</code> object as key. Let us extend our example so that we would add two books to our book collection, <code>"Sense and Sensibility"</code> and <code>"Pride and Prejudice"</code>.</p>

        <pre class="sh_java">
Book senseAndSensibility = new Book("Sense and Sensibility", 1811, "...");
Book prideAndPrejudice = new Book("Pride and Prejudice", 1813, "....");

HashMap&lt;String, Book&gt; bookCollection = new HashMap&lt;String, Book&gt;();
bookCollection.put(senseAndSensibility.getName(), senseAndSensibility);
librabookCollectionry.put(prideAndPrejudice.getName(), prideAndPrejudice);
        </pre>

        <p>Books can be retrieved from the book collection based on their name. A search for the book <code>"Persuasion"</code> does not return a corresponding entry, in which case the HashMap returns a <code>null</code> reference. However, the book "Pride and Prejudice" was found.</p>

        <pre class="sh_java">
Book book = bookCollection.get("Persuasion");
System.out.println(book);
System.out.println();
book = bookCollection.get("Pride and Prejudice");
System.out.println(book);
        </pre>

        <pre>
null

Name: Pride and Prejudice (1813)
Contents: ...
        </pre>

        <p>HashMaps are useful when we know the key to use for our search. Keys are always unique, and it is not possible to store more than one object together with one key alone. The object which we store can still be a <em>list</em> or another HashMap, of course!</p>

        <h3 id="kapseloitu_kirjasto">Library</h3>

        <p>The problem with the book collection above is that we must remember the correct book name when we search for it, character by character. Java built-in <code>String</code> class provides us the tools for this. The <code>toLowerCase()</code> method turns a string's characters to lower case, and the <code>trim()</code> method deletes the white spaces at the beginning and at the end of the string. Computer users tend to write white spaces at the beginning or end of a text, involuntarily.</p>

        <pre class="sh_java">
String text = "Pride and Prejudice ";
text = text.toLowerCase(); // the text is now "pride and prejudice "
text = text.trim() // the text is now "pride and prejudice"
        </pre>

        <p>Let us create the the class <code>Library</code>, which encapsulates a HashMap containing books, and allows for book search regardless of its spelling. Let us add the methods <code>addBook(Book book)</code> and <code>removeBook(String bookName)</code> to our <code>Library</code> class. It's already clear that we would need various different methods to clean a string. Therefore, we can create a separate method called <code>private String stringCleaner(String string)</code>.</p>

        <pre class="sh_java">
public class Library {
    private HashMap&lt;String, Book&gt; collection;

    public Library() {
        this.collection = new HashMap&lt;String, Book&gt;();
    }

    public void addBook(Book book) {
        String name = stringCleaner(book.getName());

        if(this.collection.containsKey(name)) {
            System.out.println("The book is already in the library!");
        } else {
            collection.put(name, book);
        }
    }

    public void removeBook(String bookName) {
        bookName = stringCleaner(bookName);

        if(this.collection.containsKey(bookName)) {
            this.collection.remove(bookName);
        } else {
            System.out.println("The book was not found, you can't remove it!");
        }
    }

    private String stringCleaner(String string) {
        if (string == null) {
            return "";
        }

        string = string.toLowerCase();
        return string.trim();
    }
}
        </pre>
        <p>We implement our search functionality so that we can retrieve a book using a hash algorithm based on the book name.</p>

        <pre class="sh_java">
    public Book getBook(String bookName) {
        bookName = stringCleaner(bookName);
        return this.collection.get(bookName);
    }
        </pre>

        <p>The method above returns the wanted book when this is found, otherwise it returns a <code>null</code> value. We can also also go through all the collection keys one by one, and look for the beginning characters of the book's name. In this way, we would actually fail to capitalise on HashMap performance speed because, in the worst case, we would need to go through all the book names. Search based on the beginning characters of a string is possible through the <code>keySet()</code> method. The <code>keySet()</code> method returns a set of keys, which can be parsed with the <code>for each</code> loop.</p>

        <pre class="sh_java">
    public Book getBookUsingItsBeginningCharacters(String beginning) {
        beginning = stringCleaner(beginning);

        for (String key: this.collection.keySet()) {
            if (key.startsWith(beginning)) {
                return this.collection.get(key);
            }
        }

        return null;
    }
        </pre>

        <p>Let's leave the method above out of our library for now. Our library is still lacking an essential feature concerning book addition. Let us create the method <code>public ArrayList&lt;Book&gt; bookList()</code>, which returns a list of the books in our library. The method <code>bookList()</code> makes use of the <code>values()</code> method, which is provided by HashList. The <code>values()</code> method returns a set of our library books, which can be given as parameter to the constructor of an <code>ArrayList</code> class.</p>

        <pre class="sh_java">
public class Library {
    private HashMap&lt;String, Book&gt; collection;

    public Library() {
        this.collection = new HashMap&lt;String, Book&gt;();
    }

    public Book getBook(String bookName) {
        bookName = stringCleaner(bookName);
        return this.collection.get(bookName);
    }

    public void addBook(Book kirja) {
        String name = stringCleaner(book.getName());

        if(this.collection.containsKey(name)) {
            System.out.println("The book is already in the library!");
        } else {
            this.collection.put(name, book);
        }
    }

    public void removeBook(String bookName) {
        bookName = stringCleaner(bookName);

        if(this.collection.containsKey(bookName)) {
            this.collection.remove(bookName);
        } else {
            System.out.println("The book was not found, you can't remove it!");
        }
    }

    public ArrayList&lt;Book&gt; bookList() {
        return new ArrayList&lt;Book&gt;(this.collection.values());
    }

    private String stringCleaner(String string) {
        if (string == null) {
            return "";
        }

        string = string.toLowerCase();
        return string.trim();
    }
}
        </pre>

        <p>Among the programming principles, there is the so called <em>DRY</em> principle (Don't Repeat Yourself), according to which we try to avoid having code repeat in different places. Turning a string to lower case, and its <em>trimming</em> - removing white spaces from the beginning and the end of a string - would have ocurred several different places without the <code>stringCleaner()</code> method. We might hardly notice we are repeating the same code as we are writing. It is only afterwards we may see the repeated code has snuck in there. That the repetition happens is not in itself bad, however. The most important thing is that we clean our code as soon as we notice the need.</p>


        <h3>Original-Type Variables in a HashMap</h3>

        <p>Both HashMap keys and stored objects are reference-type variables. If we want to use an original-type variable as key or stored value, we can use their reference-type equivalent. Some are introduced below.</p>

        <p>
        <table>
          <tr><th>Original-type</th><th>Reference-type equivalent</th><tr>
              <tr><td>int</td><td><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html" target="_blank">Integer</a></td></tr>
              <tr><td>double</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Double.html" target="_blank">Double</a></td></tr>
              <tr><td>char</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_blank">Character</a></td></tr>
            </table>
            </p>

            <p>In fact, Java automatically encapsulates original-type values and translates them into reference-type values when needed. Even though the number <code>1</code> is an original-type variable, it can be used as an <code>Integer</code> key directly in the following way.</p>

            <pre class="sh_java">
HashMap&lt;Integer, String&gt; table = new HashMap&lt;Integer, String&gt;();
table.put(1, "Be!");
            </pre>

            <p>In Java, the automatic translation of original-type variables into reference-type ones is called <em>auto-boxing</em>, i.e. allocation into a slot. The same process also works in the opposite way. We can create a method which returns a HashMap containing an Integer. In the following example, the automatic translation happens inside the method <code>addTwitch</code>.</p>


            <pre class="sh_java">
public class TwitchRegister {
    private HashMap&lt;String, Integer&gt; twitched;

    public NumberBookkeeping() {
        this.twitched = new HashMap&lt;String, Integer&gt;();
    }

    public void addTwitch(String name, int number) {
        this.twitched.put(name, number);
    }

    public int lastTwitch(String name) {
        this.twitched.get(name);
    }
}
            </pre>

            <p>Even though the HashMap contains Integer objects, Java can also translate certain reference-type variables into their original-type equivalent. For instance, <code>Integer</code> objects can be translated into <code>int</code> values, if needed. However, this can be misleading! If we try to translate a null reference into a number, we receive the <em>java.lang.reflect.InvocationTargetException</em> error. When we make use of this automatic translation, we have to be sure that the value we want to translate is not null. The above <code>lastTwitch</code> method must be fixed in the following way.</p>

            <pre class="sh_java">
    public int lastTwitch(String name) {
        if(this.twitched.containsKey(name) {
            return this.twitched.get(name);
        }

        return 0;
    }
            </pre>



            <div class="tehtavat">
              <div class="tehtava">
                <h3>Promissory Note</h3>

                <p>Create the class <code>PromissoryNote</code> with the following functionality:</p>

                <ul>
                  <li> the constructor <code>public PromissoryNote()</code> creates a new promissory note</li>
                  <li> the method <code>public void setLoan(String toWhom, double value)</code> which stores the information about loans to specific people.</li>
                  <li> the method <code>public double howMuchIsTheDebt(String whose)</code> which returns the entity of the debt held by the parameter <code>person</code></li>
                </ul>

                <p>The class can be used in the following way:</p>

                <pre class="sh_java">
  PromissoryNote mattisNote = new PromissoryNote();
  mattisNote.setLoan("Arto", 51.5);
  mattisNote.setLoan("Mikael", 30);

  System.out.println(mattisNote.howMuchIsTheDebt("Arto"));
  System.out.println(mattisNote.howMuchIsTheDebt("Joel"));
                </pre>

                <p>The example above would print:</p>

                <pre>
51.5
0
                </pre>

                <p>Be careful in a situation where you ask for the debt of a person who hasn't got debts. Go back to the final example of section 36.3, if you need!</p>

                <p>Attention! The promissory note does not need to take into account old loans. When you set a new debt to a person who has an old one, the old one is canceled.</p>

                <pre class="sh_java">
  PromissoryNote mattisNote = new PromissoryNote();
  mattisNote.setLoan("Arto", 51.5);
  mattisNote.setLoan("Arto", 10.5);

  System.out.println(mattisNote.howMuchIsTheDebt("Arto"));
                </pre>

                <pre>
10.5
                </pre>
              </div>
              <div class="tehtava">
                <h3>Dictionary</h3>

                <p>In this exercise, we implement a dictionary which can be used to retrieve the English translation of Finnish words. We implement our dictionary using the <code>HashMap</code> data structure.</p>

                <h4 class="req">Class Dictionary</h4>

                <p>Create a class called <code>Dictionary</code>. The class has the following methods:</p>

                <ul>
                  <li> <code>public String translate(String word)</code>, returning the translation of its parameter. If the word is unknown, it returns <em>null</em>.</li>
                  <li> <code>public void add(String word, String translation)</code>, adding a new translation to the dictionary</li>
                </ul>

                <p>Implement the class Dictionary so that it contained only one object variable, a <code>HashMap</code> data structure.</p>

                <p>Test your Dictionary:</p>

                <pre class="sh_java">
    Dictionary dictionary = new Dictionary();
    dictionary.add("apina", "monkey");
    dictionary.add("banaani", "banana");
    dictionary.add("cembalo", "harpsichord");

    System.out.println(dictionary.translate("apina"));
    System.out.println(dictionary.translate("porkkana"));
                </pre>

                <pre>
monkey
null
                </pre>

                <h4>Amount of Words</h4>

                <p>Add the method <code>public int amountOfWords()</code>, which returns the amount of words in the dictionary.</p>

                <pre class="sh_java">
    Dictionary dictionary = new Dictionary();
    dictionary.add("apina", "monkey");
    dictionary.add("banaani", "banana");
    System.out.println(dictionary.amountOfWords());

    dictionary.add("cembalo", "harpsichord");
    System.out.println(dictionary.amountOfWords());
                </pre>


                <pre>
2
3
                </pre>

                <h4>Listing All Words</h4>

                <p>Add the method <code>public ArrayList&lt;String&gt; translationList()</code> to your dictionary, returning strings which stand for a content list of your dictionary in the form <i>key = value</i>.</p>

                <pre class="sh_java">
    Dictionary dictionary = new Dictionary();
    dictionary.add("apina", "monkey");
    dictionary.add("banaani", "banana");
    dictionary.add("cembalo", "harpsichord");

    ArrayList&lt;String&gt; translations = dictionary.translationList();
    for(String translation: translations) {
        System.out.println(translation);
    }
                </pre>

                <pre>
banaani = banana
apina = monkey
cembalo = harpsichord
                </pre>

                <p><strong>Hint:</strong> you can go through all HashMap keys using the method <code>keySet</code> in the following way:</p>

                <pre class="sh_java">
    HashMap&lt;String, String&gt; wordPairs = new HashMap&lt;String, String&gt;();

    wordPairs.put("monkey", "animal");
    wordPairs.put("South", "compass point");
    wordPairs.put("sauerkraut", "food");

    for ( String key : wordPairs.keySet() ) {
        System.out.print( key + " " );
    }

    // prints: monkey South sauerkraut
                </pre>



                <h4 class="req">The Beginning of a Text User Interface</h4>

                <p>In this exercise, we also train creating a text user interface. Create the class <code>TextUserInterface</code>, with the following methods:
                <ul>
                  <li> the constructor <code>public TextUserInterface(Scanner reader, Dictionary dictionary)</code></li>
                  <li> <code>public void start()</code>, which starts the interface.</li>
                </ul>
                </p>

                <p>The text user interface stores into two object variables the reader and dictionary it has received as constructor parameters. You don't need other object variables.
                <strong>
                  The user input must be read using the reader object received as constructor parameter! The translations also have to be stored into the dicitonary object received as constructor parameter. The text user interface must not create new objects itself!
                </strong>
                </p>

                <p><strong>Attention:</strong> This means <strong>The text user interface must not create a scanner itself</strong> but it must use the scanner received as parameter to read the user input!</p>

                <p>At the beginning, in the text user interface must only have the command <code>quit</code>, to quit the text user interface. If the user inputs something else, we print "Unknown statement".</p>

                <pre class="sh_java">
    Scanner reader = new Scanner(System.in);
    Dictionary dict = new Dictionary();

    TextUserInterface ui = new TextUserInterface(reader, dict);
    ui.start();
                </pre>

                <pre>
Statement:
  quit - quit the text user interface

Statement: <font color="red">help</font>
Unknown statement

Statement: <font color="red">quit</font>
Cheers!
                </pre>

                <h4 class="req">Adding and Translating Words</h4>

                <p>Add the methods <code>add</code> and <code>translate</code> to your text user interface. The command <code>add</code> asks for a word pair from the user and adds them to the dictionary. The command <code>translate</code> asks a word from the user and it prints the translation.</p>

                <pre class="sh_java">
    Scanner reader = new Scanner(System.in);
    Dictionary dict = new Dictionary();

    TextUserInterface ui = new TextUserInterface(reader, dict);
    ui.start();
                </pre>

                <pre>
Statements:
  add - adds a word pair to the dictionary
  translate - asks a word and prints its translation
  quit - quits the text user interface

Statement: <font color="red">add</font>
In Finnish: <font color="red">porkkana</font>
Translation: <font color="red">carrot</font>

Statement: <font color="red">translate</font>
Give a word: <font color="red">porkkana</font>
Translation: carrot

Statement: <font color="red">quit</font>
Cheers!
                </pre>

              </div>
            </div>

            <h2>Towards Automatic Tests</h2>

            <p>Testing a program manually is a hopeless burden. It is possible to automate inputs by setting up a string as a Scanner object parameter. The example below shows how it is possible to test automatically the program above.</p>

            <pre class="sh_java">
    String input = "translate\n" + "monkey\n"  +
                   "translate\n" + "cheese\n" +
                   "add\n"  + "cheese\n" + "juusto\n" +
                   "translate\n" + "cheese\n" +
                   "quit\n";

    Scanner reader = new Scanner(input);
    Dictionary dictionary = new Dictionary();

    TextUserInterface ui = new TextUserInterface(reader, dictionary);
    ui.start();
            </pre>

            <p>The print output contains only the program output, and not the user commands.</p>

            <pre>
Commands:
  add - adds a word couple to the dictionary
  translate - asks for a word and prints its translation
  quit - stops the user interface

Command: Give word: Unknown word!

Command: Give word: Unknown word!

Command: In Finnish: Translation:
Command: Give word: Translation: juusto

Command: Cheers!
            </pre>

            <p>Giving a string to a Scanner class is a way to replace the String inputs given through the keyboard. The contents of the String variable <code>input</code> "simulates" the user input. <code>\n</code> denotes a line break. Each single part of the <code>input</code> variable which ends with a line break corresponds to one nextLine() input.</p>

            <p>It is easy to change the text input, and we can add new words to our dictionary in the following way:</p>

            <pre class="sh_java">
    String input = "add\n"  + "cheese\n" + "juusto\n" +
                   "add\n"  + "bier\n" + "olut\n" +
                   "add\n"  + "book\n" + "kirja\n" +
                   "add\n"  + "computer\n" + "tietokone\n" +
                   "add\n"  + "auto\n" + "car\n" +
                   "quit\n";
            </pre>

            <p>If you want to test again your program manually, change the Scanner object constructor parameter into <code>System.in</code>, i.e system input stream.</p>

            <p>The program functionality must be checked from the output pane, still. The result can still be confusing at the beginning, because the automatic input does not appear in the output pane at all.</p>

            <p>The final goal will be to also automate the testing the program's functionality, so that both testing the program and analising its output text would happen successfully in one click.</p>




            <h2>Java API</h2>

            <p>The Java programming language we use in our course is made of three things. The first is the program syntax and semantics: the way we define variables, the control flow, the variable and class structure, and their functionality. The second is JVM, i.e. <em>Java Virtual Machine</em>, used for running our programs. Our Java programs are translated into a <em>bytecode</em>, which can be run on whatever computer has JVM. We haven't dealt with program translation because the program environment does it on our behalf. Sometimes, if the program environtment does not work as expected we may have to choose <em>clean & build</em>, which deletes the old source code and translates our program again. The third is API (<em>Application Programming Interface</em>), that is to say the program interface or standard library.</p>

            <p>API is a set of built-in classes specific of the programming language, which is provided to users for their own projects. For instance the casses <code>ArrayList</code>, <code>Arrays</code>, <code>Collections</code>, and <code>String</code> are all part of Java's build-in API. A description of the API of Java 7 can be found at the address <a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank">http://docs.oracle.com/javase/7/docs/api/</a>. On the left side of the page we find a description of Java's built-in classes. If you look for the <code>ArrayList</code> class, you  find a link to <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank">http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html</a>, which shows the stucture, constructors, and methods of the class.</p>

            <p>NetBeans is able to show a class API, if needed. If you write a class name and add the relative import sentence, you can right click on the class name and and choose <em>Show Javadoc</em>. This opens the class API description in your browser.</p>

            <div class="tehtavat">

              <div class="tehtava">
                <h3>Airport</h3>

                <p>Every week, you will find one or more larger exercises, where you can design freely the program structure, the appearance of the user interface and the requred commands are predefined. The first exercise which you can design freely in Advanced Programming is <em>Airport</em>.</p>

                <p><b>Attention: you can create only one Scanner object so that your tests would work well. Also, do not use static variables, the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</b></p>

                <p>In the airport exercises we create an application to manage an airport, with its airplanes and flights. As far as the planes are concerned, we always know their ID and capacity. As for the flights, we know the plane used for the flight, the departure airport code (for instance <a href="http://en.wikipedia.org/wiki/Helsinki_Airport" target="_blank">HEL</a>) and the destination airport code (for instance <a href="http://en.wikipedia.org/wiki/Batman_Airport" target="_blank">BAL</a>).</p>

                <p>There can be various different flights and planes. The same plane can also go on various different flights (various different routes). The application must offer two different panels. First, the airport worker inputs the flight and plane information to the system in the airport panel.</p>

                <p>When the user exits the airport panel, the user then proceeds to use the flight service. The flight service has three actions: printing planes, printing flights, and printing airplane information. In addition to this, the user can exit the application by choosing <code>x</code>. If the user inputs an invalid command, the command is asked again.</p>


                <pre>
Airport panel
--------------------

Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
> <font color="red">1</font>
Give plane ID: <font color="red">HA-LOL</font>
Give plane capacity: <font color="red">42</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
> <font color="red">1</font>
Give plane ID: <font color="red">G-OWAC</font>
Give plane capacity: <font color="red">101</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
> <font color="red">2</font>
Give plane ID: <font color="red">HA-LOL</font>
Give departure airport code: <font color="red">HEL</font>
Give destination airport code: <font color="red">BAL</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
> <font color="red">2</font>
Give plane ID: <font color="red">G-OWAC</font>
Give departure airport code: <font color="red">JFK</font>
Give destination airport code: <font color="red">BAL</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
> <font color="red">2</font>
Give plane ID: <font color="red">HA-LOL</font>
Give departure airport code: <font color="red">BAL</font>
Give destination airport code: <font color="red">HEL</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
> <font color="red">x</font>

Flight service
------------

Choose operation:
[1] Print planes
[2] Print flights
[3] Print plane info
[x] Quit
> <font color="red">1</font>
G-OWAC (101 ppl)
HA-LOL (42 ppl)
Choose action:
[1] Print planes
[2] Print flights
[3] Print plane info
[x] Quit
> <font color="red">2</font>
HA-LOL (42 ppl) (HEL-BAL)
HA-LOL (42 ppl) (BAL-HEL)
G-OWAC (101 ppl) (JFK-BAL)

Choose operation:
[1] Print planes
[2] Print flights
[3] Print plane info
[x] Quit
> <font color="red">3</font>
Give plane ID: <font color="red">G-OWAC</font>
G-OWAC (101 ppl)

Choose operation:
[1] Print planes
[2] Print flights
[3] Print plane info
[x] Quit
> <font color="red">x</font>
                </pre>

                <p><strong>Attention:</strong> for the tests, it is essential that the <em>user interface</em> works <b>exactly</b> as displayed above. In fact, it is a good idea to copy-paste the menus printed by the above program into your code <em>exactly</em>. The tests do not require that your program should be prepared to deal with invalid inputs. This exercise is worth three single excercise points.</p>

                <p><em><strong>The program must start by executing the main method in the exercise layout.</strong></em></p>

                <p><b>Still another remark:</b> in order to make your tests work, your program has to create only one Scanner object. Also, avoid using static variables: the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</p>
              </div>
            </div>
          </div>
          The material continues here: <a href="http://mooc.cs.helsinki.fi/programming-part2/material/week-8">Week 2</a>
        </section>


        <!-- added not-released to the classname for those weeks not yet released -->
        <section class="viikkoraja" id="2" >
          <div class="viikkoraja">Week2</div>
          <div class="viikkoraja-mooc" id="Week 8" deadline="unlocks when 85% of week 7 done " data-first-chapter-index="38" data-first-exercise-index="116" data-first-week-index="8"  data-first-chapter-index-mooc="39" data-first-exercise-index-mooc="116" data-first-week-index-mooc="8" tekija="Arto Vihavainen, Matti Luukkainen">


            <h2 id="object">Object</h2>

            <p>In our course, we have been using frequently the method <code>public String toString()</code> when we wanted to print an object in the shape of a string. Calling the method without setting it up properly does usually cause an error. We can have a look at the class <code>Book</code>, which does not contain the method <code>public String toString()</code> yet, and see what happens when the program uses the method <code>System.out.println()</code> and tries to print an object of <code>Book</code> class.</p>

            <pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }
}
            </pre>

            <pre class="sh_java">
Book objectBook = new Book("Object book", 2000);
System.out.println(objectBook);
            </pre>

            <p>if we take an object of <code>Book</code> class and use it as the parameter of the method <code>System.out.println()</code>, our program does not print an error message. Our program does not crash, and instead of reading an error message, we notice an interesting print output. The print output contains the name of the class, <code>Book</code>, plus an indefinite String which follows a @ character. Notice that when we call <code>System.out.println(objectBook)</code> Java calls <code>System.out.println(objectBook.toString())</code>, in fact, but this does not cause an error.</p>

            <p>The explanation is related to the way Java classes are built. Each Java class automatically <em>inherits</em> the <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">Object</a></code> class, which contains a set of methods that are useful to each Java class. Heritage means that our class has access to the features and functions defined in the inherited class. Among the others, the class <code>Object</code> contains the method <code>toString</code>, which is inherited by the classes we create.</p>

            <p>The <code>toString</code> method inherited from the object class is not usually the one we'd want. That's why we will want to <em>replace</em> it with one we make personally. Let us add the method <code>public String toString()</code> to our <code>Book</code> class. This method will replace the <code>toString</code> method inherited from the <code>Object</code> class.</p>

            <pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }
}
            </pre>

            <p>If now we create an object instance, and we set it into the print method, we notice that the <code>toString</code> method of the <code>Book</code> class produces a string.</p>

            <pre class="sh_java">
Book objectBook = new Book("Object book", 2000);
System.out.println(objectBook);
            </pre>

            <pre>
Object book (2000)
            </pre>

            <p>Above the <code>toString</code> method of class <code>Book</code> we see the <code>@Override</code> <em>annotation</em>. We use annotations to give guidelines to both the translator and the reader about how to relate to the methods. The <code>@Override</code> annotation tells that the following method replaces the one defined inside the inherited class. If we don't add an annotation to the method we replace, the translator gives us a <em>warning</em>, however avoiding writing annotations is not a mistake.</p>

            <p>There are also other useful methods we inherit from the <code>Object</code> class. Let us now get acquainted with the methods <code>equals</code> and <code>hashCode</code>.</p>

            <h3>Equals Method</h3>

            <p>The <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)" target="_blank">equals</a></code> method is used to compare two objects. The method is particularly used when we compare two <code>String</code> objects.</p>

            <pre class="sh_java">
Scanner reader = new Scanner(System.in);

System.out.print("Write password: ");
String password = reader.nextLine();

if (password.equals("password")) {
    System.out.println("Right!");
} else {
    System.out.println("Wrong!");
}
            </pre>

            <pre>
Write password: <font color="red">mightycarrot</font>
Wrong!
            </pre>

            <p>The <code>equals</code> method is defined in the <code>Object</code> class, and it makes sure that both the parameter object and the compared object have the same reference. In other words, by default the method makes sure that we are dealing with <em>one</em> unique object. If the reference is the same, the method returns <code>true</code>, otherwise <code>false</code>. The following example should clarify the concept. The class <code>Book</code> doesn't implement its own <code>equals</code> method, and therefore it uses the one created by the <code>Object</code> class.</p>

            <pre class="sh_java">
Book objectBook = new Book("Objectbook", 2000);
Book anotherObjectBook = objectBook;

if (objectBook.equals(objectBook)) {
    System.out.println("The books were the same");
} else {
    System.out.println("The books were not the same");
}

// Now we create an object with the same contents, which is however a different, independent object
anotherObjectBook = new Book("Objectbook", 2000);

if (objectBook.equals(anotherObjectBook)) {
    System.out.println("The books were the same");
} else {
    System.out.println("The books were not the same");
}
            </pre>

            <p>Print output:</p>

            <pre>
The books were the same
The books were not the same
            </pre>

            <p>Even if the internal structure of both <code>Book</code> objects (i.e. the object variable values) is exactly the same, only the first comparison prints "<code>The books were the same</code>". This depends on the fact that only in the first case also the references were the same, i.e. we were comparing an object with itself. In the second example, we had two different objects even though they both had the same values.</p>

            <p>When we use the <code>equals</code> method to compare strings, it works as we want it to: it identifies two strings as equal if the have the same <em>contents</em> even though they are two different objects. In fact, the default <code>equals</code> method is replaced with a new implementation in the String class.</p>

            <p>We want that book comparison happened against name and year. We replace the <code>equals</code> method in the <code>Object</code> class with an implementation in the <code>Book</code> class. The <code>equals</code> method has to make sure whether the object is the same as the one received as parameter. First, we define a method according to which all the objects are the same.</p>

            <pre class="sh_java">
    public boolean equals(Object object) {
        return true;
    }
            </pre>

            <p>Our method is a little too optimistic, so let us change its functionality slightly. Let us define that the objects are not the same if the parameter object is <em>null</em> or if the the two object types are different. We can find out the type of an object with the method <code>getClass()</code> (which is denifed in the <code>oject</code> class). Otherwise, we expect that the objects are the same.</p>

            <pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (this.getClass() != object.getClass()) {
            return false;
        }

        return true;
    }
            </pre>

            <p>The <code>equals</code>method finds out the class difference of two objects, but it is not able to distinguish two similar objects from each other. In order to compare our object with the object we received as parameter, and whose reference is <code>Object</code> type, we have to change the type of the Object reference. The reference type can be changed if and only if the object type is really such as we are converting it into. Type casting happens by specifying the desired class within brackets on the right side of the assignment sentence:</p>

            <pre class="sh_java">
    WantedType variable = (WantedType) oldVariable;
            </pre>

            <p>Type casting is possible because we know two objects are the same type. If they are different type, the above <code>getClass</code> method returns false. Let us change the <code>Object</code> parameter received with the <code>equals</code> method into <code>Book</code> type, and let us identify two different books against their publishing year. The books are otherwise the same.</p>

            <pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if(this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        return true;
    }
            </pre>

            <p>Now, our comparison method is able to distinguish books against their publishing year. Wa want to check still that our book names are the same, and our own book name is not <em>null</em>.</p>

            <pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }
            </pre>

            <p>Excellent, we have got a method for comparison which works, finally! Below is our <code>Book</code> class as it looks like at the moment.</p>

            <pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }
}
            </pre>

            <p>Now, our book comparison returns <code>true</code>, if the book contents are the same.</p>

            <pre class="sh_java">
Book objectBook = new Book("Objectbook", 2000);
Book anotherObjectBook = new Book("Objectbook", 2000);

if (objectBook.equals(anotherObjectBook)) {
    System.out.println("The books are the same");
} else {
    System.out.println("The books are not the same");
}
            </pre>

            <pre>
The books are the same
            </pre>

            <h4>Equals and ArrayList</h4>

            <p>Various different Java made-up methods make use of the <code>equals</code> method to implement their search functionality. For instance, the <code>contains</code> mehod of class <code>ArrayList</code> compares objects through the <code>equals</code> method. Let us continue to use the <code>Book</code> class we defied for our examples. If our objects do not implement the <code>equals</code> method, we can't use the <code>contains</code> method, for instance. Try out the code below in two different <code>book</code> classes. The first class implements the <code>equals</code> method, the other does not.</p>

            <pre class="sh_java">
ArrayList&lt;Book&gt; books = new ArrayList&lt;Book&gt;();
Book objectBook = new Book("Objectbook", 2000);
books.add(objectBook);

if (books.contains(objectBook)) {
    System.out.println("The object book was found.");
}

objectBook = new Book("Objectbook", 2000);

if (!books.contains(objectBook)) {
    System.out.println("The object book was not found.");
}
            </pre>

            <h3>HashCode Method</h3>

            <p>The <code>hashCode</code> method takes an object and returns a numeric value, i.e. a hash value. We need numeric values for instance when we use and object as HashMap keys. So far, we have been using only String and Integer objects as HashMap keys, and their <code>hashCode</code> method is implemented by default. Let us make an example where it is not so: let us continue with our book examples and let us start to take note of our books on loan. We want to implement our bookkeeping through Hashmap. The key is the book, and the book's value is a string, which tells the loaner's name:</p>

            <pre class="sh_java">
        HashMap&lt;Book, String&gt; loaners = new HashMap&lt;Book, String&gt;();

        Book objectbook = new Book("Objectbook", 2000);
        loaners.put( objectbook, "Pekka" );
        loaners.put( new Book("Test Driven Development",1999), "Arto" );

        System.out.println( loaners.get( objectbook ) );
        System.out.println( loaners.get( new Book("Objectbook", 2000) );
        System.out.println( loaners.get( new Book("Test Driven Development", 1999) );
            </pre>

            <p>Print output:</p>

            <pre>
Pekka
null
null
            </pre>

            <p>We can find the loaner by searching against the same object which was given as HashMap key with the <code>put</code> method. However, if our search item is the same book but a different object, we are not able to find its loaner and we are retured with a <em>null</em> reference. This is again due to the default implementation of the <code>hashCode</code> method of <code>Object</code> class. The default implementation creates an index based on the reference; this means that different objects with the same content receive different hashCode method outputs, and therefore it is not possible to find the right place of the object in the HashMap.</p>

            <p>To be sure the HashMap worked in the way we want - i.e. it returned the loaner when the key is an object with the right <em>content</em> (not necessarily the same object as the original value) - the class which works as key must overwrite both the <code>equals</code> method and the <code>hashCode</code> method. The method must be overwritten in such a way, so that it would assign the same numeric value to all objects which have the same content. Some objects with different content may eventually be assigned the same hashCode; however, different content objects should be assigned the same hashCode as rarely as possible, if we want our HashMap to be efficient.</p>

            <p>Previously, we have successfully used <code>String</code> objects as HashMap keys, and we can therefore say that the <code>String</code> class has a <code>hashCode</code> implementation which works as expected. Let us <em>delegate</em> the calculation to the <code>String</code> object.</p>

            <pre class="sh_java">
    public int hashCode() {
        return this.name.hashCode();
    }
            </pre>

            <p>The solution above is quite good; but if <code>name</code> is <em>null</em>, we are thrown a <code>NullPointerException</code>. We can fix this by setting the condition: if the value of the <code>name</code> variable is is <em>null</em>, return value 7. Seven is a value chosen casually, thirteen could have done as well.</p>

            <pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.name.hashCode();
    }
            </pre>

            <p>We can still improve the <code>hashCode</code> method by taking into consideration the book publishing year, in our calculations:</p>

            <pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
            </pre>


            <p>An additional remark: the output of the hashCode method of HashMap key objects tells us their value slot in the hash construction, i.e. their index in the HashMap. You may now be wondering: "doesn't this lead to a situation where more than one object ends up with the same index in the HashMap?". The answer is yes and no. Even if the <code>hashCode</code> method gave the same value to two different objects, HashMaps are built in such way that various different obejcts may have the same index. In order to distinguish objects with the same index, the key objects of the HashMap must have implemented the <code>equals</code> method. You will find more information about Hashmap implementation in the course <em>Data Structures and Algorithms</em>.</p>

            <p>The final <code>Book</code> class now.</p>

            <pre class="sh_java">
public class Book {

    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }

    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
}
            </pre>

            <p><b>Let us sum up everything again:</b> in order to use a class as HashMap key, we have to define</p>
            <ul>
              <li>The <code>equals</code> method in a way that objects with the same content will return true when compared, whereas different-content objects shall return false</li>
              <li>The <code>hashCode</code> method in a way that it assigns the same value to all the objects whose content is regarded as similar</li>
            </ul>

            <p>The equals and hashCode methods of our Book class fulfill these two conditions. Now, the problem we faced before is solved, and we can find out the book loaners:</p>

            <pre class="sh_java">
        HashMap&lt;Book, String&gt; loaners = new HashMap&lt;Book, String&gt;();

        Book objectbook = new Book("Objectbook", 2000);
        loaners.put( objectbook, "Pekka" );
        loaners.put( new Book("Test Driven Development",1999), "Arto" );

        System.out.println( loaners.get( objectbook ) );
        System.out.println( loaners.get( new Book("Objectbook", 2000) );
        System.out.println( loaners.get( new Book("Test Driven Development", 1999) );
            </pre>

            <p>Print output:</p>

            <pre>
Pekka
Pekka
Arto
            </pre>

            <p><em>NetBeans allows for the automatic creation of the <code>equals</code> and <code>hashCode</code> methods. From the menu Source -> Insert Code, you can choose <em>equals() and hashCode()</em>. After this, NetBeans asks which object variables the methods shall use.</em></p>

            <NEXTWEEK></NEXTWEEK>
            <div class="tehtavat" id="viikko8">
              <div class="tehtava">



                <h3>Car Registration Centre</h3>

                <h4>Registration Plate Equals and HashCode</h4>

                <p>European registration plates are composed of two parts: the country ID -- one or two letters long -- and possibly a regitration code specific for the country, which in turn is composed of numbers and letters. Registaration plates are defined using the following class:</p>

                <pre class="sh_java">
public class RegistrationPlate {
    // ATTENTION: the object variable types are final, meaning that their value cannot be changed!
    private final String regCode;
    private final String country;

    public RegistrationPlate(String regCode, String country) {
       this.regCode = regCode;
       this.country = country;
    }

    public String toString(){
        return country+ " "+regCode;
    }
}
                </pre>

                <p>We want to store the registration plates into say ArrayLists, using a HashMap as key. As mentioned before, it means we have to implement the methods <code>equals</code> and <code>hashCode</code> in their class, otherwise they can't work as we want. </p>

                <p><strong>Suggestion:</strong> take the equals and hashCode models from the Book example above. The registration plate hashCode can be created say combining the hashCodes of the country ID and of the registration code.</p>

                <p>Example program:</p>

                <pre class="sh_java">
    public static void main(String[] args) {
        RegistrationPlate reg1 = new RegistrationPlate("FI", "ABC-123");
        RegistrationPlate reg2 = new RegistrationPlate("FI", "UXE-465");
        RegistrationPlate reg3 = new RegistrationPlate("D", "B WQ-431");

        ArrayList&lt;RegistrationPlate&gt; finnish = new ArrayList&lt;RegistrationPlate&gt;();
        finnish.add(reg1);
        finnish.add(reg2);

        RegistrationPlate new = new RegistrationPlate("FI", "ABC-123");
        if (!finnish.contains(new)) {
            finnish.add(new);
        }
        System.out.println("Finnish: " + finnish);
        // if the equals method hasn't been overwritten, the same registration plate is repeated in the list

        HashMap&lt;RegistrationPlate, String&gt; owners = new HashMap&lt;RegistrationPlate, String&gt;();
        owners.put(reg1, "Arto");
        owners.put(reg3, "JÃ¼rgen");

        System.out.println("owners:");
        System.out.println(owners.get(new RegistrationPlate("FI", "ABC-123")));
        System.out.println(owners.get(new RegistrationPlate("D", "B WQ-431")));
        // if the hashCode hasn't been overwritten, the owners are not found
    }
                </pre>

                <p>If equals hashCode have been implemented well, the output should look like this:</p>

                <pre>
Finnish: [FI ABC-123, FI UXE-465]
owners:
Arto
JÃ¼rgen

                </pre>

                <h4>The Owner, Based of the Registration Plate</h4>

                <p>Implement the class <code>VehicleRegister</code> which has the following methods:</p>

                <ul>
                  <li><code>public boolean add(RegistrationPlate plate, String owner)</code>, which adds the parameter owner of the car which corresponds to the parameter registration plate. The method returns true if the car had no owner; if the car had an owner already, the method returns false and it doesn't do anything</li>
                  <li><code>public String get(RegistrationPlate plate)</code>, which returns the car owner which corresponds to the parameter register number. If the car was not registered, it returns <code>null</code></li>
                  <li><code>public boolean delete(RegistrationPlate plate)</code>, which delete the information connected to the parameter registration plate. The method returns true if the information was deleted, and false if there was no information connetted to the parameter in the register.</li>
                </ul>

                <p><strong>Attention:</strong> the vehicle register has to store the owner information into a <code>HashMap&lt;RegistrationPlate, String&gt; owners</code> object variable!</p>

                <h4>More for the Vehicle Register</h4>

                <p>Add still the following methods to your VehicleRegister:</p>

                <ul>
                  <li><code>public void printRegistrationPlates()</code>, which prints out all the registration plates stored</li>
                  <li><code>public void printOwners()</code>, which prints all the car owners stored. Each owner's name has to be printed only once, even though they had more than one car</li>
                </ul>

              </div>
            </div>
            <h2 id="rajapinta">Interface</h2>

            <p><em>Interface</em> is an instrument we have to define the functionality our classes should have. Interfaces are defined as normal Java classes, but instead of the definition "<code>public class ...</code>", we write "<code>public interface ...</code>". The interfaces influence class behaviour by defining the method names and return values, but they <em>do not contain method implementation</em>. The access modifier is not specified, because it is always <code>public</code>. Let us have a look at the interface <em>Readable</em>, which defines whether an object can be read.</p>

            <pre class="sh_java">
public interface Readable {
    String read();
}
            </pre>

            <p>The interface <code>Readable</code> defines the method <code>read()</code>, which returns a string object. The classes which implement an interface decide <em>in which way</em> the methods defined in the interface have to be implemented, in the end. A class implements an interface by adding the keyword <em>implements</em> between the class and the interface name. Below, we create the class <code>SMS</code> which implements <code>Readable</code> interface.</p>

            <pre class="sh_java">
public class SMS implements Readable {
    private String sender;
    private String content;

    public SMS(String sender, String content) {
        this.sender = sender;
        this.content = content;
    }

    public String getSender() {
        return this.sender;
    }

    public String read() {
        return this.content;
    }
}
            </pre>

            <p>Because the class <code>SMS</code> implements the interface <code>Readable</code> (<code>public class SMS implements Readable</code>), the class <code>SMS</code> <em>must</em> implement the method <code>public String read()</code>. The implementations of methods defined in the interface must always have public access.</p>

            <p><em>An interface is a behavioural agreement. In order to implement the behaviour, the class must implement the methods defined by the interface. The programmer of a class which implements an interface has to define what the behaviour will be like. Implementing an interface means to agree that the class will offer all the actions defined by the interface, i.e. the behaviour defined by the interface. A class which implements an interface but does not implement some of the interface methods can not exist.</em></p>

            <p>Let us implement another class which implements the <code>Readable</code> interface, in addition to our <code>SMS</code> class. The class <code>EBook</code> is the electronic implementation of a book, and it contains the book name and page number. The EBook reads one page at time, and the <code>public String read()</code> method always returns the string of the following page.</p>

            <pre class="sh_java">
public class EBook implements Readable {
    private String name;
    private ArrayList&lt;String&gt; pages;
    private int pageNumber;

    public EBook(String name, ArrayList&lt;String&gt; pages) {
        this.name = name;
        this.pages = pages;
        this.pageNumber = 0;
    }

    public String getName() {
        return this.name;
    }

    public int howManyPages() {
        return this.pages.size();
    }

    public String read() {
        String page = this.pages.get(this.pageNumber);
        nextPage();
        return page;
    }

    private void nextPage() {
        this.pageNumber = this.pageNumber + 1;
        if(this.pageNumber % this.pages.size() == 0) {
            this.pageNumber = 0;
        }
    }
}
            </pre>

            <p>Classes which implement interfaces generate objects as well as normal classes, and they can be used as ArrayList types too.</p>

            <pre class="sh_java">
    SMS message = new SMS("ope", "Awesome stuff!");
    System.out.println(message.read());

    ArrayList&lt;SMS&gt; messages = new ArrayList&lt;SMS&gt;();
    messages.add(new SMS("unknown number", "I hid the body.");
            </pre>

            <pre>Awesome stuff!</pre>

            <pre class="sh_java">
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("Split your method into short clear chunks.");
    pages.add("Devide the user interface logic from the application logic.");
    pages.add("At first, always code only a small program which solves only a part of the problem.");
    pages.add("Practice makes perfect. Make up your own fun project.");

    EBook book = new EBook("Programming Hints.", pages);
    for(int page = 0; page &lt; book.howManyPages(); page++) {
        System.out.println(book.read());
    }
            </pre>

            <pre>

Split your method into short clear chunks.
Divide the user interface logic from the application logic.
At first, always code only a small program which solves only a part of the problem.
Practice makes perfect. Make up your own fun project.
            </pre>

            <div class="tehtavat">
              <div class="tehtava">

                <h3>NationalService</h3>

                <p>In the exercise layout, you find the premade interface <code>NationalService</code>, which contains the following operations:</p>

                <ul>
                  <li> the method <code>int getDaysLeft()</code> which returns the number of days left on service</li>
                  <li> the method <code>void work()</code>, which reduces the working days by one. The working days number can not become negative.</li>
                </ul>

                <pre class="sh_java">
public interface NationalService {
    int getDaysLeft();
    void work();
}
                </pre>

                <h4>CivilService</h4>

                <p>Create the class <code>CivilService</code> which implements your <code>NationalService</code> interface. The class constructor is without parameter. The class has the object variable daysLeft which is initialised in the constructor receiving the value 362.</p>

                <h4>MilitaryService</h4>

                <p>Create the class <code>MilitaryService</code> which implements your <code>NationalService</code> interface. The class constructor has one parameter, defining the days of service (<code>int daysLeft</code>).</p>
              </div>
            </div>

            <h3>An Interface as Variable Type</h3>

            <p>When we create a new variable we always specify its type. There are two types of variable types: primitive-type variables (int, double, ...) and reference-type (all objects). As far as reference-type variables are concerned, their class has also been their type, so far.</p>

            <pre class="sh_java">
    String string = "string-object";
    SMS message = new SMS("teacher", "Something crazy is going to happen");
            </pre>

            <p>The type of an object can be different from its class. For instance, if a class implements the interface <code>Readable</code>, its type is <code>Readable</code>, too. For instance, since the class <code>SMS</code> implements the interface <code>Readable</code>, it has two types: <code>SMS</code> and <code>Readable</code>.</p>

            <pre class="sh_java">
    SMS message = new SMS("teacher", "Awesome stuff!");
    Readable readable = new SMS("teacher", "The SMS is Readable!");
            </pre>

            <pre class="sh_java">
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("A method can call itself.");

    Readable book = new EBook("Recursion Principles", pages);
    for(int page = 0; page &lt; ((EBook)book).howManyPages(); page++) {
        System.out.println(book.read());
    }
            </pre>

            <p>Because an interface can be used as type, it is possible to create a list containing interface-type objects.</p>

            <pre class="sh_java">
    ArrayList&lt;Readable&gt; numberList = new ArrayList&lt;Readable&gt;();

    numberList.add(new SMS("teacher", "never been programming before..."));
    numberList.add(new SMS("teacher", "gonna love it i think!"));
    numberList.add(new SMS("teacher", "give me something more challenging! :)"));
    numberList.add(new SMS("teacher", "you think i can do it?"));
    numberList.add(new SMS("teacher", "up here we send several messages each day"));

    for (Readable readable: numberList) {
        System.out.println(readable.read());
    }
            </pre>

            <p>The <code>EBook</code> class implements the interface <code>Readable</code>. However, notice that even though the type of the class <code>EBook</code> is an interface, <code>EBook</code> is not the type of all the classes which implement the <code>Readable</code> interface. It is possible to assign an <code>EBook</code> object to a <code>Readable</code> variable, but the assignment does not work in the opposite way without a particular type change.</p>

            <pre class="sh_java">
    Readable readable = new Readable("teacher", "The SMS is Readable!"); // works
    SMS message = readable; // not possible

    SMS transformedMessage = (Message) Readable; // works
            </pre>

            <p>Type casting works if and only if the variable's type is really what we try to change it into. Type casting is not usually a best practice; one of the only cases where that is legitimate is in connection with the <code>equals</code> method.</p>

            <h3>An Interface as Method Parameter</h3>

            <p>The real use of interfaces becomes clear when we use them for the type of a method parameter. Because interfaces can be used as variable type, they can be used in method calls as parameter type. For instance, the below method <code>print</code> of class <ode>Printer</code> receives a <code>Readable</code> variable.</p>

          <pre class="sh_java">
public class Printer {
    public void print(Readable readable) {
        System.out.println(readable.read());
    }
}
          </pre>

          <p>The real value of the <code>print</code> method of class <code>Printer</code> is that its parameter can be <em>whatever</em> class instance which implements our <code>Readable</code> interface. When we call the method of an object, the method will work regardless of the class of this object, as long as the object implements Readable.</p>

          <pre class="sh_java">
    SMS message = new SMS("teacher", "Huhhuh, this printer is able to print them, actually!");
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("{3, 5} are the numbers in common between {1, 3, 5} and {2, 3, 4, 5}.");

    EBook book = new EBook("Introduction to University Mathematics.", pages);

    Printer printer = new Printer();
    printer.print(SMS);
    printer.print(book);
          </pre>

          <pre>
Wow, this printer is able to print them, actually!
{3, 5} are the numbers in common between {1, 3, 5} and {2, 3, 4, 5}.
          </pre>

          <p>Let us implement another <code>numberList</code> class, where we can add interesting readable stuff. The class has an <code>ArrayList</code> instance as object variable where we save things to read. We add items to our number list through the <code>add</code> method which receives a <code>Readable</code> variable as parameter.</p>

          <pre class="sh_java">
public class NumberList {
    private ArrayList&lt;Readable&gt; readables;

    public NumberList() {
        this.readables = new ArrayList&lt;Readable&gt;();
    }

    public void add(Readable readable) {
        this.readables.add(readable);
    }

    public int howManyReadables() {
        return this.readables.size();
    }
}
          </pre>

          <p>Number lists are usually readable, so we can implement the <code>Readable</code> interface to the <code>NumberList</code> class. The number list <code>read</code> method reads all the objects of the <code>readables</code> list, and it adds them one by one to a string which is returned by the <code>read()</code> method.</p>

          <pre class="sh_java">
public class NumberList implements Readable {
    private ArrayList&lt;Readable&gt; readables;

    public NumberList() {
        this.readables = new ArrayList&lt;Readable&gt;();
    }

    public void add(Readable readable) {
        this.readables.add(readable);
    }

    public int howManyReadables() {
        return this.readables.size();
    }

    public String read() {
        String read = "";
        for(Readable readable: this.readables) {
            read += readable.read() + "\n";
        }

        this.readables.clear();
        return read;
    }
}
          </pre>

          <pre class="sh_java">
    NumberList myList = new NumberList();
    joelList.add(new SMS("matti", "have you already written the tests?"));
    joelList.add(new SMS("matti", "did you have a look at the submissions?"));

    System.out.println("Joel has " + joelList.howManyReadables() + " messages to read");
          </pre>

          <pre>
Joel has got 2 messages to read
          </pre>

          <p>Because the type of <code>NumerList</code> is <code>Readable</code>, we can add <code>NumerList</code> objects to our number list, too. In the example below, Joel has a lot of messages to read, luckily Mikael deals with it and reads the messages on behalf of Joel.</p>

          <pre class="sh_java">
    NumberList joelList = new NumberList();
    for (int i = 0; i &lt; 1000; i++) {
        joelList.add(new SMS("matti", "have you already written the tests?"));
    }

    System.out.println("Joel has " + joelList.howManyReadables() + " messages to read");
    System.out.println("Let's delegate some reading to Mikael");

    NumberList mikaelList = new NumberList();
    mikaelList.add(joelList);
    mikaelList.read();

    System.out.println();
    System.out.println("Joel has " + joelList.howManyReadables() + " messages to read");
          </pre>

          <pre>
Joel has 1000 messages to read
Let's delegate some reading to Mikael

Joel has 0 messages to read
          </pre>

          <p>The <cide>read</code> method which is called in connection to Mikael's list parses all the <code>Readable</code> objects contained in the list, and calls their <code>read</code> method. At the end of each <code>read</code> method call the list is cleared. In other words, Joel's number list is cleared as soon as Mikael reads it.</p>

        <p><em>At this point, there are a lot of references; it would be good to draw down the objects and try to grasp how the <code>read</code> method call connected to <code>mikaelList</code> works!</em></p>

        <div class="tehtavat">
          <div class="tehtava">

            <h3>Boxes and Things</h3>

            <h4 class="req">ToBeStored</h4>

            <p>We need storage boxes when we move to a new apartment. The boxes are used to store different things. All the things which are stored in the boxes have to implement the following interface:</p>

            <pre class="sh_java">
public interface ToBeStored {
    double weight();
}
            </pre>

            <p>Add the interface to your program. New interfaces are added almost in the same way as classes: you choose <i>new Java interface</i> instead of <i>new Java class</i>.</p>

            <p>Create two classes which implement the interface <code>Book</code> and <code>CD</code>. Book receives its writer (String), name (String), and weight (double), all as parameter. CD's parameter contains its artist (String), title (String), and publishing year (int). All CDs weigh 0.1 kg.</p>

            <p>Remember that the classes also have to implement the interface <code>ToBeStored</code>. The classes have to work in the following way:</p>

            <pre class="sh_java">
    public static void main(String[] args) {
        Book book1 = new Book("Fedor Dostojevski", "Crime and Punishment", 2);
        Book book2 = new Book("Robert Martin", "Clean Code", 1);
        Book book3 = new Book("Kent Beck", "Test Driven Development", 0.5);

        CD cd1 = new CD("Pink Floyd", "Dark Side of the Moon", 1973);
        CD cd2 = new CD("Wigwam", "Nuclear Nightclub", 1975);
        CD cd3 = new CD("Rendezvous Park", "Closer to Being Here", 2012);

        System.out.println(book1);
        System.out.println(book2);
        System.out.println(book3);
        System.out.println(cd1);
        System.out.println(cd2);
        System.out.println(cd3);
    }
            </pre>

            <p>Print output:</p>

            <pre>
Fedor Dostojevski: Crime and Punishment
Robert Martin: Clean Code
Kent Beck: Test Driven Development
Pink Floyd: Dark Side of the Moon (1973)
Wigwam: Nuclear Nightclub (1975)
Rendezvous Park: Closer to Being Here (2012)
            </pre>

            <p>Attention! The weight is not reported here.</p>

            <h4 class="req">Box</h4>

            <p>Create the class box, which has to store Things that implement the interface <code>ToBeStored</code>. The box receives as constructor the maximum weight, expressed in kilograms. The box can't be added more things than its maximum capacity allows for. The weight of the things contained in the box can never exceed the box maximum capacity.</p>

            <p>The following example clarifies the box use:</p>

            <pre class="sh_java">
    public static void main(String[] args) {
        Box box = new Box(10);

        box.add( new Book("Fedor Dostojevski", "Crime and Punishment", 2) ) ;
        box.add( new Book("Robert Martin", "Clean Code", 1) );
        box.add( new Book("Kent Beck", "Test Driven Development", 0.7) );

        box.add( new CD("Pink Floyd", "Dark Side of the Moon", 1973) );
        box.add( new CD("Wigwam", "Nuclear Nightclub", 1975) );
        box.add( new CD("Rendezvous Park", "Closer to Being Here", 2012) );

        System.out.println( box );
    }
            </pre>

            <p>Printing:</p>

            <pre>
Box: 6 things, total weight 4.0 kg
            </pre>

            <p>Note: because the weights are represented as double, the rounding can cause small mistakes. You don't need to care about it when you do the exercise.</p>

            <h4 class="req">Box weight</h4>

            <p>If you created the object variable <code>double weght</code> in your box which records the weight of your things, replace it now with a method which calculates the weight:</p>

            <pre class="sh_java">
public class Box {
    //...

    public double weight() {
        double weight = 0;
        // it calculates the total weight of the things which had been stored
        return weight;
    }
}
            </pre>

            <p>When you need the box weight -- if you have to add a new thing, for instance -- you can simply call the method which calculates it.</p>

            <p>In fact, the method could work well even though it retured the value of an object variable. However, we train a situation where you don't need to maintain the object variable explicitly, but you can calculate it when you need it. With the following exercise, the information stored in a box object variable would not necessarily work properly, however. Why?</p>

            <h4 class="req">Boxes are Stored too!</h4>

            <p>Implementing the interface <code>ToBeStored</code> requires that the class has the method <code>double weight()</code>. In fact, we just added this method to Box. Boxes can be stored!</p>

            <p>Boxes are objects where we can store object which implement the interface <code>ToBeStored</code>. Boxes also implement this interface. This means that <b>you can also put boxes inside your boxes!</b></p>

            <p>Try this out: create a couple of boxes in your program, put things into the boxes and put smaller boxes into the bigger ones. Try also what happens when you put a box into itself. Why does it happen?</p>
          </div>
        </div>

        <h3>An Interface as Method Return Value</h3>

        <p>As well as any other variable type, an interface can also be used as method return value. Below you find <code>Factory</code>, which can be used to produce different objects that implement the interface <code>Item</code>. In the beginning, Factory produces books and disks at random.</p>

        <pre class="sh_java">
   public class Factory {
      public Factory(){
          // Attention: it is not necessary to write an empty constructor if there are no other constructors in the class.
      // In such cases, Java creates a default constructor, i.e a constructor without parameter
      }

       public Item produceNew(){
           Random random = new Random();
           int num = random.nextInt(4);
           if ( num==0 ) {
               return new CD("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( num==1 ) {
               return new CD("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( num==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           }
       }
   }
        </pre>

        <p>It is possible to use our Factory without knowing precisely what kind of classes are present in it, as long as they all implement Item. Below you find the class <code>Packer</code> which can be used to get a boxful of items. The Packer knows the factory which produces its Items:</p>

        <pre class="sh_java">
   public class Packer {
       private Factory factory;

       public Packer(){
            factory = new Factory();
       }

       public Box giveABoxful() {
            Box box = new Box(100);

            for ( int i=0; i &lt; 10; i++ ) {
                Item newItem = factory.produceNew();
                box.add(newItem);
            }

            return box;
       }
   }
        </pre>

        <p>Because the packer doesn't know the classes which implement the Item interface, it is possble to add new classes which implement the interface without having to modify the packer. Below, we create a new class which implements our Item interface - <code>ChocolateBar</code>. Our Factory was modified to produce chocolate bars in addition to books and CDs. The class <code>Packer</code> works fine with the extended factory version, without having to change it.</p>

        <pre class="sh_java">
   public class ChocolateBar implements Item {
      // we don't need a constructor because Java is able to generate a default one!

      public double weight(){
         return 0.2;
      }
   }

   public class Factory {
      // we don't need a constructor because Java is able to generate a default one!

       public Item produceNew(){
           Random random = new Random();
           int num = random.nextInt(5);
           if ( num==0 ) {
               return new CD("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( num==1 ) {
               return new CD("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( num==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else if ( num==3 ) {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           } else {
               return new ChocolateBar();
           }
       }
   }
        </pre>


        <p><em>Using interfaces while programming permits us to reduce the number of dependences among our classes. In our example, Packer is not dependent on the classes which implement Item interface, it is only dependent on the interface itself. This allows us to add classes wihout having to change the class Packer, as long as they implement our interface. We can even add classes that implement the interface to the methods which make use of our packer without compromising the process. In fact, less dependences make it easy to extend a program.</em></p>


        <!--
<p>We can imlement now the classes <code>PieceOfNews</code> and <code>NewsService</code>; the first reports a singular piece of news, and the second produces the news to be read. The code which makes use of our news service does not have to know the actual news implementation, and that is not even sensible. The only essential thing is that the program is able to read the news. In fact, the news service can submit its news through the <code>Readable</code> interface.</p>

<pre class="sh_java">
public class PieceOfNews implements Readable {
    private String text;

    public PieceOfNews(String text) {
        this.text = text;
    }

    public String read() {
        return this.text;
    }
}
</pre>

<pre class="sh_java">
public class NewsService {

    public Luettava getLatestNews() {
        return new PieceOfNews("Latest Hot Topics!");
    }
}
</pre>

        <p>The news service always submits a <code>Readable</code> interface object. At this point, people often wonder a simple question: "<code>Why shouldn't we simply use the class PieceOfNews?</code>". The answer is quite long but hopefully it will clear the idea behind this.</p>

        <p>Let us think about a situation where we have a <code>Publisher</code> which publishes news. The publisher has to read the news from the NewsService regularly, and print out the messages (the Publisher could send the message to different media, but let's stick to a basic example). Let us suppose that NewsService returns PieceOfNews objects.</p>

<pre class="sh_java">
public class NewsService {

    public Luettava getLatestNews() {
        return new PieceOfNews("Latest Hot News!");
    }
}
</pre>

        <p>Publisher's essential functionality is a loop, which calls the method <code>getLatestNews</code> with regular intermissions.</p>

<pre class="sh_java">
public class Publisher {
    private NewsService newsService;

    public Publisher() {
        this.newsService = new NewsService();
    }

    public void start() {
        while (true) {
            PieceOfNews news = newsService.getLatestNews();
            System.out.println(news.read());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>So far, everything works well. We can now suppose our CEO notices that they need a new format for graphic news. Thus, we create a different class called <code>GraphicPieceOfNews</code>. GraphicPieceOfNews is readable so our NewsService programmer make it implement our Readable interface.</p>

<pre class="sh_java">
public class GraphicPieceOfNews implements Readable {
    private String imageAddress;
    private String text;

    public GraphicPieceOfNews(String text, String imageAddress) {
        this.text = text;
        this.imageAddress = imageAddress;
    }

    public String read() {
        return this.text + " (image address: " + this.imageAddress + ")";
    }
}
</pre>

        <p>Meanwhile, they also have to modify NewsService class, because it doesn't support the new news format: </p>

<pre class="sh_java">
public class NewsService {

    public GraphicPieceOfNews getLatestNews() {
        return new GraphicPieceOfNews("Latest Hot News!", "image address");
    }
}
</pre>

        <p>Now <em>we have to</em> modify our Publisher. In fact, it does not work any more because it returns an instance of the class <code>GraphicPieceOfNews</code>. How many classes we would have to modify if the news service used ten services, and what about one thousand? At this point <em>each</em> implementation which used our news service should change its own functionality.</p>

        <p>And what about if not all the pieces of news contained photos, and sometimes we wanted to return a <code>PieceOfNews</code> class instance? The method above, <code>getLatestNews</code>, may not be enough.</p>

        <p>Let's go back to our news format change, where the return type of the news service method <code>getLatestNews</code> is <code>Readable</code>.</p>


<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        return new PieceOfNews("The Latest Hot News!");
    }
}
</pre>

        <p>If the news service CEO wanted to get a new image format, we would not need to modify the <code>getLatestNews</code> method at all.</p>

<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        return new GraphicPieceOfNews("The Latest Hot News!", "Photo's address");
    }
}
</pre>

        <p>Not even the Publisher would need any modification.</p>

<pre class="sh_java">
public class Publisher {
    private NewsService newsService;

    public Publisher() {
        this.newsService = new NewsService();
    }

    public void start() {
        while (true) {
            Readable readable = newsService.GraphicPieceOfNews();
            System.out.println(readable.read());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>How many classes should we have modified if our news service offered ten services, and what about one thousand? Zero. And what about if our news service wanted to send sometimes normal news and sometimes graphic news? Easy! We only need to change our news service.</p>

<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        Random random = new Random();

        if(random.nextDouble() > 0.5) {
            return new PieceOfNews("The Latest Hot News!");
        }

        return new GraphicPieceOfNews("The Latest Hot News!", "photo's address");
    }
}
</pre>

    <p>Even in this case we don't need to change the implementations which make use of our NewsService.</p>


    <p><em>Coding to interface allows for reducing the dependences. If all the services which make use of our news service were coded to the interface Readable, they would not be dependent on any particular class which implements the Readable interface. In the wxamples above, the internal implementation of the news service can be modified so that the modifications would not affect the objects which make use of the news service, in any way.</em></p>
-->

        <!-- TODO: tarkista onko sama kuin "Valmiit rajapinnat"-->
        <h3>Made-Up Interfaces</h3>

        <p>Java API offers a sensible number of made-up interfaces. Below, we get to know some of Java's most used interfaces: <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html" target="_blank">List</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html" target="_blank">Map</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> and <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a></code>.</p>

        <h4>List</h4>

        <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List</a> interface defines lists basic functionality. Because the class ArrayList implements the <code>List</code> interface, it can also be initialized through the <code>List</code> interface.</p>

        <pre class="sh_java">
List&lt;String&gt; strings = new ArrayList&lt;String&gt;();
strings.add("A String object within an ArrayList object!");
        </pre>

        <p>As we notice from the <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List interface Java API</a>, there are a lot of classes which implement the interface <code>List</code>. A list construction which is familiar to hakers like us is the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html" target="_blank">linked list</a>. A linked list can be used through the List interface in the same way as the objects created from ArrayList.</p>

        <pre class="sh_java">
List&lt;String&gt; strings = new LinkedList&lt;String&gt;();
strings.add("A string object within a LinkedList object!");
        </pre>

        <p>Both implementations of the <code>List</code> interface work in the same way, in the user point of view. In fact, the interface <em>abstracts</em> their internal functionality. ArrayList and linkedList internal construction is evidently different, anyway. ArrayList saves the objects into a table, and the search is quick with a specific index. Differently, LinkedList builds up a list where each item has a reference to the following item. When we search for an item in a linked list, we have to go through all the list items till we reach the index.</p>

        <p>When it comes to bigger lists, we can point out more than evident performance differences. LinkedList's strength is that adding new items is always fast. Differently, behind ArrayList there is a table which grows as it fills up. Increasing the size of the table means creating a new one and copying there the information of the old. However, searching against an index is extremely fast with an ArrayList, whereas we have to go thourgh all the list elements one by one before reaching the one we want, with a LinkedList. More information about data structures such as ArrayList and LinkedList internal implementation comes with the course <em>Data structures and algorithms</em>.</p>

        <p>In our programming course you will rather want to choose ArrayList, in fact. Programming to interface is worth of it, anyway: implement your program so that you'll use data structures via interfaces.</p>

        <h4>Map</h4>

        <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html">Map</a> Interface defines HashMap basic fuctionality. Because HashMaps implement the <code>Map</code> interface, it is possible to initialize them trough the <code>Map</code> interface.</p>

        <pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "tsemppiÃ¤");
translations.put("hai", "kyllÃ¤");
        </pre>

        <p>You get HashMap keys thourgh the method <code>keySet</code>.</p>

        <pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

for(String key: translations.keySet()) {
    System.out.println(key + ": " + translations.get(key));
}
        </pre>

        <pre>
gambatte: good luck
hai: yes
        </pre>

        <p>The <code>keySet</code> method returns a set made of keys which implement <code>Set</code> interface. The set which implement the <code>Set</code> interface can be parsed with a for-each loop. HashMap values are retrieved through the <code>values</code> method, which returns a set of values which implement the <code>Collection</code> interface. We should now focus on Set and Collection interfaces.</p>

        <h4>Set</h4>

        <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a> interface defines the functionality of Java's sets. Java's sets always contain 0 or 1 element of a certain type. Among the others, <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code> is one of the classes which implement the Set interface. We can parse a key set through a for-each loop, in the following way</p>

        <pre class="sh_java">
Set&lt;String&gt; set = new HashSet&lt;String&gt;();
set.add("one");
set.add("one");
set.add("two");

for (String key: set) {
    System.out.println(key);
}
        </pre>

        <pre>
one
two
        </pre>

        <p>Notice that HashSet is not concerned on the order of its keys.</p>

        <h4>Collection</h4>

        <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a> interface defines the functionality of collections. Among the others, Java's lists and sets are collections -- that is, List and Set interfaces implement the Collection interface. Collection interface provides methods to check object existence (the <code>contains</code> method) and to check the collection size (<code>size</code> method). We can parse any class which implements the Collection interface with a <code>for-each</code> loop. </p>

        <p>We now create a HashMap and parse first its keys, and then its values.</p>

        <pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

Set&lt;String&gt; keys = translations.keySet();
Collection&lt;String&gt; keySet = keys;

System.out.println("Keys:");
for(String key: keySet) {
    System.out.println(key);
}

System.out.println();
System.out.println("Values:");
Collection&lt;String&gt; values = translations.values();
for(String value: values) {
    System.out.println(value);
}
        </pre>

        <pre>
Keys:
gambatte
hai

Values:
yes
good luck
        </pre>


        <p>The following example would have produced the same output, too.</p>

        <pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

System.out.println("Keys:");
for(String key: translations.keySet()) {
    System.out.println(key);
}

System.out.println();
System.out.println("Values:");
for(String value: translations.values()) {
    System.out.println(value);
}
        </pre>

        <p>In the following exercise we build an online shop, and we train to use classes through their interfaces.</p>

        <div class="tehtavat">
          <div class="tehtava">
            <h3>Online Shop</h3>

            <p>Next, we create some programming components which are useful to manage an online shop.</p>

            <h4>Storehouse</h4>

            <p>Create the class Storehouse with the following methods:</p>

            <ul>
              <li><code>public void addProduct(String product, int price, int stock)</code>, adding to the storehouse a product whose price and number of stocks are the parameter values</li>
              <li><code>public int price(String product)</code> returns the price of the parameter product; if the product is not available in the storehouse, the method returns -99</li>
            </ul>


            <p>Inside the storehouse, the prices (and soon also the stocks) of the products have to be stored into a <code>Map&lt;String, Integer&gt;</code> variable! The type of the object so created can be <code>HashMap</code>, but you should use the interface <code>Map</code> for the variable type (see 40.4.2)</p>

            <p>The next example clarifies storehouse use:</p>

            <pre class="sh_java">
        Storehouse store = new Storehouse();
        store.addProduct("milk", 3, 10);
        store.addProduct("coffee", 5, 7);

        System.out.println("prices:");
        System.out.println("milk:  " + store.price("milk"));
        System.out.println("coffee:  " + store.price("coffee"));
        System.out.println("sugar: " + store.price("sugar"));
            </pre>

            <p>Prints:</p>

            <pre>
prices:
milk:  3
coffee:  5
sugar: -99
            </pre>

            <h4>Product Stock</h4>

            <p>Store product stocks in a similar <code>Map&lt;String, Integer&gt;</code> variable as the one you used for their prices. Fill the Storehouse with the following methods:</p>

            <ul>
              <li><code>public int stock(String product)</code> returns the stock of the parameter product.</li>
              <li><code>public boolean take(String product)</code> decreases the stock of the parameter product by one, and it returns <em>true</em> if the object was available in the storehouse. If the product was not in the storehouse, the method returns <em>false</em>, the product stock cannot go below zero.</li>
            </ul>


            <p>An example of how to use the storehouse now:</p>

            <pre class="sh_java">
        Storehouse store = new Storehouse();
        store.addProduct("coffee", 5, 1);

        System.out.println("stocks:");
        System.out.println("coffee:  " + store.stock("coffee"));
        System.out.println("sugar: " + store.stock("sugar"));

        System.out.println("we take a coffee " + store.take("coffee"));
        System.out.println("we take a coffee " + store.take("coffee"));
        System.out.println("we take sugar " + store.take("sugar"));

        System.out.println("stocks:");
        System.out.println("coffee:  " + store.stock("coffee"));
        System.out.println("sugar: " + store.stock("sugar"));
            </pre>

            <p>Prints:</p>

            <pre>
stocks:
coffee:  1
sugar: 0
we take coffee true
we take coffee false
we take sugar false
stocks:
coffee:  0
sugar: 0
            </pre>

            <h4>Listing the Products</h4>

            <p>Let's add another method to our storehouse:</p>

            <ul>
              <li><code>public Set&lt;String&gt; products()</code> returns a name <em>set</em> of the products contained in the storehouse</li>
            </ul>

            <p>The method can be implemented easily. Using the Map's method <code>keySet</code>, you can get the storehouse products by asking for their prices or stocks.</p>

            <p>An example of how to use the storehose now:</p>

            <pre class="sh_java">
        Storehouse store = new Storehouse();
        store.addProduct("milk", 3, 10);
        store.addProduct("coffee", 5, 6);
        store.addProduct("buttermilk", 2, 20);
        store.addProduct("jogurt", 2, 20);

        System.out.println("products:");
        for (String product : store.products()) {
            System.out.println(product);
        }
            </pre>

            <p>Prints:</p>

            <pre>
products:
buttermilk
jogurt
coffee
milk
            </pre>

            <h4>Purchase</h4>

            <p>We add <em>purchases</em> to our shopping basket. With purchase we mean a specific number of a specific product. For instance, we can put into our shopping basket either a purchase corresponding to one bread, or a purchase corresponding to 24 coffees.</p>

            <p>Create the class <code>Purchase</code> with the following functionality:</p>

            <ul>
              <li>a constructor <code>public Purchase(String product, int amount, int unitPrice)</code>, which creates a purchase corresponding the parameter product. The product unit amount of purchase is clarified by the parameter <em>amount</em>, and the third parameter is the <em>unit price</em></li>
              <li><code>public int price()</code>, which returns the purchase price. This is obtained by raising the unit amount by the unit price</li>
              <li><code>public void increaseAmount()</code> increases by one the purchase unit amount</li>
              <li><code>public String toString()</code> returns the purchase in a string form like the following</li>
            </ul>

            <p>An example of how to use a purchase</p>

            <pre class="sh_java">
        Purchase purchase = new Purchase("milk", 4, 2);
        System.out.println( "the total price of a purchase containing four milks is " + purchase.price() );
        System.out.println( purchase );
        purchase.increaseAmount();
        System.out.println( purchase );
            </pre>

            <p>Prints:</p>

            <pre>
the total price of a purchase containing four milks is 8
milk: 4
milk: 5
            </pre>

            <p>Note: <em>toString</em> follows the pattern <em>product: amount</em>, but the price is not reported!</p>

            <h4>Shopping Basket</h4>

            <p>Finally, we can implement our shopping basket class!</p>

            <p>The shopping basket stores its products as <em>Purchase objects</em>. The shopping basket has to have an object variable whose type is either <code>Map&lt;String, Purchase&gt;</code> or <code>List&lt;Purchase&gt;</code>. Do not create any other object variable for your shopping basket in addition to the Map or List needed to store purchases.</p>

            <p>Attention: if you store a Purchase object in a Map helping variable, it will be useful to use the Map method values() in this and in the following exercise; with it, it's easy to go through all the stored Purchase objects.</p>

            <p>Let's create a constructor without parameter for our shopping basket, as well as the following methods:</p>

            <ul>
              <li><code>public void add(String product, int price)</code> adds a purchase to the shopping basket; the purchase is defined by the parameter product, and its price is the second parameter.</li>
              <li><code>public int price()</code> returns the shopping basket total price</li>
            </ul>

            <p>Example code of using basket</p>

            <pre class="sh_java">
        ShoppingBasket basket = new ShoppingBasket();
        basket.add("milk", 3);
        basket.add("buttermilk", 2);
        basket.add("cheese", 5);
        System.out.println("basket price: " + basket.price());
        basket.add("computer", 899);
        System.out.println("basket price: " + basket.price());
            </pre>

            <p>Prints:</p>

            <pre>
basket price: 10
basket price: 909
            </pre>

            <h4>Printing out the Shopping Basket</h4>

            <p>Let's create the method <code>public void print()</code> for our shopping basket. This prints out the <em>Purchase</em> objects which are contained by the basket. The printing order is not important. The output of the shopping basket in the previous example would be:</p>

            <pre>
butter: 1
cheese: 1
computer: 1
milk: 1
            </pre>

            <p>Note that the number stands for the unit amount of the products, not for their price!</p>

            <h4>Only One Purchase Object for One Product</h4>

            <p>Let's update our Shopping Basket; if the basket already contains the product which we add, we don't create a new Purchase object, but we update the Purchase object corresponding to the existing product by calling its method <em>increaseAmount()</em>.</p>

            <p>Example:</p>

            <pre class="sh_java">
        ShoppingBasket basket = new ShoppingBasket();
        basket.add("milk", 3);
        basket.print();
        System.out.println("basket price: " + basket.price() +"\n");

        basket.add("buttermilk", 2);
        basket.print();
        System.out.println("basket price: " + basket.price() +"\n");

        basket.add("milk", 3);
        basket.print();
        System.out.println("basket price: " + basket.price() +"\n");

        basket.add("milk", 3);
        basket.print();
        System.out.println("basket price: " + basket.price() +"\n");
            </pre>

            <p>Prints:</p>

            <pre>
milk: 1
basket price: 3

buttermilk: 1
milk: 1
basket price: 5

buttermilk: 1
milk: 2
basket price: 8

buttermilk: 1
milk: 3
basket price: 11
            </pre>

            <p>This means that first, we add milk and buttermilk, creating new Purchase objects for them. When we add more milk to the basket, we don't create a new purchase object for the milk, but we update the unit amount of the purchase object representing the milk we already have in the basket.</p>

            <h4>Shop</h4>

            <p>Now, all the parts of our online shop are ready. Our online shop has a storage house, which contains all products. We have got a shopping basket to manage all our customers. Whenever a customer chooses a purchase, we add it to the shopping basket if the product is available in our storage house. Meanwhile, the storage stocks are reduced by one.</p>

            <p>Below, you find a ready-made code body for your online shop. Create the class <code>Shop</code> to your project, and copy the code below into it.</p>

            <pre class="sh_java">
import java.util.Scanner;

public class Shop {

    private Storehouse store;
    private Scanner reader;

    public Shop(Storehouse store, Scanner reader) {
        this.store = store;
        this.reader = reader;
    }

    // the method to deal with a customer in the shop
    public void manage(String customer) {
        ShoppingBasket basket = new ShoppingBasket();
        System.out.println("Welcome to our shop " + customer);
        System.out.println("below is our sale offer:");

        for (String product : store.products()) {
            System.out.println( product );
        }

        while (true) {
            System.out.print("what do you want to buy (press enter to pay):");
            String product = reader.nextLine();
            if (product.isEmpty()) {
                break;
            }

            // here, you write the code to add a product to the shopping basket, if the storehouse is not empty
            // and decreases the storehouse stocks
            // do not touch the rest of the code!

        }

        System.out.println("your purchases are:");
        basket.print();
        System.out.println("basket price: " + basket.price());
    }
}
            </pre>

            <p>The following main program fills the shop storehouse and manages the customer Pekka:</p>

            <pre class="sh_java">
    Storehouse store = new Storehouse();
    store.addProduct("coffee", 5, 10);
    store.addProduct("milk", 3, 20);
    store.addProduct("milkbutter", 2, 55);
    store.addProduct("bread", 7, 8);

    Shop shop = new Shop(store, new Scanner(System.in));
    shop.manage("Pekka");
            </pre>

            <p>The shop is almost ready. There are comments in the method <code>public void manage(String customer)</code>, showing the part that you should implement. In that point, implement the code to check whether the object the customer wants is available in the storehouse. If so, reduce the storehouse stocks by one unit, and add the product to the shopping basket.</p>

            <p><em>Now you have done something! verkkokauppa.com!</em></p>
          </div>
        </div>

        <h2>Generics</h2>

        <p>We speak about <em>Generics</em> in connection to the way classes can conserve objects of genric type. Generics is based on the generic type parameter which is used when we define a class, and which helps us to define the types that have to be chosen when an <em>object is created</em>. A class generics can be defined by setting up the number of type parameters we want. This number is written after the class name and between the greater-than and less-than signs. We now implement our own generic class <code>Slot</code> which be assigned whatever object.</p>

        <pre class="sh_java">
public class Slot&lt;T&gt; {
    private T key;

    public void setValue(T key) {
        this.key = key;
    }

    public T getValue() {
        return key;
    }
}
        </pre>

        <p>The definition <code>public class Slot&lt;T&gt;</code> tells us that we have to give a type parameter to the constructor of the class <code>Slot</code>. After the constructor call the object variables have to be the same type as what established with the call. We now create a slot which memorizes strings.</p>

        <pre class="sh_java">
    Slot&lt;String&gt; string = new Slot&lt;String&gt;();
    string.setValue(":)");

    System.out.println(string.getValue());
        </pre>

        <pre>
:)
        </pre>

        <p>If we change the type parameter we can create different kinds of <code>Slot</code> ojects, whose purpose is to memorize objects. For instance, we can memorize an integer in the following way:</p>

        <pre class="sh_java">
    Slot&lt;Integer&gt; num = new Slot&lt;Integer&gt;();
    num.setValue(5);

    System.out.println(slot.getValue());
        </pre>


        <pre>
5
        </pre>

        <p>An important part of Java data structures are programmed to be generic. For instance, ArrayList receives one parameter, HashMap two.</p>

        <pre class="sh_java">
    List&lt;String&gt; string = new ArrayList&lt;String&gt;();
    Map&lt;String, String&gt; keyCouples = new HashMap&lt;String, String&gt;();
        </pre>

        <p>In the future, when you see the type <code>ArrayList&lt;String&gt;</code>, for instance, you know that its internal structure makes use of a generic type parameter.</p>

        <h3>The Interface which Makes Use of Generics: Comparable</h3>

        <p>In addition to normal interfaces, Java has interfaces which make use of generics. The internal value types of generic interfaces are defined in the same way as for generic classes. Let us have a look at Java made-up <code><a href="http://java.sun.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</a></code> interface. The <code>Comparable</code> interface defines the <code>compareTo</code> method, which returns the place of <code>this</code> object, in relation to the parameter object (a negative number, 0, or a positive number). If <code>this</code> object is placed before the parameter object in the comparison order, the method returns a negative value, whereas it returns a positive value if it is placed after the parameter object. If the objects are placed at the same place in the comparison order, the method returns 0. With comparison order we mean the object order of magnitude defined by the programmer, i.e. the object order, when they are sorted with the sort method.</p>

        <p>One of the advantages of the <code>Comparable</code> interface is that it allows us to sort a list of Comparable type keys by using the standard library method <code>Collections.sort</code>, for instance. <code>Collections.sort</code> uses the <code>compareTo</code> method of a key list to define in which order these keys should be. We call <em>Natural Ordering</em> this ordering technique which makes use of the <code>compareTo</code> method.

        <p>We create the class <code>ClubMember</code>, which depicts the young people and children who belong to the club. The members have to eat in order of height, so the club members will implement the interface <code>Comparable</code>. The interface <code>Comparable</code> also takes as type parameter the class which it is compared to. As type parameter, we use the <code>ClubMember</code> class.</p>

        <pre class="sh_java">
public class ClubMember implements Comparable&lt;ClubMember&gt; {
    private String name;
    private int height;

    public ClubMember(String name, int height) {
        this.name = name;
        this.height = height;
    }

    public String getName() {
        return this.name;
    }

    public int getHeigth() {
        return this.height;
    }

    @Override
    public String toString() {
        return this.getName() + " (" + this.getHeigth() + ")";
    }

    @Override
    public int compareTo(ClubMember clubMember) {
        if(this.heigth == clubMember.getHeight()) {
            return 0;
        } else if (this.height &gt; clubMember.getHeight()) {
            return 1;
        } else {
            return -1;
        }
    }
}
        </pre>

        <p>The interface requires the method <code>compareTo</code>, which returns an integer that tells us the comparison order. Our <code>compareTo()</code> method has to return a negative number if <code>this</code> object is smaller than its parameter object, or zero, if the two members are equally tall. Therefore, we can implement the above <code>compareTo</code> method, in the following way:</p>

        <pre class="sh_java">
    @Override
    public int compareTo(ClubMember clubMember) {
        return this.height - clubMember.getHeight();
    }
        </pre>

        <p>Sorting club members is easy, now.</p>

        <pre class="sh_java">
    List&lt;ClubMember&gt; clubMembers = new ArrayList&lt;ClubMember&gt;();
    clubMembers.add(new ClubMember("mikael", 182));
    clubMembers.add(new ClubMember("matti", 187));
    clubMembers.add(new ClubMember("joel", 184));

    System.out.println(clubMembers);
    Collections.sort(clubMembers);
    System.out.println(clubMembers);
        </pre>

        <pre>
[mikael (182), matti (187), joel (184)]
[mikael (182), joel (184), matti (187)]
        </pre>

        <p>If we want to sort the members in descending order, we only have to switch the variable order in our <code>compareTo</code> method.</p>


        <div class="tehtavat">
          <div class="tehtava">

            <h3>Rich First, Poor Last</h3>

            <p>You find the pre-made class Person. People have got name and salary information. Make Person implement the <code>Comparable</code> interface, so that the <code>compareTo</code> method would sort the people according to their salary -- rich first, poor last.</p>

          </div>
          <div class="tehtava">

            <h3>Students Sorted by Name</h3>

            <p>You find the pre-made class Student. Students have got a name. Make Student implement the <code>COmparable</code> interface, so that the <code>compareTo</code> method would sort the students in alphabetic order.</p>

            <p><b>Tip:</b> student names are Strings, the class String is <code>Comparable</code> itself. You can use the String's <code>compareTo</code> method when you implement your Student class. <code>String.compareTo</code> gives a different value to characters according to their case; because of this, String has also got the method <code>compareToIgnoreCase</code> which, in fact, ignores the case while comparing. You can use either of them, when you sort your students.</p>

          </div>
          <div class="tehtava">

            <h3>Sorting Cards</h3>

            <p>Together with the exercise layout, you find a class whose objects represent playing cards. Cards have got a value and a suit. Card values are <em>2, 3, ..., 10, J, Q, K </em> and <em>A</em>, and the suits are <em>Spades, Hearts, Diamonds</em> and <em>Clubs</em>. Value and suit are however shown as integers in the objects. Cards have also got a toString method, which is used to print the card value and suit in a "friendly way". </p>

            <p>Four constants -- that is <code>public static final</code> variables -- are defined in the class, so that the user didn't need to handle card's suits as numbers:</p>

            <pre class="sh_java">
public class Card {
    public static final int SPADES  = 0;
    public static final int DIAMONDS  = 1;
    public static final int HEARTS = 2;
    public static final int CLUBS   = 3;

    // ...
}
            </pre>

            <p>Now, instead of writing the number 1, we can use the constant <code>Card.DIAMONDS</code> in our program. In the following example, we create three cards and print them:</p>

            <pre class="sh_java">
  Card first = new Card(2, Card.DIAMONDS);
  Card second = new Card(14, Card.CLUBS);
  Card third = new Card(12, Card.HEARTS);

  System.out.println(first);
  System.out.println(second);
  System.out.println(third);
            </pre>

            <p>Prints:</p>

            <pre>
2 of Diamonds
A of Clubs
Q of Hearts
            </pre>

            <p><b>Note:</b> using constants as shown above is not the best way deal with things. Later on in the course we learn a better way to show suits!</p>

            <h4>Comparable Cards</h4>

            <p>Make your Cards class Comparable. Implement the <code>compareTo</code> method so that cards would be sorted in ascending order according to their value. If the value of two classes have got the same values, we compare them against their suit in ascending order: <em>spades first, diamonds second, hearts third, and clubs last</em>.</p>

            <p>The smallest card would then be the two spades and the greatest would be the clubs ace.</p>

            <h4>Hand</h4>

            <p>Next, let's create the class <code>Hand</code> which represents the player hand set of cards. Create the following method to the hand:</p>

            <ul>
              <li><code>public void add(Card card)</code> adds a card to the hand</li>
              <li><code>public void print()</code> prints the cards in the hand following the below example pattern</li>
            </ul>

            <pre class="sh_java">
  Hand hand = new Hand();

  hand.add( new Card(2, Card.SPADES) );
  hand.add( new Card(14, Card.CLUBS) );
  hand.add( new Card(12, Card.HEARTS) );
  hand.add( new Card(2, Card.CLUBS) );

  hand.print();
            </pre>

            <p>Prints:</p>

            <pre>
2 of Spades
A of Clubs
Q of Hearts
2 of Clubs
            </pre>

            <p>Store the hand cards into an ArrayList.</p>

            <h4>Sorting the Hand</h4>

            <p>Create the method <code>public void sort()</code> for your hand, which sorts the cards in the hand. After being sorted, the cards are printed in order:</p>

            <pre class="sh_java">
  Hand hand = new Hand();

  hand.add( new Card(2, Card.SPADES) );
  hand.add( new Card(14, Card.CLUBS) );
  hand.add( new Card(12, Card.HEARTS) );
  hand.add( new Card(2, Card.CLUBS) );

  hand.sort();

  hand.print();
            </pre>

            <p>Prints:</p>

            <pre>
2 of Spades
2 of Clubs
Q of Hearts
A of Clubs
            </pre>

            <h4>Comparing Hands</h4>

            <p>In one card game, the most valuable hand, where the sum of the cards value is the biggest. Modify the class <code>Hand</code> so that it could be compared according to this criterion: make it implement the interface <code>Comparable&lt;Hand&gt;</code>.</p>

            <p>Below, you find an example of a program where we compare hands:</p>

            <pre class="sh_java">
  Hand hand1 = new Hand();

  hand1.add( new Card(2, Card.SPADES) );
  hand1.add( new Card(14, Card.CLUBS) );
  hand1.add( new Card(12, Card.HEARTS) );
  hand1.add( new Card(2, Card.CLUBS) );

  Hand hand2 = new Hand();

  hand2.add( new Card(11, Card.DIAMONDS) );
  hand2.add( new Card(11, Card.CLUBS) );
  hand2.add( new Card(11, Card.HEARTS) );

  int comparison = hand1.compareTo(hand2);

  if ( comparison &lt; 0 ) {
    System.out.println("the most valuable hand contains the cards");
    hand2.print();
  } else if ( comparison &gt; 0 ){
    System.out.println("the most valuable hand contains the cards");
    hand1.print();
  } else {
    System.out.println("the hands are equally valuable");
  }
            </pre>

            <p>Prints:</p>

            <pre>
the most valuable hand contains the cards
J of Diamonds
J of Spades
J of Hearts
            </pre>

            <h4>Sorting the Cards against Different Criteria</h4>

            <p>What about if we wanted to sort cards in a slightly different way, sometimes; for instance, what about if we wanted to have all same-suit cards in a raw? The class can have only one compareTo method, which means that we have to find out other ways to sort cards against different orders.</p>

            <p>If you want to sort your cards in optional orders, you can make use of different classes which execute the comparison. These classes have to implement the interface <code>Comparator&lt;Card&gt;</code>. The object which determines the sorting order compares two cards it receives as parameter. There is only one method, a compare(Card card1, Card card2) method which has to return a negative value if card1 is before card2, a positive value if card2 is before card1, and 0 otherwise.</p>

            <p>The idea is creating a specific comparison class for each sorting order; for instance, a class which places same suit cards together in a row:</p>

            <pre class="sh_java">
import java.util.Comparator;

public class SortAgainstSuit implements Comparator&lt;Card&gt; {
    public int compare(Card card1, Card card2) {
        return card1.getSuit()-card2.getSuit();
    }
}
            </pre>

            <p>Sorting against suit works in the same way as the card method <code>compareTo</code> thought for suits, that is <em>spades first, diamonds second, hearts third, clubs last.</em></p></em></p>

          <p>Sorting is still possible through the Collections' sort method. The method now receives as second parameter an object of the class that determines the sorting order:</p>

          <pre class="sh_java">
  ArrayList&lt;Card&gt; cards = new ArrayList&lt;Card&gt;();

  cards.add( new Card(3, Card.CLUBS) );
  cards.add( new Card(2, Card.DIAMONDS) );
  cards.add( new Card(14, Card.CLUBS) );
  cards.add( new Card(12, Card.HEARTS) );
  cards.add( new Card(2, Card.CLUBS) );

  SortAgainstSuit suitSorter = new SortAgainstSuit();
  Collections.sort(cards, suitSorter );

  for (Card c : cards) {
    System.out.println( c );
  }
          </pre>

          <p>Prints:</p>

          <pre>
2 of Diamonds
Q of Hearts
3 of Clubs
A of Clubs
2 of Clubs
          </pre>

          <p>The sorting object can also be created directly together with the sort call:</p>

          <pre class="sh_java">
  Collections.sort(cards, new SortAgainstSuit() );
          </pre>
          <p>

          <p>Further information about comparator classes in <a href="http://leepoint.net/notes-java/data/collections/comparators.html">here.</a></p>

          <p>Create now the class <code>SortAgainstSuitAndValue</code> which iplements the Comparator interface and sorts cards as it is done in the example above, plus same suit cards are also sorted according to their value.
          </p>

          <h4>Sort Against Suit</h4>

          <p>Add the method <code>public void sortAgainstSuit()</code> to the class <code>Hand</code>; when the method is called the hand's cards are sorted according to the comparator <code>SortAgainstSuitAndValue</code>. After sorting them, the cards are printed in order:</p>

          <pre class="sh_java">
  Hand hand = new Hand();

  hand.add( new Card(12, Card.HEARTS) );
  hand.add( new Card(4, Card.CLUBS) );
  hand.add( new Card(2, Card.DIAMONDS) );
  hand.add( new Card(14, Card.CLUBS) );
  hand.add( new Card(7, Card.HEARTS) );
  hand.add( new Card(2, Card.CLUBS) );

  hand.sortAgainstSuit();

  hand.print();
          </pre>

          <p>Prints:</p>

          <pre>
2 of Diamonds
7 of Hearts
Q of Hearts
2 of Clubs
4 of Clubs
A of Clubs
          </pre>

        </div>
      </div>

      <h2>Collections</h2>

      <p>The class library <code><a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html" target="_blank">Collections</a></code> is Java's general-purpose library for collection classes. As we can see, <code>Collections</code> provides methods to sort objects either through the interface <code>Comparable</code> or <code>Comparator</code>. In addition to sorting, we can use this class library to retrieve the minimum and maximum values (through the methods <code>min</code> and <code>max</code>, respectively), retrieve a specific value (<code>binarySearch</code> method), or reverse the list (<code>reverse</code> method).</p>

      <h3>Search</h3>

      <p>The Collections class library provides a made-up binary search functionality. The method <code>binarySearch()</code> returns the index of our searched key, if this is found. If the key is not found, the search algorithm returns a negative value. The method <code>binarySearch()</code> makes use of the Comparable interface to retieve objects. If the object's <code>compareTo()</code> method returns the value 0, i.e. if it is the same object, the key is considered found.</p>

      <p>Our ClubMember class compares people's heights in its <code>compareTo()</code> method, i.e. we look for club members whose height is the same while we parse our list.</p>

      <pre class="sh_java">
    List&lt;ClubMember&gt; clubMembers = new ArrayList&lt;ClubMember&gt;();
    clubMembers.add(new ClubMember("mikael", 182));
    clubMembers.add(new ClubMember("matti", 187));
    clubMembers.add(new ClubMember("joel", 184));

    Collections.sort(clubMembers);

    ClubMember wanted = new ClubMember("Name", 180);
    int index = Collections.binarySearch(clubMembers, wanted);
    if (index &gt;= 0) {
        System.out.println("A person who is 180 centimiters tall was found at index " + index);
        System.out.println("name: " + clubMembers.get(index).getName());
    }

    wanted = new ClubMember("Name", 187);
    int index = Collections.binarySearch(clubMembers, wanted);
    if (index &gt;= 0) {
        System.out.println("A person who is 187 centimiters tall was found at index " + index);
        System.out.println("name: " + clubMembers.get(index).getName());
    }
      </pre>

      <p>The print output is the following:</p>

      <pre>
A person who is 187 centimiters tall was found at index 2
name: matti
      </pre>

      <p>Notice that we also called the method <code>Collections.sort()</code>, in our example. This is because binary search cannot be done if our table or list are not already sorted up.</p>







      <div class="tehtavat">

        <div class="tehtava">

          <h3>Ski Jumping</h3>

          <p>Once again, you can train to build the program structure yourself; the appearance of the user interface and its functionality are pre-defined.</p>

          <p><b>Note: you can create only one Scanner object lest the tests fail. Also, no not use static variables: the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</b></p>

          <p>Ski jumping is a beloved sport for Finns; they attempt to land as far as possible down the hill below, in the most stylish way. In this exercise, you create a simulator for a ski jumping tournament.</p>

          <p>First, the simulator asks the user for the jumper names. If the user inputs an empty string (i.e. presses enter), we move to the jumping phase. In the jumping phase, the jumpers jump one by one in reverse order according to their points. The jumper with the less points always jumps first, then the ones with more points, till the person with the most points.</p>

          <p>The total points of a jumper are calculated by adding up the points from their jumps. Jump points are decided in relation to the jump length (use a random integer between 60-120) and judge decision. Five judges vote for each jump (a vote is a random number between 10-20). The judge decision takes into consideration only three judge votes: the smallest and the greatest votes are not taken into account. For instance, if Mikael jumps 61 meters and the judge votes are 11, 12, 13, 14, and 15, the total points for the jump are 100.</p>

          <p>There are as many rounds as the user wants. When the user wants to quit, we print the tournament results. The tournament results include the jumpers, the jumper total points, and the lengths of the jumps. The final results are sorted against the jumper total points, and the jumper who received the most points is the first.</p>

          <p>Among the other things, you will need the method <code>Collections.sort</code> and <code>Collections.reverse</code>. First, you should start to wonder what kind of classes and objects there could be in your program. Also, it would be good to arrive to a situation where your user interface is the only class with printing statements.</p>

          <pre>
Kumpula ski jumping week

Write the names of the participants one at a time; an empty string brings you to the jumping phase.
  Participant name: <font color="red">Mikael</font>
  Participant name: <font color="red">Mika</font>
  Participant name:

The tournament begins!

Write "jump" to jump; otherwise you quit: <font color="red">jump</font>

Round 1

Jumping order:
  1. Mikael (0 points)
  2. Mika (0 points)

Results of round 1
  Mikael
    length: 95
    judge votes: [15, 11, 10, 14, 14]
  Mika
    length: 112
    judge votes: [14, 12, 18, 18, 17]

Write "jump" to jump; otherwise you quit: <font color="red">jump</font>

Round 2

Jumping order:
  1. Mikael (134 points)
  2. Mika (161 points)

Results of round 2
  Mikael
    length: 96
    judge votes: [20, 19, 15, 13, 18]
  Mika
    length: 61
    judge votes: [12, 11, 15, 17, 11]

Write "jump" to jump; otherwise you quit: <font color="red">jump</font>

Round 3

Jumping order:
  1. Mika (260 points)
  2. Mikael (282 points)

Results of round 3
  Mika
    length: 88
    judge votes: [11, 19, 13, 10, 15]
  Mikael
    length: 63
    judge votes: [12, 19, 19, 12, 12]

Write "jump" to jump; otherwise you quit: <font color="red">quit</font>

Thanks!

Tournament results:
Position    Name
1           Mikael (388 points)
            jump lengths: 95 m, 96 m, 63 m
2           Mika (387 points)
            jump lengths: 112 m, 61 m, 88 m
          </pre>



          <p><strong>Note1:</strong> it is essential that the <em>user interface</em> works exactly as displayed above; for instance, the number of spaces at the beginning of the lines must be right. <stong>The space at the beginning of the lines must be made of spaces</strong>, the tests do not work if you use tabulatation. Also, it is good that you copy the text which has to be printed by your program and you paste it into your code; you can copy it either from the exercise layout or from the test error messages. <em>The exercise is worth of four separate exercise points.</em></p>

        <p><strong>The program has to start when we execute the main method in the example layout. Also, remember again that you can create only one Scanner object in your exercise.</strong></p>

      </div>
    </div>
    <!--
    <p>A screencast where we create a bigger application using what we have learnt in the first two weeks:</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=LFxtwce8chM" height="300" target="_blank"><img src="img/youtube.jpg"/></a>


    <p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/LFxtwce8chM"></iframe></p>
-->


  </div>
  The material continues here: <a href="http://mooc.cs.helsinki.fi/programming-part2/material/week-9">Week 3</a>
</section>

<section class="viikkoraja" id="3" >
  <div class="viikkoraja">Week3</div>
  <div class="viikkoraja-mooc" id="Week 9" deadline="unlocks when 85% of week 8 done " data-first-chapter-index="42" data-first-exercise-index="124" data-first-week-index="9"  data-first-chapter-index-mooc="42" data-first-exercise-index-mooc="124" data-first-week-index-mooc="9" tekija="Arto Vihavainen, Matti Luukkainen">


    <h2>Single Responsibility Principle</h2>

    <p>When we design bigger programs, we often reason about what class has to deal with what task. If we delegate the implementation of the whole program to one class, the result is inevitably chaos. A sector of software design, <em>object-oriented design</em>, includes the <em>Single Responsibility Principle</em>, which we should follow.</p>

    <p>The Single Responsibility Principle states that each class should have only one clear role. If the class has one clear role, modifying that role is easy, and only one class will have to be modified. <em>Each class should have only one reason to be modified.</em>.</p>

    <p>Let us focus on the following class <code>Worker</code>, which has methods to calculate his salary and to report his working hours.</p>

    <pre class="sh_java">
public class Worker {
    // object variables

    // worker's constructor and methods

    public double calculateSalary() {
        // the logic concerning salary count
    }

    public String reportHours() {
        // the logic concerning working hours bookkeeping
    }
}
    </pre>

    <p>Even if the examples above do not show the concrete implementations, an alarm should go off. Our <code>Worker</code> class has at least three different responsibilities. It represents a worker, it performes the role of a salary calculator, and the role of a working hour bookkeeping system by reporting working hours. The class above should be split into three: one should represent the worker, another should represent the salary calculator, and the third should deal with time bookkeeping.</p>

    <pre class="sh_java">
public class Worker {
    // object variables

    // worker's constructor and methods
}
    </pre>

    <pre class="sh_java">
public class SalaryCalculator {
    // object variables

    // methods for salary count

    public double calculateSalary(Person person) {
        // salary calculation logic
    }
}
    </pre>


    <pre class="sh_java">
public class TimeBookkeeping {
    // object variables

    // methods concerning time bookkeeping

    public String createHourReport(Person person) {
        // working hours bookeeping logic
    }
}
    </pre>

    <p><em>Each variable, each code raw, each method, each class, and each program should have only one responsibility. Often a "better" program stucture is clear to the programmer only once the program is implemented. This is completely acceptable: even more important it is that we always try to change a program to make it clearer. <strong>Always refactor -- i.e. always improve your program when it is needed!</strong></em></p>


    <h2>Organising Classes into Packages</h2>

    <p>When we design and implement bigger programs, the number of classes rapidly grows. When the number of classes grows, remembering their functionality and methods becomes more difficult. Giving sensible names to classes helps to remember their funcitonality. In addition to giving sensible names, it is good to split the source code files into packages according to their functionality, use, and other logical reasons. In fact, the <em>packages</em> are but folders we use to organise our source code files. Directories are often called folders, both in windows and colloqually. We will use the term directory, anyway.</p>

    <p>Programming environments provide made-up tools for package management. So far, we have been creating classes and interfaces only in the <code>default package</code> of the <code>Source Packages</code> partition. In NetBeans, we can create a new package by clicking on <code>Source Packages</code>, and choosing <code>New -&gt; Java Package...</code>. In the created package, we can create classes in the same way as we do in the <code>default package</code>.</p>

    <p>You can read the name of the package that contains a certain class at the beginning of the source code files in the sentence <code>package <em>packageName</em></code> before the other statements. For instance, the below class <code>Implementation</code> is contained in the package <code>library</code>.</p>

    <pre class="sh_java">
package library;

public class Implementation {

    public static void main(String[] args) {
        System.out.println("Hello packageworld!");
    }
}
    </pre>

    <p>Packages can contain other packages. For instance, the package definition <code>package library.domain</code> means that the package <code>domain</code> is contained in the package <code>library</code>. By placing packages into other packages, we design the hierachy of classes and interfaces. For instance, all Java's classes are located in packages that are contained in the package <code>java</code>. The package name <code>domain</code> is often used to represent the storage location of the classes which deal with concepts specific for the domain. For instance, the class <code>Book</code> could be stored in the package <code>library.domain</code> because it represents a concept specific of the library.</p>

    <pre class="sh_java">
package library.domain;

public class Book {
    private String name;

    public Book(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
    </pre>

    <p>We can uses the classes stored in our packages through the <code>import</code> statement. For instance, the class <code>Implementation</code>, which is contained in the package <code>library</code> could make use of a class stored in <code>library.domain</code> through the assignment <code>import library.domain.Book</code>.</p>


    <pre class="sh_java">
package library;

import library.domain.Book;

public class Implementation {

    public static void main(String[] args) {
        Book book = new Book("The ABC of Packages!");
        System.out.println("Hello packageworld: " + book.getName());
    }
}
    </pre>

    <pre>
Hello packageworld: The ABC of Packages!
    </pre>

    <p>The import statements are defined in our source code file after the package statement but before the class statement. There can be many of them -- for instance, when we want to use different classes. Java's made-up classes are usually stored in <code>java</code> package child packages. Hopefully, the statements which appear at the beginning of our classes -- such as <code>import java.util.ArrayList</code> and <code>import java.util.Scanner;</code> -- are starting to look more meaningful now.</p>

    <p>From now on, in <em>all</em> our exercises we will use packages. Next, we will create our first packages ourselves.</p>

    <div class="tehtavat" id="viikko9">
      <div class="tehtava">

        <h3>First Packages</h3>

        <h4>UI Interface</h4>

        <p>Create the package <code>mooc</code> in your project. We create the functionality of our application inside this package. Add the package <code>ui</code> to your application; at this point, you should have the package <code>mooc.ui</code>. Create a new interface in it, and call it <code>UserInterface</code>.</p>

        <p>The interface <code>UserInterface</code> has to determine the method <code>void update()</code>. </p>

        <h4>Text User Interface</h4>

        <p>Create the class <code>TextUserInterface</code> in the same package; make it implement the interface <code>UserInterface</code>. Implement the method <code>public void update()</code> which is required by the interface <code>UserInterface</code> which <code>TextUserInterface</code> implements: its only duty should be printing the string "<code>Updating the user interface</code>" with a <code>System.out.println</code> method call.</p>

        <h4>Application Logic</h4>

        <p>Create now the package <code>mooc.logic</code>, and add the class <code>ApplicationLogic</code> in it. The application logic API should be the following:</p>

        <p>
        <ul>
          <li>the constructor <code>public ApplicationLogic(UserInterface ui)</code></li>. It receives as parameter a class which implements the interface UserInterface. Note: your application logic has to see the interface and therefore to import it; in other words, the line <code>import mooc.ui.UserInterface</code> must appear at the beginning of he file<br/>
          <li>the method <code>public void execute(int howManyTimes)</code></li> prints the string "The application logic works" as many times as it is defined by its parameter variable. After each "The application logic works" printout, the code has to call the <code>update()</code> method of the object which implements the interface <code>UserInterface</code> and which was assigned to the constructor as its parameter.<br/>
        </ul>
        </p>

        <p>You can test your application with the following main class.</p>

        <pre class="sh_java">
import mooc.logic.ApplicationLogic;
import mooc.ui.UserInterface;
import mooc.ui.TextUserInterface;

public class Main {

    public static void main(String[] args) {
        UserInterface ui = new TextUserInterface();
        new ApplicationLogic(ui).execute(3);
    }
}
        </pre>

        <p>The program output should be the following:</p>

        <pre>
The application logic works
Updating the user interface
The application logic works
Updating the user interface
The application logic works
Updating the user interface
        </pre>

      </div>
    </div>

    <h3>A Concrete Directory Construction</h3>

    <p>All the projects which can be seen are stored in your computer <em><a href="http://en.wikipedia.org/wiki/File_system" target="_blank">file system</a></em>. Each project has its own directory (folder) which contains the project directories and files.</p>

    <p>The project directory <code>src</code> contains the program source code. If a class package is a library, it is located in the directory <code>library</code> of the project source code directory <code>src</code>. If you are interested in it, it is possible to have a look at the concrete project structure in NetBeans, by going to the <em>Files</em> tab which is next to the <em>Projects</em> tab. If you can't see the <em>Files</em> tab, you can display it by choosing <em>Files</em> from the <em>Window</em> menu.</p>

    <p>Application development is usually done through the <em>Projects</em> tab, where NetBeans has hidden the project files which the programmer doesn't have to care about.</p>

    <h3>Visibility Definitions and Packages</h3>

    <p>We have already managed to know two visibility definitions. The method and variables with the visibility definition <code>private</code> are visible only inside the class that defines them. They cannot be used outside the class. Differently, the method and variables with visibility definition <code>public</code> are visible for any class.</p>

    <pre class="sh_java">
package library.ui;

public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        printTitle();

        // more functionality
    }

    private void printTitle() {
        System.out.println("***********");
        System.out.println("* LIBRARY *");
        System.out.println("***********");
    }
}
    </pre>

    <p>The object constructor and <code>start</code> method of the above class <code>UserInterface</code> can be called from whatever program. The method <code>printTitle</code> and the variable <code>reader</code> can be used only inside their class.</p>

    <p>When we want to assign package visibility to a variable or a method, we do not need to use any prefix. We can modify the example above assigning package visibility to the method <code>printTitle</code>.</p>

    <pre class="sh_java">
package library.ui;

public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        printTitle();

        // more functionality
    }

    void printTitle() {
        System.out.println("***********");
        System.out.println("* Library *");
        System.out.println("***********");
    }
}
    </pre>

    <p>Now, the classes <em>inside the same package</em> can use the method <code>printTitle</code>.

    <pre class="sh_java">
package library.ui;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner reader = new Scanner(System.in);
        UserInterface userInterface = new UserInterface(reader);

        userInterface.printTitle(); // it works!
    }
}
    </pre>

    <p>If the class is in a different package, the method <code>printTitle</code> can't be used.</p>

    <pre class="sh_java">
package library;

import java.util.Scanner;
import library.ui.UserInterface;

public class Main {

    public static void main(String[] args) {
        Scanner reader = new Scanner(System.in);
        UserInterface userInterface = new UserInterface(reader);

        userInterface.printTitle(); // it doesn't work  !
    }
}
    </pre>

    <h2>Many Interfaces, and Interface Flexibility</h2>

    <p>Last week we were introduced to interfaces. An interface defines one or more methods which have to be implemented in the class which implements the interface. The interfaces can be stored into packages like any other class. For instance, the interface <code>Identifiable</code> below is located in the package <code>application.domain</code>, and it defines that the classes which implement it have to implement the method <code>public String getID()</code>.</p>

    <pre class="sh_java">
package application.domain;

public interface Identifiable {
    String getID();
}
    </pre>

    <p>The class makes use of the interface through the keyword <code>implements</code>. The class <code>Person</code>, which implements the <code>Idenfifiable</code> interface. The <code>getID</code>of Person class always returns the person ID.</p>

    <pre class="sh_java">
package application.domain;

public class Person implements Identifiable {
    private String name;
    private String id;

    public Person(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return this.name;
    }

    public String getPersonID() {
        return this.id;
    }

    @Override
    public String getID() {
        return getPersonID();
    }

    @Override
    public toString(){
        return this.name + " ID: " +this.id;
    }
}
    </pre>


    <p>An interface strength is that interfaces are also <em>types</em>. All the objects which are created from classes that implement an interface also have that interface's type. This effictively helps us to build our applications.</p>

    <p>We create the class <code>Register</code>, which we can use to search for people against their names. In addition to retrieve single people, <code>Register</code> provides a method to retrieve a list with all the people.</p>

    <pre class="sh_java">
public class Register {
    private HashMap&lt;String, Identifiable&gt; registered;

    public Register() {
        this.registered = new HashMap&lt;String, Identifiable&gt;();
    }

    public void add(Identifiable toBeAdded) {
        this.registered.put(toBeAdded.getID(), toBeAdded);
    }

    public Identifiable get(String id) {
        return this.registered.get(id);
    }

    public List&lt;Identifiable&gt; getAll() {
        return new ArrayList&lt;Identifiable&gt;(registered.values());
    }
}
    </pre>

    <p>Using the register is easy.</p>

    <pre class="sh_java">
Register personnel = new Register();
personnel.add( new Person("Pekka", "221078-123X") );
personnel.add( new Person("Jukka", "110956-326B") );

System.out.println( personnel.get("280283-111A") );

Person found = (Person) register.get("110956-326B");
System.out.println( found.getName() );
    </pre>

    <p>Because the people are recorded in the register as <code>Identifiable</code>, we have to change back their type if we want to deal with people through those methods which are not defined in the interface. This is what happens in the last two lines.</p>

    <p>What about if we wanted an operation which returns the people recorded in our register sorted according to their ID?</p>

    <p>One class can implement various different interfaces, and our <code>Person</code> class can implement <code>Comparable</code> in addition to <code>Identifiable</code>. When we implement various different interfaces, we separate them with a comma (<code>public class ... implements <em>FirstInterface</em>, <em>SecondInterface</em> ...</code>). When we implement many interfaces, we have to implement all the methods required by all the interfaces. Below, we implement the interface <code>Comparable</code> in the class <code>Person</code>.</p>

    <pre class="sh_java">
package application.domain;

public class Person implements Identifiable, Comparable&lt;Person&gt; {
    private String name;
    private String id;

    public Person(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return this.name;
    }

    public String getPersonID() {
        return this.id;
    }

    @Override
    public String getID() {
        return getPersonID();
    }

    @Override
    public int compareTo(Person another) {
        return this.getID().compareTo(another.getID());
    }
}
    </pre>

    <p>Now, we can add to the register method sortAndGetEverything:</p>

    <pre class="sh_java">
    public List&lt;Identifiable&gt; sortAndGetEverything() {
        ArrayList&lt;Identifiable&gt; all = new ArrayList&lt;Identifiable&gt;(registered.values());
        Collections.sort(all);
        return all;
    }
    </pre>

    <p>However, we notice that our solution does not work. Because the people are recorded into the register as if their type was <code>Identifiable</code>, Person has to implement the interface <code>Comparable&lt;Identifiable&gt;</code> so that our register could sort people with its method <code>Collections.sort()</code>. This means we have to modify Person's interface:</p>

    <pre class="sh_java">
public class Person implements Identifiable, Comparable&lt;Identifiable&gt; {
    // ...

    @Override
    public int compareTo(Identifiable another) {
        return this.getID().compareTo(another.getID());
    }
}
    </pre>

    <p>Now our solution works!</p>

    <p>Our Register is unaware of the real type of the objects we record. We can use the class Register to record objects of different types than Person, as long as the object class implements the interface <code>Identifiable</code>. For instance, below we use the register to manage shop sales:</p>

    <pre class="sh_java">
public class Sale implements Identifiable {
    private String name;
    private String barcode;
    private int stockBalance;
    private int price;

    public Sale(String name, String barcode) {
        this.name = name;
        this.barcode = barcode;
    }

    public String getID() {
        return barcode;
    }

    // ...
}

Register products = new Register();
products.add( new Product("milk", "11111111") );
products.add( new Product("yogurt", "11111112") );
products.add( new Product("cheese", "11111113") );

System.out.println( products.get("99999999") );

Product product = (Product)products.get("11111112");
product.increaseStock(100);
product.changePrice(23);
    </pre>

    <p>The class <code>Register</code> is quite universal now that it is not dependent on concrete classes. Whatever class which implements <code>Identifiable</code> is compatible with Register. However, the method <code>sortAndGetEverything</code> can only work if we implement the interface Comparable&lt;Identifiable&gt;.</p>


    <!--
    <p>We create now the class <code>PersonRegister</code> which returns people using the interface <code>Identifiable</code>. In addition to retrieve individuals, <code>PersonRegister</code> provides a method to return a list with all the people.</p>

<pre class="sh_java">
public class PersonRegister {
    private HashMap&lt;String, Person&gt; people;

    public PersonRegister(HashMap&lt;String, Person&gt; people) {
        this.people = people;
    }

    public void addPerson(Person person) {
        this.people.put(person.getID(), person);
    }

    public void getPersonByID(Identifiable identifiable) {
        this.people.get(identifiable.getID());
    }

    public List&lt;Person&gt; getPerson() {
        return new ArrayList&lt;Person&gt;(people.values());
    }
}
</pre>

    <p>What about if we wanted to order our list in alphabetic order?</p>


    <p>One class can implement various different interfaces; in addition to <code>Identifiable</code> the class <code>Person</code> can implement the interface we saw last week, <code>Comparable</code>. We can implement different interfaces by separating their names with a comma (<code>public class ... implements <em>FirstInterface</em>, <em>SecondInterface</em> ...</code>). When we implement many interfaces, we also have to implement all the methods they require. In the following example, <code>Person</code> implements the interface <code>Comparable</code>.</p>

<pre class="sh_java">
package application.domain;

public class Person implements Identifiable, Comparable&lt;Person&gt; {
    private String name;
    private String id;

    public Person(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return this.name;
    }

    public String getPersonID() {
        return this.id;
    }

    @Override
    public String getID() {
        return getPersonID();
    }

    @Override
    public int compareTo(Person another) {
        return this.name.compareTo(another.getName());
    }
}
</pre>

    <p>Now we can extend our the List method of PersonRegister in the following way:</p>

<pre class="sh_java">
    public List&lt;Person&gt; getPerson() {
        ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;(people.values());
        Collections.sort(people);
        return people;
    }
</pre>

-->
    <!--

    <h3>Check-out Example</h3>

    <p>In this section, we can reason about the product identification operations of a shop check-out. We can suppose that the products have a barcode, a name, and a price. A <code>Product</code> object implements the already defined interface <code>Identifiable</code>.</p>

<pre class="sh_java">
package application.domain;

public class Tuote implements Identifiable {
    private String barcode;
    private String name;
    private int price;

    public Tuote(String barcode, String name, int price) {
        this.barcode = barcode;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return this.name;
    }

    public int getPrice() {
        return this.price;
    }

    @Override
    public String getID() {
        return this.barcode;
    }
}
</pre>

    <p>Below, we implement <code>BarcodeReader</code> which reads objects and turns them into products. The barcode reader has to identify products thanks to the interface <code>Identifiable</code>. We can implement the class <code>BarcodeReader</code> so that it will include a HashMap, which retrieves products against their ID. The BarcodeReader is a part of our application logic, and we store it into the package <code>application.logic</code>.</p>

<pre class="sh_java">
package application.logic;

public class BarcodeReader {
    private HashMap&lt;String, Product&gt; products;

    public BarcodeReader(HashMap&lt;String, Product&gt; products) {
        this.products = products;
    }

    public Product identify(Identifiable identifiable) {
        return this.products.get(identifiable.getID());
    }
}
</pre>

    <p>A BarcodeReader object returns a <code>Product</code> object if the barcode is found in the BarcodeReader HashMap. In the following example, we create a check-out which uses the barcode reader to add products to the purchase list. The class has the method <code>public void buy</code> which is given an instance of <code>Identifiable</code> as parameter. The purchase adds to the purchase list the objects which are recognised by the barcode reader. If an object is not recognised, nothing happens. The method <code>printPurchases</code> prints the name of the purchased products.</p>

<pre class="sh_java">
package application.domain;

public class Cashout {
    private BarcodeReader reader;
    private List&lt;Product&gt; products;

    public Cashout(BarcodeReader barcodeReader) {
        this.reader = barcodeReader;
        this.products = new ArrayList&lt;Product&gt;();
    }

    public void buy(Identifiable identifiable) {
        Product identified = this.reader.identify(identifiable);
        if (identified == null) {
            return;
        }

        this.products.add(identified);
    }

    public void printPurchases() {
        for(Product product: this.products) {
            System.out.println(product.getName());
        }
    }
}
</pre>

    <p>At this point we notice that it is extremely unconvenient to read products if they are printed in succession according to when they were added. We modify the output so that it will list the products in aplphabetic order. We add the interface <code>Comparable</code> to <code>Product</code> to sort our products in alphabetic order.</p>

<pre class="sh_java">
package application.domain;

public class Product implements Identifiable, Comparable&lt;Product&gt; {
    private String barcode;
    private String name;
    private int price;

    public Tuote(String barcode, String name, int price) {
        this.barcode = barcode;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return this.name;
    }

    public int getPrice() {
        return this.price;
    }

    @Override
    public String getID() {
        return this.barcode;
    }

    @Override
    public int compareTo(Product product) {
        return this.name.compareTo(product.getName());
    }
}
</pre>

    <p>We can still modify our cashout implementation so that our products are sorted if need be. Notice that the products only have to be sorted when products <em>are purchased</em>. A purchase is possibly the only situation where the order of the products in the list can change. If we do so, the purchases are always sorted when we call the method <code>printPurchases</code>.</p>

<pre class="sh_java">
package application.domain;

public class Checkout {
    private BarcodeReder reader;
    private List&lt;Product&gt; products;

    public Kassa( BarcodeReder BarcodeReader) {
        this.reader = BarcodeReader;
        this.products = new ArrayList&lt;Product&gt;();
    }

    public void buy(Identifiable identifiable) {
        Tuote identified = this.reader.identify(identifiable);
        if (identified == null) {
            return;
        }

        this.products.add(identified);
        Collections.sort(this.products);
    }

    public void printPurchases() {
        for(Product product: this.products) {
            System.out.println(product.getName());
        }
    }
}
</pre>

-->

    <div>
      <big><big><b>NetBeans Tips</b></big></big>

      <ul>
        <!-- TODO -->
        <li>All NetBeans tips can be found <a href="../instructions#netbeans">here</a> </li>
        <p></p>

        <li> <b>Implement all abstract methods</b>

        <p>
        Let us suppose that your program contains the interface <code>Interface</code>, and you are building the class <code>Class</code> which implements the interface. It will be annoying to write the declaration raws of all the interface methods.
        </p>

        <p>However it is possible to ask NetBeans to fill in the method bodies automatically. When you have defined the interface a class should implement, i.e. when you have written</p>

        <pre class="sh_java">
public class Class implements Interface {
}
        </pre>

        <p>NetBeans paints the class name red. If you go to lamp icon on the left corner of the raw, click, and choose <em>Implement all abstract methods</em>, the method bodies will appear in your code!</p>

        </li>

        <li> <b>Clean and Build</b>

        <p>
        Sometimes, NetBeans may get confused and try to run a code version without noticing all the corrected changes made to it. Usually you notice it because something "strange" happens. Usually, you can fix the problem by using <em>Clean and build</em> operation. The operation is found in the Run menu, and you can execute it also by clicking on the <em>brush and hammer</em> symbol. Clean and build deletes the translated versions of the code and generates a new translation.
        </p>

        </li>
      </ul>
    </div>

    <div class="tehtavat">
      <div class="tehtava">

        <h3>Moving</h3>

        <p>Before moving, you pack your things and put them into boxes trying to keep the number of boxes needed as small as possible. In this exercise we simulate packing things into boxes. Each thing has a volume, and boxes have got a maximum capacity.</p>


        <h4>Things and Items</h4>

        <p>The removers will later on move your things to a track (which is not implemented here); therefore, we first implement the interface <code>Thing</code>, which represents all things and boxes.</p>

        <p>The Thing interface has to determine the method <code>int getVolume()</code>, which is needed to understand the size of a thing. Implement the interface <code>Thing</code> in the package <code>moving.domain</code>.</p>

        <p>Next, implement the class <code>Item</code> in the package <code>moving.domain</code>. The class receives the item name (String) and volume (int) as parameter. The class has to implement the interface <code>Thing</code>.</p>

        <p>Add the method <code>public String getName()</code> to <code>Item</code>, and replace the method <code>public String toString()</code> so that it returns strings which follow the pattern "<code>name (volume dm^3)</code>". Item should now work like the following</p>

        <pre class="sh_java">
    Thing item = new Item("toothbrash", 2);
    System.out.println(item);
        </pre>

        <pre>
toothbrash (2 dm^3)
        </pre>

        <h4>Comparable Item</h4>

        <p>When we pack our items into boxes, we want to start in order from the first items. Implement the interface <code>Comparable</code> in the class <code>Item</code>; the item <em>natural order</em> must be ascending against volume. When you have implemented the interface <code>Comparable</code>, the <code>sort</code> method of class <code>Collection</code> has to work in the following way:.</p>


        <pre class="sh_java">
    List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();
    items.add(new Item("passport", 2));
    items.add(new Item("toothbrash", 1));
    items.add(new Item("circular saw", 100));

    Collections.sort(items);
    System.out.println(items);
        </pre>

        <pre>
[toothbrash (1 dm^3), passport (2 dm^3), circular saw (100 dm^3)]
        </pre>

        <h4>Moving Box</h4>

        <p>Implement now the class <code>Box</code> in the package <code>moving.domain</code>. At first, implement the following method for your Box:</p>

        <p>
        <ul>
          <li>the constructor <code>public Box(int maximumCapacity)</code></li> receives the box maximum capacity as parameter;<br/>
          <li>the method <code>public boolean addThing(Thing thing)</code></li> adds an item which implements the interface <code>Thing</code> to the box. If it does not fit in the box, the method returns <code>false</code>, otherwise <code>true</code>. The box must store the things into a list.<br/>
        </ul>
        </p>

        <p>Also, make your <code>Box</code> implement the <code>Thing</code> interface. The method <code>getVolume</code> has to return the current volume of the things inside the box.</p>

        <h4>Packing Items</h4>

        <p>Implement the class <code>Packer</code> in the package <code>moving.logic</code>. The constructor of the class <code>Packer</code> is given the parameter <code>int boxesVolume</code>, which determines how big boxes the packer should use.</p>

        <p>Afterwards, implement the method <code>public List&lt;Box&gt; packThings(List&lt;Thing&gt; things)</code>, which packs things into boxes.</p>

        <p>The method should move all the things in the parameter list into boxes, and these boxes should be contained by the list the method returns. You don't need to pay attention to such situations where the things are bigger than the boxes used by the packer. The tests do not check the way the packer makes use of the moving boxes.</p>

        <p>The example below shows how our packer should work:</p>

        <pre class="sh_java">
    // the things we want to pack
    List&lt;Thing&gt; things = new ArrayList&lt;Thing&gt;();
    things.add(new Item("passport", 2));
    things.add(new Item("toothbrash", 1));
    things.add(new Item("book", 4));
    things.add(new Item("circular saw", 8));

    // we create a packer which uses boxes whose valume is 10
    Packer packer = new Packer(10);

    // we ask our packer to pack things into boxes
    List&lt;Box&gt; boxes = packer.packThings( things );

    System.out.println("number of boxes: "+boxes.size());

    for (Box box : boxes) {
        System.out.println("  things in the box: "+box.getVolume()+" dm^3");
    }
        </pre>

        <p>Prints:</p>

        <pre>
number of boxes: 2
  things in the box: 7 dm^3
  things in the box: 8 dm^3
        </pre>

        <p>The packer has packed the things into two boxes, the first box has the firts three things, whose total volume was 7, and the last thing in the list -- the circular saw, whose volume was 8 -- has gone to the third box. The tests do not set a limit to the number of boxes used by the packer; each thing could have been packed into a different box, and the output would have been:</p>

        <pre>
number of boxes: 4
  things in the box: 2 dm^3
  things in the box: 1 dm^3
  things in the box: 4 dm^3
  things in the box: 8 dm^3
        </pre>

        <p><strong>Note:</strong> to help testing, it would be convinient to create a toString method for the class <code>Box</code>, for instance; this would help printing the content of the box.</p>

        <!--

  <h4>Tehokkaampi pakkaaminen</h4>

  <p>Alla on kuvattu erÃ¤s hieman tehokkaampi pakkaustapa <em>pseudokoodina</em>, eli ohjelmointikielen tapaisena koodina. Pseudokoodia kÃ¤ytetÃ¤Ã¤n muun muassa ohjelmointikieliriippumattomaan algoritmien eli ohjelmien kuvaamiseen.</p>

<pre>
pakkaaEsineet( esineet ):
    jarjesta( esineet )

    laatikot = [] // huom, kannattaa kÃ¤yttÃ¤Ã¤ ArrayListiÃ¤

    while esineet is not empty:
        Muuttolaatikko pakattu = pakkaaLaatikko( esineet )
        laatikot.add( pakattu )

    return laatikot

pakkaaLaatikko( esineet ):
    Muuttolaatikko laatikko = new Muuttolaatikko

    lisaaSuuria( esineet, laatikko )
    lisaaPienia( esineet, laatikko )

    return laatikko

lisaaSuuria( esineet, laatikko ):
    while esineet is not empty:
        esine = suurin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return

lisaaPienia(List esineet, Muuttolaatikko laatikko):
    while esineet is not empty:
        esine = pienin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return
</pre>

  <p>Muokkaa luokkaa <code>Pakkaaja</code> siten, ettÃ¤ se toimii samoin tai paremmin kuin yllÃ¤ kuvattu lÃ¤hestymistapa.</p>

  <p>Metodissa <code>pakkaaEsineet</code> pakataan muuttolaatikoita niin pitkÃ¤Ã¤n kun <code>esineet</code>-listalla on esineitÃ¤. Muuttolaatikkoa pakattaessa algoritmi lisÃ¤Ã¤ laukkuun ensiksi niin paljon suurimpia esineitÃ¤ kuin laatikkoon mahtuu. Kun laatikkoon ei enÃ¤Ã¤ mahdu suurimpia esineitÃ¤, aletaan tÃ¤yttÃ¤mÃ¤Ã¤n sitÃ¤ pienimmillÃ¤ esineillÃ¤.</p>

  <p>Toteutuksesta: Kun esineesi ovat jÃ¤rjestyksessÃ¤, suurin tavara lÃ¶ytyy indeksistÃ¤ <code>esinelistan koko - 1</code>, pienin tavara lÃ¶ytyy indeksistÃ¤ <code>0</code>. ÃlÃ¤ kÃ¤ytÃ¤ tÃ¤ssÃ¤ <code>Collections.min</code> ja <code>Collections.max</code>-metodeja, sillÃ¤ ne eivÃ¤t osaa arvata ettÃ¤ <code>ArrayList</code>-lista on jo jÃ¤rjestyksessÃ¤.</p>

  <p>Poista esineitÃ¤ <code>esineet</code>-listalta sitÃ¤ mukaa kun niitÃ¤ on lisÃ¤tty muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin joissa esineet ovat suurempia kuin muuttolaatikko.</p>

  <p><em>Huom!</em> Saadaksesi pisteen tÃ¤stÃ¤ viimeisestÃ¤ tehtÃ¤vÃ¤stÃ¤ algoritmisi tulee toimia <em>vÃ¤hintÃ¤Ã¤n</em> yhtÃ¤ hyvin kuin yllÃ¤ kuvattu algoritmi. HyvyydellÃ¤ tarkoitetaan sitÃ¤, ettÃ¤ pakkaukseen kulunut aika tulee olla vÃ¤hintÃ¤Ã¤n yhtÃ¤ pieni kuin pseudokoodiratkaisun. Muuttolaatikkojen mÃ¤Ã¤rÃ¤n tulee myÃ¶s olla vÃ¤hintÃ¤Ã¤n yhtÃ¤ pieni.</p>

  <p>Voit kÃ¤yttÃ¤Ã¤ seuraavaa metodia satunnaisten esineiden luomiseen.</p>

<pre class="sh_java">
    public static List&lt;Esine&gt; luoEsineet(int kpl, int maxTilavuus) {
        Random rand = new Random();

        List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
        for (int i = 0; i &lt; kpl; i++) {
            esineet.add(new Esine("hammasharja", 1 + rand.nextInt(maxTilavuus)));
        }

        return esineet;
    }
</pre>

  <p>YllÃ¤ kuvatulla algoritmilla pakkaamisen pitÃ¤isi toimia nopeasti jopa 100000 esinettÃ¤ sisÃ¤ltÃ¤villÃ¤ listoilla. Voit testata pakkaajasi nopeutta esimerkiksi seuraavasti:</p>

<pre class="sh_java">
        List&lt;Esine&gt esineet = luoEsineet(100000, 10);
        Pakkaaja pakkaaja = new Pakkaaja(50);

        long start = System.nanoTime();
        List&lt;Muuttolaatikko&gt laatikot = pakkaaja.pakkaaEsineet(esineet);
        long kulunutAika = ((System.nanoTime() - start) / 1000000);

        System.out.println("Pakkaukseen kului " + kulunutAika + " ms.");
        System.out.println("Tarvittiin " + laatikot.size() + " laatikkoa.");
</pre>

-->
      </div>
    </div>

    <h2>Exceptions</h2>

    <p>Exceptions are such situations where the program executions is different from our expectations. For instance, the program may have called a method of a <em>null</em> reference, in which case the user is <em>thrown</em> a <code>NullPointerException</code>. If we try to retrieve a index outside a table, the user is thrown a <code>IndexOutOfBoundsException</code>. All of them are a type of <code>Exception</code>.</p>

    <p>We deal with exception using the block <code>try { } catch (Exception e) { }</code>. The code contained within the brackets which follows the keyword <code>try</code> can <em>possibly</em> go through an exception. The keyword the code within the brackets which follow the keyword <code>catch</code> defines what should happen when the try-code throws an exception. We also define the type of the exception we want to catch (<code>catch (Exception e)</code>).</p>

    <pre class="sh_java">
    try {
        // code which can throw an exception
    } catch (Exception e) {
        // code which is executed in case of exception
    }
    </pre>

    <p>The <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#parseInt(java.lang.String)" target="_blank">parseInt</a></code> method of class <code>Integer</code> which turns a string into a number can throw a <code>NumberFormatException</code> if its string parameter cannot be turned into a number. Now we implement a program which tries to turn into a number a user input string.</p>

    <pre class="sh_java">
    Scanner reader = new Scanner(System.in);
    System.out.print("Write a number: ");

    int num = Integer.parseInt(reader.nextLine());
    </pre>

    <pre>
Write a number: <font color="red">tatti</font>
<font color="red">Exception in thread "..." java.lang.NumberFormatException: For input string: "tatti"</font>
    </pre>

    <p>The program above throws an exception because the user digits an erroneous number. The program execution ends up with a malfunction, and it cannot continue. We add an exception management statement to our program. The call, which may throw an exception is written into the <code>try</code> block, and the action which takes place in case of exception is written into the <code>catch</code> block.</p>

    <pre class="sh_java">
    Scanner reader = new Scanner(System.in);

    System.out.print("Write a number: ");

    try {
        int num = Integer.parseInt(reader.nextLine());
    } catch (Exception e) {
        System.out.println("You haven't written a proper number.");
    }
    </pre>

    <pre>
Write number: <font color="red">5</font>
    </pre>

    <pre>
Write number: <font color="red">oh no!</font>
You haven't written a proper number.
    </pre>

    <p>In case of exception, we move from the chunk of code defined by the <code>try</code> keyword to the <code>catch</code> chunk. Let's see this by adding a print statement after the <code>Integer.parseInt</code> line in the <code>try</code> chunk.</p>

    <pre class="sh_java">
    Scanner reader = new Scanner(System.in);

    System.out.print("Write a number: ");

    try {
        int num = Integer.parseInt(reader.nextLine());
        System.out.println("Looks good!");
    } catch (Exception e) {
        System.out.println("You haven't written a proper number.");
    }
    </pre>


    <pre>
Write a number: <font color="red">5</font>
Looks good!
    </pre>

    <pre>
Write a number: <font color="red">I won't!</font>
you haven't written a proper number.
    </pre>

    <p>String <code>I won't!</code> is given as parameter to the method <code>Integer.parseInt</code>, which throws an exception if the String parameter can't be changed into a number. Note that the code in the <code>catch</code> chunk is executed <em>only</em> in case of exception -- otherwise the program do not arrive till there.</p>

    <p>Let's make something more useful out of our number translator: let's do a method which keeps on asking to type a number till the user does it. The user can return <em>only</em> if they have typed the right number.</p>

    <pre class="sh_java">
public int readNumber(Scanner reader) {
    while (true) {
        System.out.print("Write a number: ");

        try {
            int num = Integer.parseInt(reader.nextLine());
            return num;
        } catch (Exception e) {
            System.out.println("You haven't written a proper number.");
        }
    }
}
    </pre>

    <p>The method <code>readNumber</code> could work in the following way:</p>

    <pre>
Write a number: <font color="red">I won't!</font>
You haven't written a proper number.
Write a number: <font color="red">Matti has a mushroom on his door.</font>
You haven't written a proper number.
Write a number: <font color="red">43</font>

    </pre>


    <h3>Throwing Exceptions</h3>

    <p>Methods and constructors can <em>throw</em> exceptions. So far, there are two kinds of exceptions which can be thrown. There are the ones which have to be handled, and the ones which don't have to be dealt with. When we have to handle the exceptions, we do it either in a <code>try-catch</code> chunk, or <em>throwing them from a method</code></em>. </p>

  <p>In the clock exercise of Introduction to Programming, we explained that we can stop our program of one second, by calling the method <code>Thread.sleep(1000)</code>. The method may throw an exception, which we <em>must</em> deal with. In fact, we handle the exception using the <code>try-catch</code> sentence; in the following example we skip the exception, and we leave empty the <code>catch</code> chunk.</p>

  <pre class="sh_java">
    try {
        // we sleep for 1000 milliseconds
        Thread.sleep(1000);
    } catch (Exception e) {
        // In case of exception, we do not do anything.
    }
  </pre>

  <p>It is also possible to avoid handling the exceptions in a method, and <em>delegate the responsibility</em> to the method caller. We delegate the responsibility of a method by using the statement <code>throws Exception</code>.</p>

  <pre class="sh_java">
    public void sleep(int sec) <strong>throws Exception</strong> {
        Thread.sleep(sec * 1000);   // now we don't need the try-catch block
    }
  </pre>

  <p>The <code>sleep</code> method is called in another method. Now, this other method can either handle the exception in a <code>try-catch</code> block or delegate the responsibility forward. Sometimes, we delegate the responsibility of handling an exception, till the very end, and even the <code>main</code> method delegates it:</p>
  <pre class="sh_java">
public class Main {
   public static void main(String[] args) throws Exception {
       // ...
   }
}
  </pre>

  <p>In such cases, the exception ends up in Java's virtual machine, which interrupts the program in case there is an error which causes the problem.</p>

  <p>There are some exceptions which the programmer does not always have to address, such as the <code>NumberFormatException</code> which is thrown by <code>Integer.parseInt</code>. Also the <code>RuntimeException</code>s do not always require to be addressed; next week we will go back to <em>why</em> variables can have more than one type.</p>

  <p>We can throw an exception ourself from the source code using the <code>throw</code> statement. For instance, if we want to throw an exception which was created in the class <code>NumberFormatException</code>, we could use the statement <code>throw new NumberFormatException()</code>.</p>

  <p>Another exception which hasn't got to be addressed is <code>IllegalArgumentException</code>. With <code>IllegalArgumentException</code> we know that a method or a constructor has received an <em>illegal</em> value as parameter. For instance, we use the IllegalArgumentException when we want to make sure that a parameter has received particular values. We create the class <code>Grade</code> whose constructor has a integer parameter: the grade.</p>

  <pre class="sh_java">
public class Grade {
    private int grade;

    public Grade(int grade) {
        this.grade = grade;
    }

    public int getGrade() {
        return this.grade;
    }
}
  </pre>

  <p>Next, we want to validate the value of the constructor parameter of our Grade class. The grades in Finland are from 0 to 5. If the grade is something else, we want to <em>throw an exception</em>. We can add an if statement to our <code>Grade</code> class constructor, which checks whether the grade is outside range 0-5. If so, we throw an <code>IllegalArgumentException</code> telling <code>throw new IllegalArgumentException("The grade has to be between 0-5");</code>.</p>

  <pre class="sh_java">
public class Grade {
    private int grade;

    public Grade(int grade) {
        if (grade &lt; 0 || grade &gt; 5) {
            throw new IllegalArgumentException("The grade has to be between 0-5");
        }
        this.grade = grade;
    }

    public int getGrade() {
        return this.grade;
    }
}
  </pre>

  <pre class="sh_java">
    Grade grade = new Grade(3);
    System.out.println(grade.getGrade());

    Grade wrongGrade = new Grade(22);
    // it causes an exception, we don't continue
  </pre>

  <pre>
3
Exception in thread "..." java.lang.IllegalArgumentException: The grade has to be between 0-5
  </pre>


  <div class="tehtavat">
    <div class="tehtava">
      <h3>Method Argument Validation</h3>

      <p>Let's train method argument validation with the help of the <code>IllegalArgumentException</code>. The excercise layout shows two classes <code>Person</code> and <code>Calculator</code>. Change the class in the following way:</p>

      <h4>Person Validation</h4>

      <p>The constructor of <code>Person</code> has to make sure its parameter's Name variable is not null, empty, or longer than 40 characters. The age has also to be between 0-120. If one of the conditions above are not satisfied, the constructor has to throw an <code>IllegalArgumentException</code>.</p>

      <h4>Calculator Validation</h4>

      <p>The <code>Calculator</code> methods have to be changed in the following way: the method <code>multiplication</code> has to work only if its parameter is not negative (greater than 0). The method <code>binomialCoefficient</code> has to work only if the parameters are not negative and the size of a subset is smaller than the set's size. If one of the methods receives invalid arguments when they are called, they have to throw a <code>IllegalArgumentException</code>.</p>
    </div>
    <div class="tehtava">

      <h3>Sensors and Temperature Measurement</h3>

      <p>All the code in our application has to be placed into the package <code>application</code>.</p>

      <p>We have got the following interface available for our use:</p>

      <pre class="sh_java">
public interface Sensor {
    boolean isOn();  // returns true if the sensor is on
    void on();       // switches the sensor on
    void off();      // switches the sensor off
    int measure();   // returns the sensor reading if the sensor is on
                     // if the sensor is off, it throws an IllegalStateException
}
      </pre>

      <h4>Constant Sensor</h4>

      <p>Create the class <code>Constant Sensor</code> which implements the interface <code>Sensor</code>.</p>

      <p>The constant sensor is online all the time. The methods on() and off() do not do anything. The constant sensor has a constructor with an int parameter. The <code>measure</code> method call returns the number received as constructor parameter.</p>

      <p>For instance:</p>

      <pre class="sh_java">
public static void main(String[] args) {
  ConstantSensor ten = new ConstantSensor(10);
  ConstantSensor minusFive = new ConstantSensor(-5);

  System.out.println( ten.measure() );
  System.out.println( minusFive.measure() );

  System.out.println( ten.isOn() );
  ten.off();
  System.out.println( ten.isOn() );
}
      </pre>

      <p>Prints:</p>

      <pre>
10
-5
true
true
      </pre>

      <h4>Thermometer</h4>

      <p>Create the class <code>Thermometer</code> which implements the interface <code>Sensor</code>.</p>

      <p>At first, the thermometer is off. When the <code>measure</code> method is called, if the thermometer is on it returns a random number between -30 and 30. If the thermometer is off, it throws an </code>IllegalStateException</code>.
  </p>

  <h4>AverageSensor</h4>

  <p>Create the class <code>AverageSensor</code> which implements the interface </code>Sensor</code>.</p>

<p>An average sensor contains many sensors. In addition to the methods defined by the interface <code>Sensor</code>, the class has the method <code>public void addSensor(Sensor additional)</code> which adds a new sensor to the AverageSensor.</p>

<p>The average sensor is on when <em>all</em> its sensors are on. When the average sensor is switched on, all its sensors have to be switched on if they were not on already. When the average sensor is closed, at least one of its sensors has to be switched off. It's also possible that all its sensors are switched off.</p>

<p>The <code>measure</code> method of our AverageSensor returns the average of the readings of all its sensors (because the return value is <code>int</code>, the readings are rounded down as it is for integer division). If the <code>measure</code> method is called when the average sensor is off, or if the average sensor was not added any sensor, the method throws an <code>IllegalStateException</code>.
</p>

<p>Below, you find an example of a sensor program (note that both the Thermometer and the AverageSensor constructors are without parameter):</p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensor kumpula = new Thermometer();
    kumpula.on();
    System.out.println("the temperature in Kumpula is "+kumpula.measure() + " degrees");

    Sensor kaisaniemi = new Thermometer();
    Sensor helsinkiVantaa = new Thermometer();

    AverageSensor helsinkiArea = new AverageSensor();
    helsinkiArea.addSensor(kumpula);
    helsinkiArea.addSensor(kaisaniemi);
    helsinkiArea.addSensor(helsinkiVantaa);

    helsinkiArea.on();
    System.out.println("the temperature in Helsinki area is "+helsinkiArea.measure() + " degrees");
}
</pre>

<p>Prints (the printed readings depend on the random temperature readings):</p>

<pre class="sh_java">
the temperature in Kumpula is -7 degrees
the temperature in Helsinki area is -10 degrees
</pre>

<p><b>Note:</b> you'd better use a ConstantSensor object to test your average sensor!</p>

<h4>All Readings</h4>

<p>Add the method <code>public List&lt;Integer&gt; readings()</code> to your AverageSensor; it returns a list of the reading results of all the measurements executed through your AverageSensor. Below is an example of how the method works: </p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensor kumpula = new Thermometer();
    Sensor kaisaniemi = new Thermometer();
    Sensor helsinkiVantaa = new Thermometer();

    AverageSensor helsinkiArea = new AverageSensor();
    helsinkiArea.addSensor(kumpula);
    helsinkiArea.addSensor(kaisaniemi);
    helsinkiArea.addSensor(helsinkiVantaa);

    helsinkiArea.on();
    System.out.println("the temperature in Helsinki area is "+helsinkiArea.measure() + " degrees");
    System.out.println("the temperature in Helsinki area is "+helsinkiArea.measure() + " degrees");
    System.out.println("the temperature in Helsinki area is "+helsinkiArea.measure() + " degrees");

    System.out.println("readings: "+helsinkiArea.readings());
}
</pre>

<p>Prints (again, the printed readings depend on the random temperature readings):</p>

<pre class="sh_java">
the temperature in Helsinki area is -10 degrees
the temperature in Helsinki area is -4 degrees
the temperature in Helsinki area is -5 degrees

readings: [-10, -4, 5]
</pre>

</div>
</div>




<h3>Exceptions and Interfaces</h3>

    <p>Interfaces do not have a method body, but the method definition can be freely chosen when the developer implements the interface. Interfaces can also define the exceptions throw. For instance, the classes which implement the following <code>FileServer</code> can <em>possibly</em> throw an exception in their methods <code>download</code> and <code>save</code>.</p>

<pre class="sh_java">
public interface FileServer {
    String download(String file) throws Exception;
    void save(String file, String string) throws Exception;
}
</pre>

    <p>If an interface defines the <code>throws Exception</code> attributes for the methods -- i.e. the methods may throw an exception -- the classes which implement the interface must be defined in the same way. However, they do not have to throw an exception, as it becomes clear in the following example.</p>

<pre class="sh_java">
public class TextServer implements FileServer {

    private Map&lt;String, String&gt; data;

    public TextServer() {
        this.data = new HashMap&lt;String, String&gt;();
    }

    @Override
    public String download(String file) throws Exception {
        return this.data.get(file);
    }

    @Override
    public void save(String file, String string) throws Exception {
        this.data.put(file, stirng);
    }
}
</pre>

<h3>The Exception Information</h3>

    <p>The <code>catch</code> block tells how we handle an exception, and it tells us what exception we should be prepared for: <code>catch (<em>Exception e</em>)</code>. The exception information is saved into the <code>e</code> variable.</p>

<pre class="sh_java">
    try {
        // the code, which may throw an exception
    } catch (Exception e) {
        // the exception information is saved into the variable e
    }
</pre>

    <p>The class <code>Exception</code> can provide useful methods. For instance, the method <code>printStackTrace()</code> prints a <em>path</em> which tells us where the exception came from. Let's check the following error printed by the method <code>printStackTrace()</code>.</p>

<pre>
Exception in thread "main" java.lang.NullPointerException
  at package.Class.print(Class.java:43)
  at package.Class.main(Class.java:29)
</pre>

    <p>Reading the stack trace happens button up. The lowest is the first call, i.e. the program execution has started from the <code>main()</code> method of class <code>Class</code>. At line 29 of the main method of <code>Class</code>, we called the method <code>print()</code>. Line 43 of the method <code>print</code> caused a <code>NullPointerException</code>. Exception information are extremely important to find out the origin of a problem.</p>


<h2>Reading a File</h2>

    <p>A relevant part of programming is related to stored files, in one way or in another. Let's take the first steps in Java file handling. Java's API provides the class <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">File</a>, whose contents can be read using the already known <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a> class.</p>

    <p>If we read the desciption of the <code>File</code> <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">API</a> we notice the <code>File</code> class has the constructor <code>File(String pathname)</code>, which <em>creates a new File instance by converting the given pathname string into an abstract pathname</em>. This means the <code>File</code> class constructor can be given the pathname of the file we want to open.</p>

    <p><em>In the NetBeans programming environment, files have got their own tab called <em>Files</em>, which contains all our project files. If we add a file to a project <em>root</em> -- that is to say outside all folders -- we can refer to it by writing only the its name. We create a file object by fiving the file pathname to it as parameter:</em></p>

<pre class="sh_java">
    File file = new File("file-name.txt");
</pre>

    <p><code>System.in</code> input stream is not the only reading source we can give to the constructor of a Scanner class. For instance, the reading source can be a file, in addition to the user keyboard. Scanner provides the same methods to read a keyboard input and a file. In the following example, we open a file and we print all the text contained in the file using the <code>System.out.println</code> statement. At the end, we close the file using the statement <code>close</code>.</p>

<pre class="sh_java">
        // The file we read
        File file = new File("filename.txt");

        Scanner reader = new Scanner(file);
        while (reader.hasNextLine()) {
            String line = reader.nextLine();
            System.out.println(line);
        }

        reader.close();
</pre>

    <p>The Scanner class constructor <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html#Scanner(java.io.File)" target="_blank">public Scanner(File source)</a></code> (<em>Constructs a new Scanner that produces values scanned from the specified file.</em>) throws a <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileNotFoundException.html" target="_blank">FileNotFoundException</a></code> when the specified file is not found. The <code>FileNotFoundException</code> is different than <code>RuntimeException</code>, and we have either to handle it or throw it forward. At this point, you only have to know that the programming environment tells you whether you have to handle the exception or not. Let's first create a try-catch block where we handle our file as soon as we open it.</p>

<pre class="sh_java">
    public void readFile(File f) {
        // the file we read
        Scanner reader = null;

        try {
            reader = new Scanner(f);
        } catch (Exception e) {
            System.out.println("We couldn't read the file. Error: " + e.getMessage());
            return; // we exit the method
        }

        while (reader.hasNextLine()) {
            String line = reader.nextLine();
            System.out.println(line);
        }

        reader.close();
    }
</pre>

    <p>Another option is to delegate the exception handling responsibility to the method caller. We delegate the exception handling responsibility by adding the definition <code>throws <em>ExceptionType</em></code> to the method. For instance, we can add <code>throws Exception</code> because the type of all exceptions is <code>Exception</code>. When a method has the attribute <code>throws Exception</code>, whatever chunk of code which calls that method knows that it may throw an exception, and it should be prepared for it.</p>

<pre class="sh_java">
    public void readFile(File f) throws Exception {
        // the file we read
        Scanner reader = new Scanner(f);

        while (reader.hasNextLine()) {
            String line = reader.nextLine();
            System.out.println(line);
        }

        reader.close();
    }
</pre>

    <p>In the example, the method <code>readFile</code> receives a file as parameter, and prints all the file lines. At the end, the reader is closed, and the file is closed with it, too. The attribute <code>throws Exception</code> tells us that the method may throw an exception. Same kind of attributes can be added to all the methods that handle files.</p>

    <p>Note that the <code>Scanner</code> object's method <code>nextLine</code> returns a string, but it does not return a new line at the end of it. If you want to read a file and still maintain the new lines, you can add a new line at the end of each line:</p>

<pre class="sh_java">
    public String readFileString(File f) throws Exception {
        // the file we read
        Scanner reader = new Scanner(f);

        String string = "";

        while (reader.hasNextLine()) {
            String line = reader.nextLine();
            string += line;
            string += "\n";
        }

        reader.close();
        return string;
    }
</pre>

    <p>Because we use the <code>Scanner</code> class to read files, we have all Scanner methods available for use. For instance the method <code>hasNext()</code> returns the boolean value <code>true</code> if the file contains something more to read, and the method <code>next()</code> reads the following word and returns a <code>String</code> object. </p>

    <p>The following program creates a <code>Scanner</code> object which opens the file <code>file.txt</code>. Then, it prints every fifth word of the file.</p>

<pre class="sh_java">
        File f = new File("file.txt");
        Scanner reader = new Scanner(f);

        int whichNumber = 0;
        while (reader.hasNext()) {
            whichNumber++;
            String word = reader.next();

            if (whichNumber % 5 == 0) {
                System.out.println(word);
            }
        }
</pre>

    <p>Below, you find the text contained in the file, followed by the program output.</p>

<pre>
Exception handling is the process of responding to the occurrence, during computation, of exceptions â anomalous or exceptional events requiring special processing â often changing the normal flow of program execution. ...
</pre>

<pre>
process
occurrence,
â
requiring
changing
program
</pre>

<h3>Character Set Issues</h3>

    <p>When we read a text file (or when we save something into a file), Java has to find out the character set used by the operating system. Knowledge of the character set is required both to save text on the computer harddisk in binary format, and to translate binary data into text.</p>

    <p>There have been developed standard character sets, and "UTF-8" is the most common nowadays. UTF-8 character set contains both the alphabet letters of everyday use and more particular characters such as the Japanese kanji characters or the information need to read and save the chess pawns. From a simplified programming angle, we could think a character set both as a character-number hashmap and a number-character hashmap. The character-number hashmap shows what binary number is used to save each character into a file. The number-character hashmap shows how we can translate into characters the values we obtain reading a file.</p>

    <p>Almost each operating system producer has also got their own standards. Some support and want to contribute to the use of open source standards, some do not. If you have got problems with the use of Scandinavian characters such as Ã¤ and Ã¶ (expecially Mac and Windows users), you can tell which character set you want to use when you create a <code>Scanner</code> object. In this course, we always use the the "UTF-8" character set.</p>

    <p>You can create a Scanner object which to read a file which uses the UTF-8 character set in the following way:</p>

<pre class="sh_java">
    File f = new File("examplefile.txt");
    Scanner reader = new Scanner(f, "UTF-8");
</pre>

    <p>Anther thing you can do to set up a character set is using an environment variable. Macintosh and Windows users can set up an the value of the environment variable <code>JAVA_TOOL_OPTIONS</code> to the string <code>-Dfile.encoding=UTF8</code>. In such case, Java always uses UTF-8 characters as a default.</p>

<div class="tehtavat">
    <div class="tehtava">
  <h3>Printer</h3>

<p>Create the class <code>Printer</code>, its constructor <code>public Printer(String fileName)</code> which receives a String standing for the file name, and the method <code>public void printLinesWhichContain(String word)</code> which prints the file lines which contain the parameter word (<em>lower and upper case make difference in this excercise; for instance, "test" and "Test" are not the considered the same</em>); the lines are printed in the same order as they are inside the file.</p>

<p>If the argument is an empty String, all of the file is printed.</p>

<p>If the file is not found, the constructor delegates the exception with no need for a try-catch statement; the constructor simply has to be defined in the following way:</p>

<pre class="sh_java">
public Printer {

   public Printer(String fileName) throws Exception {
      // ...
   }

   // ...
}
</pre>

<p>The file <em>textFile</em> has been place into the default package of your project to help the tests. When you define the file name of the constructor of Printer, you have to write <code>src/textfile.txt</code>. The file contains an extract of Kalevala, a Finnish epic poem:</p>

<pre>
SiinÃ¤ vanha VÃ¤inÃ¤mÃ¶inen
katseleikse kÃ¤Ã¤nteleikse
Niin tuli kevÃ¤tkÃ¤kÃ¶nen
nÃ¤ki koivun kasvavaksi
MiksipÃ¤ on tuo jÃ¤tetty
koivahainen kaatamatta
Sanoi vanha VÃ¤inÃ¤mÃ¶inen
</pre>

<p>The following example shows what the program should do:</p>

<pre class="sh_java">
    Printer printer = new Printer("src/textfile.txt");

    printer.printLinesWhichContain("VÃ¤inÃ¤mÃ¶inen");
    System.out.println("-----");
    printer.printLinesWhichContain("Frank Zappa");
    System.out.println("-----");
    printer.printLinesWhichContain("");
    System.out.println("-----");
</pre>

<p>Prints:</p>

<pre>
SiinÃ¤ vanha VÃ¤inÃ¤mÃ¶inen
Sanoi vanha VÃ¤inÃ¤mÃ¶inen
-----
-----
SiinÃ¤ vanha VÃ¤inÃ¤mÃ¶inen
katseleikse kÃ¤Ã¤nteleikse
Niin tuli kevÃ¤tkÃ¤kÃ¶nen
nÃ¤ki koivun kasvavaksi
MiksipÃ¤ on tuo jÃ¤tetty
koivahainen kaatamatta
Sanoi vanha VÃ¤inÃ¤mÃ¶inen
</pre>

<p>In the project, you also find the whole Kalevala; the file name is <code>src/kalevala.txt</code></p>
</div>
<div class="tehtava">
  <h3>File Analysis</h3>

  <p>In this exercise, we create an application to calculate the number of lines and characters.</p>

  <h4>Number of Lines</h4>


  <p>Create the class <code>Analysis</code> in the package <code>file</code>; the class has the constructor <code>public Analysis(File file)</code>. Create the method <code>public int lines()</code>, which returns the number of lines of the file the constructor received as parameter.</p>

<p>The method cannot be "disposable", that is to say it has to return the right value even though it is called different times in a raw. Note that after you create a Scanner object for a file and read its whole contents using <code>nextLine</code> method calls, you can't use the <em>same</em> scanner to read the file again!</p>

<p><strong>Attention:</strong> if the tests report a <em>timeout</em>, it probably means that you haven't been reading the file at all, meaning that the <code>nextLine</code> method calls miss!</p>

  <h4>Number of Characters</h4>

  <p>Create the method <code>public int characters()</code> in the class <code>Analysis</code>; the method returns the number of characters of the file the constructor received as parameter.</p>

<p>The method cannot be "disposable", that is to say it has to return the right value even though it is called different times in a raw.</p>

  <p>You can decide yourself what to do if the constructor parameter file does not exist.</p>

<p>The file <em>testFile</em> has been place into the test package of your project to help the tests. When you define the file name of the constructor of Analysis, you have to write <code>test/testfile.txt</code>. The file contains the following text:</p>

<pre>
there are 3 lines, and characters
because line breaks are also
characters
</pre>

<p>The following example shows what the program should do:</p>

<pre class="sh_java">
    File file = new File("test/testfile.txt");
    Analysis analysis = new Analysis(file);
    System.out.println("Lines: " + analysis.lines());
    System.out.println("Characters: " + analysis.characters());
</pre>

<pre>
Lines: 3
Characters: 74
</pre>
</div>
<div class="tehtava">
  <h3>Word Inspection</h3>

  <p>Create the class WordInspection, which allows for different kinds of analyses on words. Implement the class in the package <code>wordinspection</code>.</p>

  <p>The Institute for the Languages of Finland (Kotimaisten kielten tutkimuskeskus, Kotus) has published online a list of Finnish words. In this exercise we use a modified version of that list, which can be found in the exercise source folder <code>src</code> with the name <code>wordList.txt</code>; the relative path is <code>"src/wordList.txt"</code>. Because the word list if quite long, in fact, a <code>shortList.txt</code> was created in the project for the tests; the file can be found following the path <code>"src/shortList.txt"</code>.
</p>

  <p><strong>If you have problems with Scandinavian letters </strong> (Mac and Windows users) create your <code>Scanner</code> object assigning it the "UTF-8" character set, in the following way: <code>Scanner reader = new Scanner(file, "UTF-8");</code> Problems come expecially when the tests are executed.</p>

  <h4 class="req">Word Count</h4>

  <p>Create the constructor <code>public WordInspection(File file)</code> to your WordInspection class. The constructor creates a new WordInspection object which inspects the given file.</p>

  <p>Create the method <code>public int wordCount()</code>, which counts the file words and prints their number. In this part, you don't have to do anything with the words, you should only count how many there are. For this exercise, you can expect there is only one word in each row.</p>


  <h4 class="req">z</h4>

  <p>Create the method <code>public List&lt;String&gt; wordsContainingZ()</code>, which returns all the file words which contain a z; for instance, jazz and zombie.</p>

  <h4 class="req">Ending l</h4>

  <p>Create the method <code>public List&lt;String&gt; wordsEndingInL()</code>, which returns all the Finnish words of the file which end in l; such words are, for instance, kannel and sammal.</p>

  <p><em>Attention! If you read the file various different times in your program, you notice that your code contains a lot of copy-paste, so far. It would be useful to think whether it would be possible to read the file in an different place, maybe inside the constructor or as a method, which the constructor calls. In such case, the methods could use a list which was read before and then create a new list which suits their search criteria. In week 12, we will come back again with an ortodox way to eliminate copy-paste.</em></p>

  <h4>Palindromes</h4>

  <p>Create the method <code>public List&lt;String&gt; palindromes()</code>, which returns all the palindrome words of the file. Such words are, for instance, ala and enne.</p>

  <h4 class="req">All Vowels</h4>

  <p>Create the method <code>public List&lt;String&gt; wordsWhichContainAllVowels()</code>, which returns all the words of the file which contain all Finnish vowels (aeiouyÃ¤Ã¶). Such words are, for instance, myÃ¶hÃ¤iselokuva and ympÃ¤ristÃ¶nsuojelija.</p>
</div>
</div>





<h2>Hashmaps and Sets</h2>

<h3>Many Values and One Key</h3>

<p>As we remember, we can save only one value per key using HashMap. In the following examples we save people's mobile phone numbers in a HashMap.</p>

<pre class="sh_java">
  Map&lt;String, String&gt; phoneNumbers = new HashMap&lt;String, String&gt;();

  phoneNumbers.put("Pekka", "040-12348765");

  System.out.println( "Pekka's number: "+ phoneNumbers.get("Pekka") );

  phoneNumbers.put("Pekka", "09-111333");

  System.out.println( "Pekka's number: "+ phoneNumbers.get("Pekka") );
</pre>

<p>as expected, the output tells us:</p>

<pre>
Pekka's number: 040-12348765
Pekka's number: 09-111333
</pre>

<p>What about if we wanted to save various different values per one key, what about if a person had many phone numbers? Can we manage with an HashMap? Of course! For instance, instead of saving Strings as HashMap values we could save ArrayLists, mapping more than one object to one key. Let's change the way we save phone numbers as follows:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; phoneNumbers = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();
</pre>

<p>Now, a list is mapped to each HashMap key. Even though the new command creates a HashMap, the list which will be saved inside has to be created separately. In the following example, we add two numbers to the HashMap for Pekka, and we print them:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; phoneNumbers = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();

  // We map an empty ArrayList to Pekka
  phoneNumbers.put( "Pekka", new  ArrayList&lt;String&gt;() );

  // we add Pekka's number to the list
  phoneNumbers.get("Pekka").add("040-12348765");

  // and we add a second phone number
  phoneNumbers.get("Pekka").add("09-111333");

  System.out.println( "Pekka's numbers: "+ phoneNumbers.get("Pekka") );
</pre>

<p>Prints</p>

<pre>
Pekka's numbers: [040-12348765, 09-111333]
</pre>

<p>We define the phone number type as <code>Map&lt;String, ArrayList&lt;String&gt;&gt;</code>, that is a Map whose key is a String and whose value is a list containing strings. The concrete implementation -- that is to say the created object -- was a HashMap. We could have defined a variable also in the following way:
</p>

<pre class="sh_java">
Map&lt;String, List&lt;String&gt;&gt; phoneNumbers = new HashMap&lt;String, List&lt;String&gt;&gt;();
</pre>

<p>Now, the variable type is a Map, whose key is a String and value is a <code>List</code> containing strings. In fact, a List is an interface which defines the List functionality, and ArrayLists implement this interface, for instance. The concrete object is a HashMap.</p>

<p>The values we save into the HashMap are concrete object which implement the interface <code>List&lt;String&gt;</code>, ArrayLists, for instance. Again, we can add values to the HashMap in the following way:</p>

<pre class="sh_java">
  // first, we map an empty ArrayList to Pekka
  phoneNumbers.put( "Pekka", new  ArrayList&lt;String&gt;() );

  // ...
</pre>

<p>In the future, instead of using concrete classes (such as <code>HashMap</code> and <code>ArrayList</code>, for instance), we will always try to use their respective interfaces <code>Map</code> and <code>List</code>.</p>

<h3>Sets</h3>

    <p>Differently from lists, in a <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> there can be up to one same entry, that is to say the same object can not be contained twice in a set. The similarity between two objects is inspected using the methods <code>equals</code> and <code>hashCode</code>. </p>

<p>One of the classes which implement the <code>Set</code> interface is  <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>. Let's use it to implement the class <code>ExerciseAccounting</code>, which allows us to keep an account of the exercise we do and to print them. Let's suppose the the exercises are always integers.</p>

<pre class="sh_java">
public class ExerciseAccounting {
    private Set&lt;Integer&gt; doneExercises;

    public ExerciseAccounting() {
        this.doneExercises = new HashSet&lt;Integer&gt;();
    }

    public void add(int exercise) {
        this.doneExercises.add(exercise);
    }

    public void print() {
        for (int exercise: this.doneExercises) {
            System.out.println(exercise);
        }
    }
}
</pre>

<pre class="sh_java">
        ExerciseAccounting account = new ExerciseAccounting();
        account.add(1);
        account.add(1);
        account.add(2);
        account.add(3);

        account.print();
</pre>

<pre>
1
2
3
</pre>

    <p>The solution above is useful if we don't need information about the exercises done by each different user. We can change the saving logic of the exercises in a way to have them save in relation to each user, using a HashMap. The users are recognized through a unique string (for instance, their student number), and each user has their own set of finished exercises.</p>

<pre class="sh_java">
public class ExerciseAccounting {
    private Map&lt;String, Set&lt;Integer&gt;&gt; doneExercises;

    public ExerciseAccounting() {
        this.doneExercises = new HashMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void add(String user, int exercise) {
        // note that when we create a new user we have first to map an empty exercise set to it
        if (!this.doneExercises.containsKey(user)) {
            this.doneExercises.put(user, new HashSet&lt;Integer&gt;());
        }

        // first, we retrieve the set containing the user's exercises and then we add an exercise to it
        Set&lt;Integer&gt; finished = this.doneExercises.get(user);
        finished.add(exercise);

        // the previous would have worked out without helping variable in the following way:
        //  this.doneExercises.get(user).add(exercise);
    }

    public void print() {
        for (String user: this.doneExercises.keySet()) {
            System.out.println(user + ": " + this.doneExercises.get(user));
        }
    }
}
</pre>

<pre class="sh_java">
        ExerciseAccounting accounting = new ExerciseAccounting();
        accounting.add("Mikael", 3);
        accounting.add("Mikael", 4);
        accounting.add("Mikael", 3);
        accounting.add("Mikael", 3);

        accounting.add("Pekka", 4);
        accounting.add("Pekka", 4);

        accounting.add("Matti", 1);
        accounting.add("Matti", 2);

        accounting.print();
</pre>

<pre>
Matti: [1, 2]
Pekka: [4]
Mikael: [3, 4]
</pre>


    <p>Note that the user names are not printed in order, in our example. This depends on the saving process of the <code>HashMap</code> entries, which happens through the value returned by the <code>hashCode</code> method, and does not involve the entry order in any way.</p>

<div class="tehtavat">
    <div class="tehtava">
<h3>Multiple Entry Dictionary</h3>

<p>Let's make an extended version of the dictionary of week 1. Your task is to implement the class <code>PersonalMultipleEntryDictionary</code>, which can save one or more entry for each word translated. The class has to implement the interface in the exercise source, <code>MultipleEntryDictionary</code>, with the following methods:</p>

<p>
  <ul>
<li><code>public void add(String word, String entry)</code></li>, which adds a new entry to a word, maintaining the old ones<br/>
<li><code>public Set&lt;String&gt; translate(String word)</code></li>, which returns a <code>Set</code> object, with all the entries of the word, or a <code>null</code> reference, if the word is not in the dictionary<br/>
<li><code>public void remove(String word)</code></li>, which removes a word and all its entries from the dictionary<br/>
  </ul>
</p>

<p>As for the ExampleAccounting above, it's good to store the translations into a <code>Map&lt;String, Set&lt;String&gt;&gt;</code> object variable.</p>

<p>The interface code:</p>

<pre class="sh_java">
package dictionary;

import java.util.Set;

public interface MultipleEntryDictionary {
    void add(String word, String translation);
    Set&lt;String&gt; translate(String word);
    void remove(String word);
}
</pre>

<p>An example program:</p>

<pre class="sh_java">
    MultipleEntryDictionary dict = new PersonalMultipleEntryDictionary();
    dict.add("kuusi", "six");
    dict.add("kuusi", "spruce");

    dict.add("pii", "silicon");
    dict.add("pii", "pi");

    System.out.println(dict.translate("kuusi"));
    dict.remove("pii");
    System.out.println(dict.translate("pii"));
</pre>

<p>Prints:</p>

<pre>
[six, spruce]
null
</pre>

</div>


<!-- TODO: Translate -->
<div class="tehtava">
  <h3>Duplicate Remover</h3>

  <p>Your task is to implement inside the package <code>tools</code> a class <code>PersonalDuplicateRemover</code>, which stores the given characterStrings so that equal characterStrings are removed (a.k.a duplicates). Class also holds a record of the amount of duplicates. Class should implement the given interface <code>DuplicateRemover</code>, which has the following methods:</p>

  <p>
    <ul>
<li><code>public void add(String characterString)</code></li> stores a characterString if it's not a duplicate.<br/>
<li><code>public int getNumberOfDetectedDuplicates()</code></li> returns the number of detected duplicates.<br/>
<li><code>public Set&lt;String&gt; getUniqueCharacterStrings()</code></li> returns an object which implements the interface <code>Set&lt;String&gt;</code>. Object should have all unique characterStrings (no duplicates!). If there are no unique characterStrings, method returns an empty set.<br/>
<li><code>public void empty()</code></li> removes stored characterStrings and resets the amount of detected duplicates.<br/>
    </ul>
  </p>

  <p>Code of the interface:</p>

<pre class="sh_java">
package tools;

import java.util.Set;

public interface DuplicateRemover {
    void add(String characterString);
    int getNumberOfDetectedDuplicates();
    Set&lt;String&gt; getUniqueCharacterStrings();
    void empty();
}
</pre>

  <p>Interface can be used like this for example:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        DuplicateRemover remover = new PersonalDuplicateRemover();
        remover.add("first");
        remover.add("second");
        remover.add("first");

        System.out.println("Current number of duplicates: " +
            remover.getNumberOfDetectedDuplicates());

        remover.add("last");
        remover.add("last");
        remover.add("new");

        System.out.println("Current number of duplicates: " +
            remover.getNumberOfDetectedDuplicates());

        System.out.println("Unique characterStrings: " +
            remover.getUniqueCharacterStrings());

        remover.empty();

        System.out.println("Current number of duplicates: " +
            remover.getNumberOfDetectedDuplicates());

        System.out.println("Unique characterStrings: " +
            remover.getUniqueCharacterStrings());
    }
</pre>

  <p>Code above would print: (order of characterStrings can change, it doesn't matter)</p>

<pre>
Current number of duplicates: 1
Current number of duplicates: 2
Unique characterStrings: [first, second, last, new]
Current number of duplicates: 0
Unique characterStrings: []
</pre>

</div>
</div>

<h3>One Object in Many Lists, a Map Construction or a Set</h3>

<p>As we remember, object variable are reference-type, which means that the variable does not memorize the object itself, but the reference to the object. Respectively, if we put an object into an ArrayList, for instance, the List does not memorize the object itself but the <code>reference</code> to the object. There is no reason why we should not be able to save an object in various different lists or HashMaps, for instance.</p>

<p>Let's have a look at our library example, which saves books into HashMaps, both based on their writer and ISB number. In addition to this, the library. Moreover, the library has two lists for the books on loan and for the ones that are on the shelves.</p>

<pre class="sh_java">
public class Book {
    private String ISBN;
    private String writer;
    private String name;
    private int date;
    // ...
}

public class Library {
    private Map&lt;String, Book&gt; ISBNBooks;
    private Map&lt;String, List&lt;String&gt;&gt; writerBooks;
    private List&lt;Book&gt; loanBooks;
    private List&lt;Book&gt; shelfBooks;

    public void addBook(Book newBook){
        ISBNBooks.put(newBook.getIsbn(), newBook);
        writerBooks.get(newBook.getWriter()).add(newBook);
        shelfBooks.add(newBook);
    }

    public Book getBookBasedOnISBN(String isbn){
        return ISBNBooks.get(isbn);
    }

    // ...
}
</pre>

<p>If an object is listed in different places at the same time (in a list, a set, or a map construction), you have to pay particular attention so to make sure the state of the different collections is consistent. For instance, if we decide to delete a book, it must be deleted from both maps as well as from the two lists which contain the books on loan and on the shelves.</p>

<div class="tehtavat">

    <div class="tehtava">

  <h3>Phone Search</h3>

<p><b>Attention: you can create only one Scanner object so that your tests would work well. Also, do not use static variables, the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</b></p>


<p>Let's create an application to manage people phone numbers and addresses.</p>

<p>The exercise can be worth 1-5 points. To receive one point, you should implement the following functionality:</p>

<ul>
<li>1 adding a phone number to the relative person</li>
<li>2 phone number search by person</li>
</ul>

<p>to receive two points we also require</p>

<ul>
<li>3 name search by phone number</li>
</ul>

<p>to receive three points also</p>

<ul>
<li>4 adding an address to the relative person</li>
<li>5 personal information search (search for a person's address and phone number)</li>
</ul>

<p>if you want to receive four points, also implement</p>

<ul>
<li>6 removing a person's information</li>
</ul>

<p>and to receive all the points:</p>

<ul>
<li>7 filtered search by keyword (retrieving a list which must be sorted by name in alphabetic order), the keyword can appear in the name or address</li>
</ul>

<p>An example of how the program works:</p>

<pre>
phone search
available operations:
 1 add a number
 2 search for a number
 3 search for a person by phone number
 4 add an address
 5 search for personal information
 6 delete personal information
 7 filtered listing
 x quit

command: <font color="red">1</font>
whose number: <font color="red">pekka</font>
number: <font color="red">040-123456</font>

command: <font color="red">2</font>
whose number: <font color="red">jukka</font>
  not found

command: <font color="red">2</font>
whose number: <font color="red">pekka</font>
 <font color="red">040-123456</font>

command: <font color="red">1</font>
whose number: <font color="red">pekka</font>
number: <font color="red">09-222333</font>

command: <font color="red">2</font>
whose number: <font color="red">pekka</font>
 040-123456
 09-222333

command: <font color="red">3</font>
number: <font color="red">02-444123</font>
 not found

command: <font color="red">3</font>
number: <font color="red">09-222333</font>
 pekka

command: <font color="red">5</font>
whose information: <font color="red">pekka</font>
  address unknown
  phone numbers:
   040-123456
   09-222333

command: <font color="red">4</font>
whose address: <font color="red">pekka</font>
street: <font color="red">ida ekmanintie</font>
city: <font color="red">helsinki</font>

command: <font color="red">5</font>
whose information: <font color="red">pekka</font>
  address: ida ekmanintie helsinki
  phone numbers:
   040-123456
   09-222333

command: <font color="red">4</font>
whose address: <font color="red">jukka</font>
street: <font color="red">korsontie</font>
city: <font color="red">vantaa</font>

command: <font color="red">5</font>
whose information: <font color="red">jukka</font>
  address: korsontie vantaa
  phone number not found

command: <font color="red">7</font>
keyword (if empty, all listed): <font color="red">kk</font>

 jukka
  address: korsontie vantaa
  phone number not found

 pekka
  address: ida ekmanintie helsinki
  phone numbers:
   040-123456
   09-222333

command: <font color="red">7</font>
keyword (if empty, all listed): <font color="red">vantaa</font>

 jukka
  address: korsontie vantaa
  phone number not found

command: <font color="red">7</font>
keyword (if empty, all listed): <font color="red">seppo</font>
 keyword not found

command: <font color="red">6</font>
whose information: <font color="red">jukka</font>

command: <font color="red">5</font>
whose information: <font color="red">jukka</font>
  not found

command: <font color="red">x</font>
</pre>

<p>Some remarks:</p>
<ul>
<li>Because of the tests, it is essential that the <em>user interface</em> works exactly as in the example above. The application can optionally decide in which way invalid inputs are handled. The tests contain only valid inputs.</li>
<li><em><strong>The program has to start when the main method is executed; you can only create one Scanner object.</strong></em></li>
<li>Do not use static variables, the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</li>
<li>In order to make things easier, we assume the name is a single string; if we want to print our lists sorted by surname in alphabetic order, the name has to be given in the form <em>surname name</em>.</li>
<li>A person can have more than one phone number and address. However, these are not necessarily stored.</li>
<li>If a person is deleted, no search should retrieve them.</li>
</ul>
</div>
</div>
</div>
The material continues here: <a href="http://mooc.cs.helsinki.fi/programming-part2/material/week-10">Week 4</a>
</section>



<section class="viikkoraja" id="4" >
  <div class="viikkoraja">Week4</div>
  <div class="viikkoraja-mooc" id="Week 10" deadline="unlocks when 85% of week 9 done " data-first-chapter-index="48" data-first-exercise-index="134" data-first-week-index="10"  data-first-chapter-index-mooc="48" data-first-exercise-index-mooc="134" data-first-week-index-mooc="10" tekija="Arto Vihavainen, Matti Luukkainen">
<div class="tehtavat">
    <div class="tehtava">
<h3>The Finnish Ringing Centre</h3>

<p>In the sixth week of Introduction to Programming, we created an observation database for bird watching. Now we continue in the same vein, and this time, we create a program for the ringing centre to track of the places where the rung birds were observed.</p>

<big>
<p><strong>ATTENTION:</strong> You may run into a strange error message in this exercise, such as <code>NoSuchMethodError: Bird.equals(BBird;)Z</code>; if this happens, <strong>clean and build</strong>, i.e. press the brush and hammer icon in NetBeans.</p>
</big>

<h4>Bird equals and toString</h4>

<p>The Finnish Ringing Centre stores the information about the birds who were watched in a specific year in <code>Bird</code> objects:</p>

<pre class="sh_java">
public class Bird {

    private String name;
    private String latinName;
    private int ringingYear;

    public Bird(String name, String latinName, int ringingYear) {
        this.name = name;
        this.latinName = latinName;
        this.ringingYear = ringingYear;
    }

    @Override
    public String toString() {
        return this.latinName + "(" + this.ringingYear + ")";
    }
}

</pre>

<p>The idea is implementing the funcionality for the ringing centre to track of the places where rung birds were observed and how many times they were. However, observation places and times are not stored in Bird objects, but in a separate HashMap, whose keys are Bird objects. As we remember from Week 2, in such cases we have to implement the methods <code>equals(Object other)</code> and <code>hashCode()</code> in the class <code>Bird</code>.</p>

<p>Some birds have more than one English name (for instance, the Rose Starling is also known as Rose-Coloured Starling or Rose-Coloured Pastor); however, the Latin name is always unique. Create the methods <code>equals</code> and <code>hashCode-</code> in the class <code>Bird</code>; two Bird objects have to be understood as the same bird if their Latin name and observation year are the same.</p>

<p>Example:</code>

<pre>
    Bird bird1 = new Bird("Rose Starling", "Sturnus roseus", 2012);
    Bird bird2 = new Bird("Rose-Coloured Starling", "Sturnus roseus", 2012);
    Bird bird3 = new Bird("Hooded Crow", "Corvus corone cornix", 2012);
    Bird bird4 = new Bird("Rose-Coloured Pastor", "Sturnus roseus", 2000);

    System.out.println( bird1.equals(bird2));   // same Latin name and same observation year: they are the same bird
    System.out.println( bird1.equals(bird3));   // different Latin name: they are not the same bird
    System.out.println( bird1.equals(bird4));   // different observation year: not the same bird
    System.out.println( bird1.hashCode()==bird2.hashCode() );
</pre>

<p>Prints:</p>

<pre>
true
false
false
true
</pre>

<h4>Ringing Centre</h4>

<p>The Ringing Centre has two methods: <code>public void observe(Bird bird, String place)</code>, which records the observation and its place among the bird information; and <code>public void observations(Bird bird)</code>, which prints all the observations of the parameter bird following the example below. The observation printing order is not important, as far as the tests are concerned.</p>

<p>The Ringing Centre stores the observation places in a <code>Map&lt;Bird, List&lt;String&gt;&gt;</code> object variable. If you need, you can use the exercise from Section 16 as example.</p>

<p>An example of how the Ringing Centre works:</p>

<pre class="sh_java">
    RingingCentre kumpulaCentre = new RingingCentre();

    kumpulaCentre.observe( new Bird("Rose Starling", "Sturnus roseus", 2012), "Arabia" );
    kumpulaCentre.observe( new Bird("Rose-Coloured Starling", "Sturnus roseus", 2012), "Vallila" );
    kumpulaCentre.observe( new Bird("European Herring Gull", "Larus argentatus", 2008), "KumpulanmÃ¤ki" );
    kumpulaCentre.observe( new Bird("Rose Starling", "Sturnus roseus", 2008), "Mannerheimintie" );

    kumpulaCentre.observations( new Bird("Rose-Coloured Starling", "Sturnus roseus", 2012 ) );
    System.out.println("--");
    kumpulaCentre.observations( new Bird("European Herring Gull", "Larus argentatus", 2008 ) );
    System.out.println("--");
    kumpulaCentre.observations( new Bird("European Herring Gull", "Larus argentatus", 1980 ) );
</pre>

<p>Prints:</p>

<pre>
Sturnus roseus (2012) observations: 2
Arabia
Vallila
--
Larus argentatus (2008) observations: 1
KumpulanmÃ¤ki
--
Larus argentatus (1980) observations: 0
</pre>

</div>
</div>


<h2>Object Polymorphism</h2>

    <p>Precedently, we have run into situations where variables had various different types, in addition to their own. For instance, in the section <a href="#45">45</a>, we noticed that <em>all</em> objects are <code>Object</code>-type. If an object is a particular type, we can also represent it as <code>Object</code>-type. For instance, <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" target="_blank">String</a></code> is also <code>Object</code>-type, and all <code>String</code> variables can be defined using <code>Object</code>.</p>

<pre class="sh_java">
    String string = "string";
    Object string = "another string";
</pre>

    <p>It is possible to assign a String to an <code>Object</code>-type reference.</p>

<pre class="sh_java">
    String string = "characterString";
    Object string = string;
</pre>

    <p>The opposite way does not work. Because <code>Object</code>-type variables are not Strings, an Object variable cannot be assigned to a String variable.</p>

<pre class="sh_java">
    Object string = "another string";
    String string = string; // DOESN'T WORK!
</pre>

    <p>What is the real problem?</p>

    <p>Variables have got their own type, and in addition to it they also have got the type of their parent classes and interfaces. The class <code>String</code> derives from the <code>Object</code> class, and therefore <code>String</code> objects are also <code>Object</code>-type. The class <code>Object</code> does not derive from the class <code>String</code>, and therefore <code>Object</code> variables are not automatically <code>String</code>-type. Let's dig deeper into the <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">String</a></code> class API documentation, expecially the upper part of the HTML page.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/string-api.png"/></p>

    <p>The String class API documentation starts with the common heading; this is followed by the class package (<code>java.lang</code>). After the package you find the class name (<code>Class String</code>), and this is followed by the <em>inheritance hierarchy</em>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html">java.lang.Object</a>
  <img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/perinta.gif"/><strong>java.lang.String</strong>
</pre>

    <p>The inheritance hierarchy lists the classes from which a class derives. The inherited classes are listed in hierarchical order, where the class we are analizing is the last one. As far as our String class inheritance hierarchy is concerned, we notice that the <code>String</code> class derives from the class <code>Object</code>. <em>In Java, each class can derive from one class, tops</em>; however, they can inherit features of more than one, undirectly.</p>

    <p>You can think inheritance hierarchy as if it was a list of types, which the object has to implement.</p>

    <p>The fact that all objects are <code>Object</code>-type helps programming. If we only need the features defined in the <code>Object</code> class in our method, we can use <code>Object</code> as method parameter. Because all objects are also Object-type, a method can be given <em>whatever</em> object as parameter. Let's create the method <code>printManyTimes</code>, which receives an <code>Object</code> variable as parameter, and the number of times this must be printed.</p>

<pre class="sh_java">
public class Printer {
    ...
    public void printManyTimes(Object object, int times) {
        for (int i = 0; i &lt; times; i++) {
            System.out.println(object.toString());
        }
    }
    ...
}
</pre>

    <p>You can give whaterver object parameter to the method <code>printManyTimes</code>. Within the method <code>printManyTimes</code>, the object has only the method which are defined in the <code>Object</code> class at its disposal, because the method is <em>presented</em> as <code>Object</code>-type inside the mehod.</p>

<pre class="sh_java">
    Printer printer = new Printer();

    String string = " o ";
    List&lt;String&gt; words = new ArrayList&lt;String&gt;();
    words.add("polymorphism");
    words.add("inheritance");
    words.add("encapsulation");
    words.add("abstraction");

    printer.printManyTimes(string, 2);
    printer.printManyTimes(words, 3);
</pre>

<pre>
 o
 o
[polymorphism, inheritance, encapsulation, abstraction]
[polymorphism, inheritance, encapsulation, abstraction]
[polymorphism, inheritance, encapsulation, abstraction]
</pre>


    <p>Let's continue with our <code>String</code> class API inspection. In the description, the inheritance hierarchy is followed by a list of the interfaces which the class implements.</p>

<pre>
<strong>All Implemented Interfaces:</strong>
  <A HREF="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html" title="interface in java.io">Serializable</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html" title="interface in java.lang">CharSequence</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html" title="interface in java.lang">Comparable</A>&lt;<A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" title="class in java.lang">String</A>&gt;
</pre>

    <p>The <code>String</code> class implements the interfaces <code>Serializable</code>, <code>CharSequence</code>, and <code>Comparable&lt;String&gt;</code>. An interface is a type, too. According to the description of the String API, we should be able to set the following interfaces as the type of a String object.</p>

<pre class="sh_java">
    Serializable serializableString = "string";
    CharSequence charSequenceString = "string";
    Comparable&lt;String&gt; comparableString = "string";
</pre>

    <p>Because we can define the parameter type of a method, we can define methods which would accept an object which implements <em>a specific interface</em>. When we define an interface as method parameter, the parameter can be whatever object which implements such interface, the method does not care about the object actual type.</p>

    <p>Let's implement our <code>Printer</code> class, and create a method to print the characters of the objects which implement the interface <code>CharSequence</code>. The <code>CharSequence</code> interface also provides methods such as <code>int length()</code>, which returns the String's length, and <code>char charAt(int index)</code>, which returns the character at a specific index.</p>

<pre class="sh_java">
public class Printer {
    ...
    public void printManyTimes(Object object, int times) {
        for (int i = 0; i &lt; times; i++) {
            System.out.println(object.toString());
        }
    }

    public void printCharacters(CharSequence charSequence) {
        for (int i = 0; i &lt; charSequence.length(); i++) {
            System.out.println(charSequence.charAt(i);
        }
    }
    ...
}
</pre>

    <p>Whatever object which implements the <code>CharSequence</code> interface can be assigned to the method <code>printCharacters</code>. For instance, you can give a <code>String</code> or a <code>StringBuilder</code> which is usually more efficient when it comes to string building. The method <code>printCharacters</code> prints each character of the object in its own line.</p>

<pre class="sh_java">
    Printer printer = new Printer();

    String string = "works";

    printer.printCharacters(string);
</pre>

<pre>
w
o
r
k
s
</pre>

<div class="tehtavat">
    <div class="tehtava">

<h3>Groups</h3>

<p>In this exercise, we make organisms and groups of organisms which move around each other. The position of the organisms is reported by using a <em>bidimensional coordinate system</em>. Each position is defined by two numbers, the <code>x</code> and <code>y</code> coordinates. The <code>x</code> coordinate tells us how far from the "point zero" the position is horizontally, whereas the <code>y</code> coordinate tells u how far the position is vertically. If you have got doubts of what a coordinate system is, you can read more information in <a href="http://en.wikipedia.org/wiki/Coordinate_system">Wikipedia</a>, for instance.</p>

<p>Together with the exercise, you find the interface <code>Movable</code>, which represents things that can be moved from one place to another. The interface contains the method <code>void move(int dx, int dy)</code>. The parameter <code>dx</code> tells us how much the object moves on the x axis and <code>dy</code> tells us about the movement on the y axis.</p>

<p>Implement the classes <code>Organism</code> and <code>Group</code>, which are both movable. Implement all the functionality inside the package <code>movable</code>.</p>

<h4>Implementing Organism</h4>

<p>Create the class <code>Organism</code> in the package <code>movable</code>; let Organism implement the interface <code>Movable</code>. Organisms have to know their own position (x and y coordinates). The API of <code>Organism</code> has to be the following:</p>

  <ul>
    <li>the constructor <strong>public Organism(int x, int y)</strong><br/>; it receives the x and y initial coordinates of the object</li>
    <li><strong>public String toString()</strong><br/>; it creates and returns a string which represents the object. The form should be the following <code>"x: 3; y: 6"</code>. Note that the coordinates are separated by a semicolon (<code>;</code>)</li>
    <li><strong>public void move(int dx, int dy)</strong><br/>; it moves the object as much as it is specified by the arguments. The variable <code>dx</code> contains the x coordinate of the movement, whereas <code>dy</code> contains the y coordinate of the movement. For instance, if the value of the variable <code>dx</code> is 5, the object variable <code>x</code> has to be increased by five</li>
  </ul>

<p>Try our the functionality of <code>Organism</code> using the following code.</p>

<pre class="sh_java">
     Organism organism = new Organism(20, 30);
     System.out.println(organism);
     organism.move(-10, 5);
     System.out.println(organism);
     organism.move(50, 20);
     System.out.println(organism);
</pre>

<pre>
x: 20; y: 30
x: 10; y: 35
x: 60; y: 55
</pre>

<h4>Implementing Group</h4>

<p>Create the class <code>Group</code> in the package <code>movable</code>; Group implements the interface <code>Movable</code>. The Group is made of various different objects which implement the interface <code>Movable</code>, and they have to be stored into a list construction, for instance.</p>

<p>The class <code>Group</code> should have the following API.</p>

  <ul>
    <li><strong>public String toString()</strong><br/>; it returns a string which describes the position of the group organisms, each organism is printed in its own line.</li>
    <li><strong>public void addToGroup(Movable movable)</strong><br/>; it adds a new objects which implements the interface <code>Movable</code> to the group.</li>
    <li><strong>public void move(int dx, int dy)</strong><br/>; it moves a group as much as it is defined by the arguments. Note that you will have to move each group organism.</li>
  </ul>

<p>Try out your program functionality with the following code.</p>

<pre class="sh_java">
    Group group = new Group();
    group.addToGroup(new Organism(73, 56));
    group.addToGroup(new Organism(57, 66));
    group.addToGroup(new Organism(46, 52));
    group.addToGroup(new Organism(19, 107));
    System.out.println(group);
</pre>

<pre>
x: 73; y: 56
x: 57; y: 66
x: 46; y: 52
x: 19; y: 107
</pre>
</div>
</div>

<h2>Inheritance of Class Features</h2>

    <p>Classes are for the programmer a way to clarify problematic concepts. With each class we create, we add new functionality to the programming language. The functionality is needed to solve the problems we meet, and the solutions are born from the interaction among the objects we create. In object programming, an object is an independent unity which can change through its methods. Objects are used together with each other; each object has its own area of responsibility. For instance, our user interface classes have been making use of <code>Scanner</code> objects, so far.</p>

    <p>Each Java's class descends from the class <code>Object</code>, which means that each class we create has all methods which are defined in <code>Object</code>. If we want to change the functionality of the methods defined in <code>Object</code>, we have to <code>Override</code> them and define a new functionality in the created class.</p>

<p>In addition to be possible to inherit the <code>Object</code> class, it is also possible to inherit other classes. If we check Java's <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html" target="_blank">ArrayList</a></code> class API we notice that <code>ArrayList</code> inherits the class <code>AbstractList</code>. The class <code>AbstractList</code> inherits the class <code>AbstractCollection</code>, which descended from the class <code>Object</code>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">java.lang.Object</a>
  <img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/util/AbstractCollection.html" target="_blank">java.util.AbstractCollection</a>&lt;E&gt;
      <img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/AbstractList.html" target="_blank">java.util.AbstractList</a>&lt;E&gt;
          <img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/perinta.gif" /><strong>java.util.ArrayList&lt;E&gt;</strong>
</pre>

        <p>Each class can inherit one class, directly, Indirectly, a class can still inherit all the feauters its parent class. The class <code>ArrayList</code> inherits directly the class <code>AbstractList</code>, and indirectly the classes <code>AbstractCollection</code> and <code>Object</code>. In fact, the class <code>ArrayList</code> has the methods <em>and</em> interfaces of <code>AbstractList</code>, <code>AbstractCollection</code> and <code>Object</code> at its disposal.</p>

        <p>The class features are inherited using the keyword <code>extends</code>. The class which inherits is called <em>subclass</em>; the class which is inherited is called <em>superclass</em>. Let's get aquainted with a carmaker system, which handles car components. The basic component of component handling is the class <code>Component</code> which defines the identification number, the producer, and the description.</p>

<pre class="sh_java">
public class Component {

    private String id;
    private String producer;
    private String description;

    public Component(String id, String producer, String description) {
        this.id = id;
        this.producer = producer;
        this.description = description;
    }

    public String getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getProducer() {
        return producer;
    }
}
</pre>

        <p>One car component is its motor. As for all the other components, the motor has also got a producer, an identification number, and a description. In addition, a motor has also got a type: for instance, combustion engine, electric motor, or hybrid. Let's create the class <code>Motor</code> which inherits <code>Component</code>: a motor is a particular case of component.</p>

<pre class="sh_java">
public class Motor extends Component {

    private String motorType;

    public Motor(String motorType, String id, String producer, String description) {
        super(id, producer, description);
        this.motorType = motorType;
    }

    public String getMotorType() {
        return motorType;
    }
}
</pre>

        <p>The class definition <code>public class Motor extends Component</code> tells us that the class <code>Motor</code> inherits the functionality of <code>Component</code>. In the class <code>Motor</code>, we define the object variable <code>motorType</code>.</p>

        <p>The Motor class constructor is interesting. In the first line of the constructor we notice the keyword <code>super</code>, which is used to call the superclass constructor. The call <code>super(id,producer,description)</code> class the constructor <code>public Component(String id, String producer, String description)</code> which is defined in the class <code>Component</code>; in this way the superclass object variables are assigned a value. After doing this, we assign a value to the object variable <code>motorType</code>.</p>

        <p>When the class <code>Motor</code> inherits the class <code>Component</code>, in receives all the methods provides by <code>Component</code>. It is possible to create an instance of the class <code>Motor</code> as it is for any other class.</p>

<pre class="sh_java">
        Motor motor = new Motor("combustion engine", "hz", "volkswagen", "VW GOLF 1L 86-91");
        System.out.println(motor.getMotorType());
        System.out.println(motor.getProducer());
</pre>

<pre>
combustion engine
volkswagen
</pre>

        <p>As you notice, the class <code>Motor</code> has the methods defined in <code>Component</code> at its disposal.</p>

        <h3>Private, Protected and Public</h3>

<p>If a method or a variable have got the <code>private</code> field accessibility, it can not be seen by its subclasses, and its subclasses do not have any straight way to access it. In the previous example Motor can't access directly the attributes defined in its superclass Component (id, producer, description). The subclass see naturally everything which has been defined <code>public</code> in its super class. If we want to define superclass variables or methods whose accessibility should be restricted to only its subclasses, we can use the <code>protected</code> field accessability</code>.</p>

        <h3>Superclass</h3>

        <p>The superclass constructor is defined by the <code>super</code> keyword. In fact, the call <code>super</code> is similar to the <code>this</code> constructor call. The call is given the values of the type required by the super class constructor parameter.</p>

        <p>When we call the constructor, the variables defined in the super class are initialized. In fact, with constructor call happens the same thing as in normal constructor calls. Unless the superclass has a constructor without parameter, in the subclass constructor call there must always be a call for its superclass constructor.</p>

        <p>Attention! The <code>super</code> call must always be in the first line!</p>

<h3>Calling the Superclass Methods</h3>

        <p>The method defined in the superclass can always be called using the <code>super</code> prefix, in the same way we call the methods defined in this class through the <code>this</code> prefix. For instance, we can make use of a method which overrives the superclass <code>toString</code> method in the following way:</p>

<pre class="sh_java">
    @Override
    public String toString() {
        return super.toString() + "\n  And my personal message again!";
    }
</pre>

<div class="tehtavat">
    <div class="tehtava">
  <h3>Person and their Heirs</h3>

  <h4 class="req">Person</h4>

  <p>Create the package <code>people</code> and the class <code>Person</code> in it; Person works in relation to the following main program:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Person pekka = new Person("Pekka Mikkola", "Korsontie Street 1 03100 Vantaa");
        Person esko = new Person("Esko Ukkonen", "Mannerheimintie Street 15 00100 Helsinki");
        System.out.println(pekka);
        System.out.println(esko);
    }
</pre>

  <p>Printing</p>

<pre>
Pekka Mikkola
  Korsontie Street 1 03100 Vantaa
Esko Ukkonen
  Mannerheimintie Street 15 00100 Helsinki
</pre>

<h4 class="req">Student</h4>

  <p>Create the class <code>Student</code> which <i>inherits</i> the class <code>Person</code>.

  <p>Students have 0 credits, at the beginning. As long as a student studies, their credits grow. Create the class, in relation to the following main program:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Student olli = new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki");
        System.out.println(olli);
        System.out.println("credits " + olli.credits());
        olli.study();
        System.out.println("credits "+ olli.credits());
    }
</pre>

  <p>Prints:</p>

<pre>
Olli
  Ida Albergintie Street 1 00400 Helsinki
credits 0
credits 1
</pre>

<h4 class="req">toString for Studets</h4>

  <p>The <code>Student</code> in the previous exercise inherits their toString method from the class <code>Person</code>. Inherited methods can also be overwritten, that is to say replaced with another version. Create now an own version of the toString method for <code>Student</code>; the method has to work as shown below:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Student olli = new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki");
        System.out.println( olli );
        olli.study();
        System.out.println( olli );
    }
</pre>

  <p>Prints:</p>

<pre>
Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 0
Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 1
</pre>

  <h4 class="req">Teacher</h4>

  <p>Create the class <code>Teacher</code> in the same package. Teacher inherits <code>Person</code>, but they also have a salary, which together with the teacher information in String form.</p>

  <p>Check whether the following main program generates the prinout below</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Teacher pekka = new Teacher("Pekka Mikkola", "Korsontie Street 1 03100 Vantaa", 1200);
        Teacher esko = new Teacher("Esko Ukkonen", "Mannerheimintie 15 Street 00100 Helsinki", 5400);
        System.out.println( pekka );
        System.out.println( esko );

        Student olli = new Student("Olli", "Ida Albergintie 1 Street 00400 Helsinki");
        for ( int i=0; i &lt; 25; i++ ) {
            olli.study();
        }
        System.out.println( olli );
    }
</pre>

  <p>Printing</p>

<pre>
Pekka Mikkola
  Korsontie Street 1 03100 Vantaa
  salary 1200 euros/month
Esko Ukkonen
  Mannerheimintie Street 15 00100 Helsinki
  salary 5400 euros/month
Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 25
</pre>

<h4 class="req">Everyone in a List</h4>

  <p>Implement the method <code>public static void printDepartment(List&lt;Person&gt; people)</code> in the <code>Main</code> class, default package. The method prints all the people in the parameter list. When the <code>main</code> method is called, printDepartment should work in the following way.</p>

<pre class="sh_java">
    public static void printDepartment(List&lt;Person&gt; people) {
       // we print all the people in the department
    }

    public static void main(String[] args) {
        List&lt;Person&gt; people = new ArrayList&lt;Person&gt;();
        people.add( new Teacher("Pekka Mikkola", "Korsontie Street 1 03100 Vantaa", 1200) );
        people.add( new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki") );

        printDepartment(people);
    }
</pre>

<pre>
Pekka Mikkola
  Korsontie Street 1 03100 Vantaa
  salary 1200 euros/month
Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 0
</pre>

</div>
</div>

   <h3>The Object Type defines the Called Method: Polymorphism</h3>
<!-- WTF -->
    <p>The method which can be called is defined through the variable type. For instance, if a <code>Student</code> object reference is saved into a <code>Person</code> variable, the object can use only the methods defined in the <code>Person</code> class:</p>

<pre class="sh_java">
   Person olli = new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki");
   olli.credits();        // NOT WORKING!
   olli.study();              // NOT WORKING!
   String.out.println( olli );   // olli.toString() IT WORKS!
</pre>

<p>If the object has many different types, it has available the methods defined by <em>all</em> types. For instance, a <code>Student</code> object has available the methods defined both in the class <code>Person</code> and in <code>Object</code>.</p>

<p>In the previous exercise, we were in the class <code>Student</code> and we replaced the <code>toString</code> method inherited from <code>Person</code> with a new version of it. Suppose we are using an object throw a type which is not its real, what version of the object method would we call, then? For instance, below there are two students whose references are saved into a Person and an Object variables. We call the <code>toString</code> method of both. What version of the method is executed: the one defined in Object, in Person, or in Student?</p>

<pre class="sh_java">
   Person olli = new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki");
   String.out.println( olli );

   Object liisa = new Student("Liisa", "VÃ¤inÃ¶ Auerin Street 20 00500 Helsinki");
   String.out.println( liisa );
</pre>

<p>Printing:</p>

<pre>
Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 0
Liisa
  VÃ¤inÃ¶ Auerin Street 20 00500 Helsinki
  credits 0
</pre>

<p>As you see, the execution method is chosen based on its real type, that is the type of the variable which saved the reference!</p>

    <p>More generally: <b>The execution method is always chosen based on the object real type, regardless of the variable type which is used. Objects are diverse, which means they can be used through different variable types. The execution method does always depend of the object actual type.</b> This diversity is called polymorphysm.</p>

<h3>Another Example: Points</h3>

<p>A point laying in a bidimensional coordinate system can be represented with the help of the following class:</p>

<pre class="sh_java">
public class Point {

    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int manhattanDistanceFromOrigin(){
        return Math.abs(x)+Math.abs(y);
    }

    protected String location(){
        return x + ", " + y;
    }

    @Override
    public String toString() {
        return "("+this.location()+") distance "+this.manhattanDistanceFromOrigin();
    }
}
</pre>

<p>The <code>location</code> method is not supposed to be used outside its class, and its accessability field is protected, which means only subclasses can access it. For instance, if we use a <a href="http://wiki.gamegardens.com/Path_Finding_Tutorial">path fiding algorithm</a>, the <a href="http://en.wiktionary.org/wiki/Manhattan_distance">Manhattan distance</a> is the distance of two points moving on a strictly horizontal and/or vertical path, along the coordinate system lines.</p>

<p>A coloured point is similar to a point, except that it contains a string which tells us its colour. The class can be created by inheriting Point:</p>

<pre class="sh_java">
public class ColouredPoint extends Point {

    private String colour;

    public ColouredPoint(int x, int y, String colour) {
        super(x, y);
        this.colour = colour;
    }

    @Override
    public String toString() {
        return super.toString()+" colour: "+colour;
    }
}
</pre>

<p>The class defines an object variable which saves the colour. The coordinates are saved in the superclass. The string representation must be similar to the one of the point, but it also has to show the colour. The overwritten <code>toString</code> method, calls the superclass toString method, and it adds the point colour to it.</p>

<p>In the following example, we create a list which contains various different points, either normal or coloured. Thanks to polymorphysm, we call the actual toString method of all objects, even though the list knows them as if they were all <code>Point</code>-type:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        List<Point> points = new ArrayList<Point>();
        points.add(new Point(4, 8));
        points.add(new ColouredPoint(1, 1, "green"));
        points.add(new ColouredPoint(2, 5, "blue"));
        points.add(new Point(0, 0));

        for (Point point : points) {
            System.out.println(point);
        }
    }
}
</pre>

<p>Printing:</p>

<pre>
(4, 8) distance 12
(1, 1) distance 2 colour: green
(2, 5) distance 7 colour: blue
(0, 0) distance 0
</pre>

<p>We also want a 3D point in our program. Because that is not a coloured point, it shall inherit Point:</p>

<pre class="sh_java">
public class 3DPoint extends Point {

    private int z;

    public 3DPoint(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String location() {
        return super.location() + ", " + z;    // printing as "x, y, z"
    }

    @Override
    public int manhattanDistanceFromOrigin() {
        // first, we ask the superclass for the distance of x+y
        // and then we add the value of z to it
        return super.manhattanDistanceFromOrigin() + Math.abs(z);
    }

    @Override
    public String toString() {
        return "(" + this.location() + ") distance " + this.manhattanDistanceFromOrigin();
    }
}
</pre>

<p>A 3D point defines an object variable corresponding to the third coordinate, and it overrides the methods <code>location</code>, <code>manhattanDistanceFromOrigin</code> and <code>toString</code> so that they would take into account the tridimensionality. We can now extend the previous example and add 3D points to our list:</p>

<pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        List<Piste> points = new ArrayList<Piste>();
        points.add(new Point(4, 8));
        points.add(new ColouredPoint(1, 1, "green"));
        points.add(new Point(2, 5, "blue"));
        points.add(new 3DPoint(5, 2, 8));
        points.add(new Point(0, 0));

        for (Point point : points) {
            System.out.println(point);
        }
    }
}
</pre>

<p>The output meets our expectations</p>

<pre>
(4, 8) distance 12
(1, 1) distance 2 colour: green
(2, 5) distance 7 colour: blue
(5, 2, 8) distance 15
(0, 0) distance 0
</pre>

<p>We notice that the tridimensional point <code>toString</code> method is exactly the same as the point's toString. Could we leave the toString method untouched? Of course! A tridimensional point can be reduced to the following:</p>

<pre class="sh_java">
public class 3DPoint extends Point {

    private int z;

    public 3DPoint(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String distance() {
        return super.distance()+", "+z;
    }

    @Override
    public int manhattanDistanceFromOrigin() {
        return super.manhattanDistanceFromOrigin()+Math.abs(z);
    }
}
</pre>

<p>What does exactly happen when we call a tridimensional point's toString method? The execution proceeds in the following way:</p>
<ol>
<li>we look for a toString method in the class 3DPoint; this is not found and we move to its parent class</li>
<li>we look for a toString method in the superclass Point; the method is found and we execute its code</li>
<ul>
<li>the code to execute is <code>return "("+this.location()+") location "+this.manhattanDistanceFromOrigin();</code></li>
<li>first, we execute the method location</li>
<li>we look for a location method in the class 3DPoint; the method is found and we executes its code
</li>
<li>the location method calculates its result by calling the superclass method location</li>
<li>next, we look for the definition of the method manhattanDistanceFromOrigin in the class Point3D; the method is found and we execute its code</li>
<li>once again, the method calculates its result by calling its homonym in the superclass</li>
</ul>
</ol>

<p>The operating sequence produced by the method call has many steps. The idea is clear, anyway: when we want to execute a method, we first look for its definition in the object real type, and if it is not found, we move to the super class. If the method is not found in the parent class either, we move to the parent parent class, and so on...</p>

          <h3>When Do We Have to Use Inheritance?</h3>

          <p>Inheritance is a tool to build and qualify object hierarchy; a subclass is always a special instance of the superclass. If the class we want to create is a special instance of an already existent class, we can create it by inheriting the class which already exists. For instance in our auto components example, motor <em>is</em> a component, but the motor has additional functionality which not all the classe
          s have.</p>

          <p>Through inheritance, a subclass receives the superclass functionality. If a subclass does not need or use the inherited functionality, inheritance is not motivated. The inherited classes inherit the upperclass methods and interfaces, and therefore we can use a subclass for any purpose the superclass was used. It is good to stick to low inheritance hierarchy, because the more complex the inheritance hierarchy is, the more complex maintainance and further development will be. In general, if the hierarchy is higher than two or three, the program structure is usually to improve.</p>

          <p>It is good to think about inheritance use. For instance, if <code>Car</code> inherited classes like <code>Component</code> or <code>Motor</code>, that would be wrong. A car <em>contains</em> a motor and components, but a car is not a motor or a component. More generally, we can think that if an object owns or is composed of the other objects, inheritance is wrong.</p>

          <p>Devoloping hierachy, you have to make sure the Single Responsibility Principle applies. There must be only one reason to change a  class. If you notice that the hierarchy increases a class responsibilities, that class must be divided into various different classes.</p>

          <h4>An Example of Inheritance Misuse</h4>

          <p>Let's think about the <code>Customer</code> class, in relation to post service. The class contains the customer personal information, and <code>Order</code>, which inherits the customer personal information and contains the information of the object to order. The class <code>Order</code> has also got the method <code>mailingAddress</code>, which tells the mailing address of the order.</p>

<pre class="sh_java">
public class Customer {

    private String name;
    private String address;

    public Customer(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
</pre>

<pre class="sh_java">
public class Order extends Customer {

    private String product;
    private String amount;

    public Order(String product, String amount, String name, String address) {
        super(name, address);
        this.product = product;
        this.amount = amount;
    }

    public String getProduct() {
        return product;
    }

    public String getAmount() {
        return amount;
    }

    public String mailingAddress() {
        return this.getName() + "\n" + this.getAddress();
    }
}
</pre>

  <p>The inheritance above is used erroneously. When a class inherits another, the subclass has to be a special instance of the superclass; order is not a special instance of customer. The misuse becomes apparent by breaking the single responsibility principle: the class <code>Order</code> is responsible for both the customer and the order information maintenance.</p>

  <p>The problem with the previous solution becomes apparent when we think of what would happen if a customer changes their own address.</p>

  <p>With a change of address, we would have to change <em>each</em> Order object of the customer, which is a hint about a bad situation. A better solution would be encapsulating <code>Customer</code> as an object variable of <code>Order</code>. If we think more specifically about the order semantics this becomes clear. <em>An order has a customer</em>. Let's change the class <code>Order</code> so that it contains a reference to <code>Customer</code>.</p>

<pre class="sh_java">
public class Order {

    private Customer customer;
    private String product;
    private String amount;

    public Tilaus(Customer customer, String product, String amount) {
        this.customer = customer;
        this.product = product;
        this.amount = amount;
    }

    public String getProduct() {
        return product;
    }

    public String getAmount() {
        return amount;
    }

    public String mailingAddress() {
        return this.customer.getName() + "\n" + this.customer.getAddress();
    }
}
</pre>

    <p>The <code>Order</code> class above is better now. The method <code>mailingAddress</code> uses a <em>Customer</em> reference to retrieve the mailing address, instead of inheriting the class <code>Customer</code>. This makes easier both the maintanance and the concrete functionality of our program.</p>

    <p>Now, when we modify a customer, we only need to change their information; we don't have to do anything about the orders.</p>

<div class="tehtavat">
<div class="tehtava">
<h3>Container</h3>

<p>Together with the exercise, you find the class <code>Container</code>, with the following constructor and methods:</p>

<ul>

<li><b>public Container(double capacity)</b><br/>
     It creates an empty container, whose capacity is given as argument;
     an improper capacity (&lt;=0) creates a useless container,
     whose capacity is 0.</li>

<li><b>public double getVolume()</b><br/>
     It returns the volume of product in the container.</li>


<li><b>public double getOriginalCapacity()</b><br/>
     It returns the original capacity of the container, that is to say what the constructor was originally given.</li>

<li><b>public double getCurrentCapacity()</b><br/>
     It returns the actual capacity of the container.</li>

<li><b>public void addToTheContainer(double amount)</b><br/>
     It adds the specified amount of things to the container. If the amount is negative, nothing changes;
     if a part of that amount fits but not the whole of it, the container is filled up
     and the left over is thrown away.</li>

<li><b>public double takeFromTheContainer(double amount)</b><br/>
    We take the specified amount form the container, the method returns what we <b>receive</b>.
    If the specified amount is negative, nothing happens and zero is returned.
    If we ask for more than what there is in the container, the method returns all the contents.</li>

<li><b>public String toString()</b><br/>
    It returns the state of an object in String form like <tt>volume = 64.5, free space 123.5</tt></li>
</ul>

        <p>In this exercise, we create various different containers out of our <code>Container</code> class. Attention! Create all the classes in the package <code>containers</code>.</p>

        <h4 class="req">Product Container, Phase 1</h4>

        <p>The class <code>Container</code> has control on the operations regarding the amount of a product. Now, we also want that products have their name and handling equipment. <i><b>Program ProductContainer, a subclass of Container!</b></i> Let's first implement a single object variable for the name of the contained product, a constructor and a getter for the name:</p>


<ul>
<li><b>public ProductContainer(String productName, double capacity)</b><br/>
     It creates an empty product container. The product name and the container capacity are given as parameters.</li>


<li><b>public String getName()</b><br/>
     It returns the product name.</li>
</ul>


        <p><i>Remember in what way the constructor can make use of its upper class constructor in its first line!</i></p>

        <p>Example:</p>

<pre class="sh_java">
        ProductContainer juice = new ProductContainer("Juice", 1000.0);
        juice.addToTheContainer(1000.0);
        juice.takeFromTheContainer(11.3);
        System.out.println(juice.getName()); // Juice
        System.out.println(juice);           // volume = 988.7, free space 11.3
</pre>

<pre>
Juice
volume = 988.7, free space 11.3
</pre>


<h4 class="req">Product Container, Phase 2</h4>


<p>As you see from the example above, the <code>toString()</code> method inherited by ProductContainer does not know anything about the product name (of course!). <i>Something must be done for it!</i> Let's also add a setter for the product name, at the same time:</p>

<ul>
<li><b>public void setName(String newName)</b> sets a new name to the product.</li>

<li><b>public String toString()</b> returns the object state in String form, like <tt>Juice: volume = 64.5, free space 123.5</tt></li>
</ul>

        <p>The new <code>toString()</code> method could be programmed using the getter inherited from the superclass, retrieving the values of inherited but hidden values field values. However, we have programmed the superclass in a way that it is already able to produce the container situation in String form: why should we bother to program this again? Make use of the inherited <code>toString</code>.</p>

        <p><i>Remember that an overwritten method can still be called in its subclass, where we overwrite it!</i></p>

        <p>Use demonstration:</p>

<pre class="sh_java">
        ProductContainer juice = new ProductContainer("Juice", 1000.0);
        juice.addToTheContainer(1000.0);
        juice.takeFromTheContainer(11.3);
        System.out.println(juice.getName()); // Juice
        juice.addToTheContainer(1.0);
        System.out.println(juice);           // Juice: volume = 989.7, space 10.299999999999955
</pre>

<pre>
Juice
Juice: volume = 989.7, free space 10.299999999999955
</pre>


<h4>Container History</h4>

        <p>Sometimes, it can be interesting to know in what way the container situation has changed: is the container often rather empty or full, is the fluctuation considerable or not, and so on. Let's provide our <code>ProductContainer</code> class with the ability to record the container history.</p>

        <p>Let's start by designing a useful tool.</p>

        <p>We could directly implement an <code>ArrayList&lt;Double&gt;</code> object to track our container history in the class <i>ProductConteiner</i>; however, now we create a <i>specific tool</i> for this purpose. The tool has to encapsulate an <code>ArrayList&lt;Double&gt;</code> object.</p>

        <p><code>ContainerHistory</code> public constructor and methods:</p>

<ul>
<li><b>public ContainerHistory()</b> creates an empty <code>ContainerHistory</code> object.</li>

<li><b>public void add(double situation)</b> adds the parameter situation to the end of the container history. </li>

<li><b>public void reset()</b> it deletes the container history records.</li>

<li><b>public String toString()</b> returns the container history in the form of a String. <i>The String form given by the ArrayList class is fine and doesn't have to be modified.</i> </li>

</ul>


<h4 class="req">ContainerHistory.java, Phase 2</h4>

<p>Implement analysis methods for your <code>ContainerHistory</code> class:</p>

<ul>

<li><b>public double maxValue()</b> reutrns the greatest value in the container history. If the history is empty, the method returns 0.</li>


<li><b>public double minValue()</b> reutrns the smallest value in the container history. If the history is empty, the method returns 0.</li>

<li><b>public double average()</b> reutrns the average of the values in the container history. If the history is empty, the method returns 0.</li>

</ul>

<h4>ContainerHistory.java, Phase 3</h4>

<p>Implement analysis methods for your <code>ContainerHistory</code> class:</p>

<ul>
<li><b>public double greatestFluctuation()</b> returns the absolute value of the single greatest fluctuation in the container history (attention: a fluctuation of -5 is greater than 4). If the history is empty or it contains one value, the method returns zero. Absolute value is the distance of a number from zero. For instance the absolute value of -5.5 is 5.5, and the absolute value of 3.2 is 3.2.</li>

<li><b>public double variance()</b> returns the sample variance of the container history values. If the history is empty or it contains only one value, the method returns zero.</li>
</ul>

<p>You find guidelines to calculate the variance in <a href="http://en.wikipedia.org/wiki/Variance#Population_variance_and_sample_variance">Wikipedia</a>, in the population and sample variance section. For instance, the average of the numbers 3, 2, 7, and 2 is 3.5, and their sample variance is therefore ((3 - 3.5)Â² + (2 - 3.5)Â² + (7 - 3.5)Â² + (2 - 3.5)Â²)/(4 - 1) Ë 5,666667.)</p>




<h4 class="req">Product Container Recorder, Phase 1</h4>

<p>Implement the class <code>ProductContainerRecorder</code> which inherits <code>ProductContainer</code>. In addition to the old methods, the new version provides services for the container history. The hisotry is handled with a  <code>ContainerHistory</code> object.
</p>

<p>The public constructor and methods:</p>

<ul>

<li><b>public ProductContainerRecorder(String productName, double capacity, double initialVolume)</b>
     creates a product container. The product name, capacity, and original volume are given as parameter.
     <i>Record the original volume both as the stored product original volume and as the first value of the container history.</i>

<li><b>public String history()</b> returns the container history in the following form:
       <tt>[0.0, 119.2, 21.2]</tt>.  <i>Use the String printout form as it is.</i>

</ul>
<p>
<b>Attention:</b> now we remember only the original volume.
</p>

<p>
Example:
</p>

<pre class="sh_java">
// the well known way:
ProductContainerRecorder juice = new ProductContainerRecorder("Juice", 1000.0, 1000.0);
juice.takeFromTheContainer(11.3);
System.out.println(juice.getName()); // Juice
juice.addToTheContainer(1.0);
System.out.println(juice);           // Juice: volume = 989.7, free space 10.3
...
<b>// history() does not work properly, yet:</b>
System.out.println(juice.history()); // [1000.0]
   // in fact, we only retrieve the original value which was given to the constructor...
...
</pre>


<p>
Printing:
</p>
<pre>
Juice
Juice: volume = 989.7, free space 10.299999999999955
[1000.0]
</pre>

<h4 class="req">Product Container Recorder, Phase 2</h4>

<p>
<i>It's time to pick up history!</i> The first version of our history knew only the original value. Implement the following methods:
</p>
<ul>

<li><b>public void addToTheContainer(double amount)</b>;

    this works like the method in <i>Container</i>, but the new situation is recorded in the history.
<b>Attention: </b> you have to record the product volume in the container after the addition, not the amount which was added!
</li>



<li><b>public double takeFromTheContainer(double amount)</b>; it works like the method in <code>Container</code>, but the new situation is recorded in the history. <b>Attention: </b> you have to record the product volume in the container after the operation, not the amount which was removed!</li>

</ul>

<p>
Use example:
</p>

<pre class="sh_java">
// the well known way:
ProductContainerRecorder juice = new ProductContainerRecorder("Juice", 1000.0, 1000.0);
juice.takeFromTheContainer(11.3);
System.out.println(juice.getName()); // Juice
juice.addToTheContainer(1.0);
System.out.println(juice);           // Juice: volume = 989.7, free space 10.3
...
// but now we have our history record
System.out.println(juice.history()); // [1000.0, 988.7, 989.7]
...
</pre>
<p>
Printing:
</p>
<pre>
Juice
Juice: volume = 989.7, free space 10.299999999999955
[1000.0, 988.7, 989.7]
</pre>
<p>

<p>
<i>Remember how an overwritten method can be used inside the method that overwrites it!</i>
</p>


<h4 class="req">Product Container Recorder, Phase 3</h4>
<p>
Implement the following method:
</p>
<ul>

<li><b>public void printAnalysis()</b>, which prints the history information regarding the product, following the exercise below:</li>
</ul>

<p>
Use example:
</p>
<pre class="sh_java">
ProductContainerRecorder juice = new ProductContainerRecorder("Juice", 1000.0, 1000.0);
juice.takeFromTheContainer(11.3);
juice.addToTheContainer(1.0);
//System.out.println(juice.history()); // [1000.0, 988.7, 989.7]

juice.printAnalysis();
</pre>
<p>
The method <i>printAnalysis</i> prints:
</p>

<pre>
Product: Juice
History: [1000.0, 988.7, 989.7]
Greatest product amount: 1000.0
Smallest product amount: 988.7
Average: 992.8
Greatest change: 11.299999999999955
Variance: 39.129999999999676
</pre>
<p>

<h4>Product Container Recorder, Phase 4</h4>
<p>
Fill the analysis so that it prints the greatest fluctuation and the history variance.
</p>

</div>
</div>


<h3>Inheritance, Interfaces, Both, or None?</h3>

<p>Inheritance does not exclude using interfaces, and viceversa. Interfaces are like an agreement on the class implementation, and they allow for the abstraction of the concrete implementation. Changing a class which implements an interface is quite easy.</p>

        <p>As with interfaces, when we make use of inheritance, the subclasses are committed to provide all the superclass methods. Because of polymorphism, inheritance works as interfaces do. We can assign a subclass instance to a method which receives its superclass as parameter.</p>

        <p>Below, we create a farm simulator, where we simulate the life in a farm. Note that the program does not make us of inheritance, and the interface use is scarce. With programs, we often create a first version which we improve later on. Typically, we don't already understand the scope of the problem when we implement the first version; planning interfaces and inheritance hierarchy may be difficult and it may slow down the work.</p>


<div class="tehtavat">
    <div class="tehtava">
<h3>Farm Simulator</h3>

<p>Dairy farms have got milking animals; they do not handle milk themselves, but milk trucks transport it to dairy factories which process it into a variety of milk products. Each dairy factory is specialised in one product type; for instance, a cheese factory produces cheese, a butter factory produces butter, and a milk factory produces milk.
<p>

<p>Let's create a simulator which represents the milk course of life. Implement all the classes in the package <code>farmsimulator</code>.
<p>


<h4>Bulk Tank</h4>

<p>Milk has to be stored in bulk tanks in good conditions. Bulk tanks are produced both with a standard capacity of 2000 litres, and with customer specific capacity. Create the class BulkTank, with the following constructors and methods.
</p>

  <ul>
    <li><strong>public BulkTank()</strong></li>
    <li><strong>public BulkTank(double capacity)</strong></li>
    <li><strong>public double getCapacity()</strong></li>
    <li><strong>public double getVolume()</strong></li>
    <li><strong>public double howMuchFreeSpace()</strong></li>
    <li><strong>public void addToTank(double amount)</strong> adds to the tank only as much milk as it fits; the additional milk will not be added, and you don't have to worry about a situation where the milk spills over</li>
    <li><strong>public double getFromTank(double amount)</strong>
      takes the required amount from the tank, or as much as there is left
    </li>
  </ul>

<p>Also, implement the <code>toString</code> method for your <code>BulkTank</code>. The <code>toString</code> method describes the tank situation by rounding down the litres using the <code>ceil()</code> method of class <code>Math</code>.
</p>

<p>Test your bulk tank with the following program chunk:</p>

<pre class="sh_java">
        BulkTank tank = new BulkTank();
        tank.getFromTank(100);
        tank.addToTank(25);
        tank.getFromTank(5);
        System.out.println(tank);

        tank = new BulkTank(50);
        tank.addToTank(100);
        System.out.println(tank);
</pre>


<p>The program print output should look like the following:</p>

<pre>
20.0/2000.0
50.0/50.0
</pre>

<p>Note that when you call the <code>println()</code> method of the <code>out</code> object of class <code>System</code>, the method receives as paramater an <code>Object</code> variable; in such case, the print output is determined by the overwritten <code>toString()</code> method in <code>BulkTank</code>! We are in front of a case of polymorphism, because the method can work with different types.
</p>

<h4>Cow</h4>

<p>If we want to produce milk, we also need cows. Cows have got names and udders. Udder capacity is a random value between 15 and 40; the class <code>Random</code> can be used to raffle off the numers, for instance, <code>int num = 15 + new Random().nextInt(26);</code>. The class <code>Cow</code> has the following functionality:</p>

  <ul>
    <li><strong>public Cow()</strong> creates a new cow with a random name</li>
    <li><strong>public Cow(String name)</strong> creates a new cow with its given name</li>
    <li><strong>String getName()</strong> returns the cow's name</li>
    <li><strong>double getCapacity()</strong> returns the udder capacity</li>
    <li><strong>double getAmount()</strong> returns the amount on milk available in the cow's udders</li>
    <li><strong>String toString()</strong> returns a String which describes the cow (see the example below)</li>
  </ul>

<p><code>Cow</code> also implement the following interfaces: <code>Milkable</code>, which describes the cow's faculty for being milked, and <code>Alive</code>, which represents their faculty for being alive.</p>

<pre class="sh_java">
public interface Milkable {
    public double milk();
}

public interface Alive {
    public void liveHour();
}
</pre>

<p>When a cow is milked, all their milk provision is taken to be processed. As long as a cow lives, their milk provision increases slowly. In Finland, milking cows produce 25-30 litres of milk every day, on the average. We simulate this by producing 0.7-2 litres every hour.
</p>

<p>If a cow is not given a name, they are assigned a random one from the list below.
</p>

<pre class="sh_java">
    private static final String[] NAMES = new String[]{
        "Anu", "Arpa", "Essi", "Heluna", "Hely",
        "Hento", "Hilke", "Hilsu", "Hymy", "Ihq", "Ilme", "Ilo",
        "Jaana", "Jami", "Jatta", "Laku", "Liekki",
        "Mainikki", "Mella", "Mimmi", "Naatti",
        "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
        "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
</pre>

<p>Implement the class Cow, and test whether it works with the following program body.</p>

<pre class="sh_java">
        Cow cow = new Cow();
        System.out.println(cow);


        Alive livingCow = cow;
        livingCow.liveHour();
        livingCow.liveHour();
        livingCow.liveHour();
        livingCow.liveHour();

        System.out.println(cow);

        Milkable milkingCow = cow;
        milkingCow.milk();

        System.out.println(cow);
        System.out.println("");

        cow = new Cow("Ammu");
        System.out.println(cow);
        cow.liveHour();
        cow.liveHour();
        System.out.println(cow);
        cow.milk();
        System.out.println(cow);

</pre>

<p>The program print output can be like the following.</p>

</p>

<pre>
Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
</pre>


<h4>MilkingRobot</h4>
<p>In modern dairy farms, milking robots handle the milking. The milking robot has to be connected to the bulk tank in order to milk an udder:
</p>

  <ul>
    <li><strong>public MilkingRobot()</strong> creates a new milking robot</li>
    <li><strong>BulkTank getBulkTank()</strong> returns the connected bulk tank, or a <code>null</code> reference, if the tank hasn't been installed</li>
    <li><strong>void setBulkTank(BulkTank tank)</strong> installs the parameter bulk tank to the milking robot</li>
    <li><strong>void milk(Milkable milkable)</strong> milks the cow and fills the connected bulk tank; the method returns an <code>IllegalStateException</code> is no tank has been fixed </li>
  </ul>

<p>Implement the class MilkingRobot, and test it using the following program body. Make sure that the milking robot can milk all the objects which implement the interface Milkable!</p>

<pre class="sh_java">
        MilkingRobot milkingRobot = new MilkingRobot();
        Cow cow = new Cow();
        milkingRobot.milk(cow);
</pre>

<pre>
Exception in thread "main" java.lang.IllegalStateException: The MilkingRobot hasn't been installed
        at farmsimulator.MilkingRobot.milk(MilkingRobot.java:17)
        at farmsimulator.Main.main(Main.java:9)
Java Result: 1
</pre>

<pre class="sh_java">
        MilkingRobot milkingRobot = new MilkingRobot();
        Cow cow = new Cow();
        System.out.println("");

        BulkTank tank = new BulkTank();
        milkingRobot.setBulkTank(tank);
        System.out.println("Bulk tank: " + tank);

        for(int i = 0; i &lt; 2; i++) {
            System.out.println(cow);
            System.out.println("Living..");
            for(int j = 0; j &lt; 5; j++) {
                cow.liveHour();
            }
            System.out.println(cow);

            System.out.println("Milking...");
            milkingRobot.milk(cow);
            System.out.println("Bulk tank: " + tank);
            System.out.println("");
        }
</pre>

<p>The print output of the program can look like the following:</p>

<pre>
Bulk tank: 0.0/2000.0
Mella 0.0/23.0
Living..
Mella 6.2/23.0
Milking...
Bulk tank: 6.2/2000.0

Mella 0.0/23.0
Living..
Mella 7.8/23.0
Milking...
Bulk tank: 14.0/2000.0
</pre>

<h4>CowHouse</h4>

<p>Cows are kept (and in this case milked) in cowhouses. The original cowhouses have room for one milking robot. Note that when milking robots are installed, they are connected to a specific cowhouse bulk tank. If a cowhouse does not have a milking robot, it can't be used to handle the cow, either. Implement the class <code>CowHouse</code> with the following constructor and methods:
</p>

  <ul>
    <li><strong>public CowHouse(BulkTank tank)</strong></li>
    <li><strong>public BulkTank getBulkTank()</strong> returns the cowhouse bulk tank</li>
    <li><strong>public void installMilkingRobot(MilkingRobot milkingRobot)</strong> installs a milking robot and connects it to the cowhouse bulk tank</li>
    <li><strong>public void takeCareOf(Cow cow)</strong> milks the parameter cow with the help of the milking robot, the method throws an <code>IllegalStateException</code> if the milking robot hasn't been installed</li>
    <li><strong>public void takeCareOf(Collection&lt;Cow&gt; cows)</strong> milks the parameter cows with the help of the milking robot, the method throws an <code>IllegalStateException</code> if the milking robot hasn't been installed</li>
    <li><strong>public String toString()</strong> returns the state of the bulk tank contained by the cowhouse</li>
  </ul>

<p><code>Collection</code> is Java's own interface, and it represents collections' behaviour. For instance, the classes <code>ArrayList</code> and <code>LinkedList</code> implement the interface <code>Collection</code>. All instances of classes which implement <code>Collection</code> can be iterated with a for-each construction.</p>

<p>Test your class <code>CowHouse</code> with the help of the following program body. Do not pay to much attention to the class <code>LinkedList</code>; apparently, it works as <code>ArrayList</code>, but the implemantation in encapsulates is slightly different. More information about this in the data structures course!
</p>

<pre class="sh_java">
        CowHouse cowhouse = new CowHouse(new BulkTank());
        System.out.println("CowHouse: " + cowhouse);

        MilkingRobot robot = new MilkingRobot();
        cowhouse.installMilkingRobot(robot);

        Cow ammu = new Cow();
        ammu.liveHour();
        ammu.liveHour();

        cowhouse.takeCareOf(ammu);
        System.out.println("CowHouse: " + cowhouse);

        LinkedList&lt;Cow&gt; cowList = new LinkedList&lt;Cow&gt;();
        cowList.add(ammu);
        cowList.add(new Cow());

        for(Cow cow: cowList) {
            cow.liveHour();
            cow.liveHour();
        }

        cowhouse.takeCareOf(cowList);
        System.out.println("CowHouse: " + cowhouse);
</pre>

<p>
The print output should look like the following:
</p>

<pre>
CowHouse: 0.0/2000.0
CowHouse: 2.8/2000.0
CowHouse: 9.6/2000.0
</pre>

<h4>Farm</h4>

<p>Farms have got an owner, a cowhouse and a breed of cows. Farm also implements our old interface <code>Alive</code>: calling the method <code>liveHour</code> makes all the cows of the farm live for an hour.
   You also have to create method <code>manageCows</code> which calls Cowhouse's method <code>takeCareOf</code> so that all cows are milked. Implement your class Farm, and make it work according to the following example.
</p>

<pre class="sh_java">
        Farm farm = new Farm("Esko", new CowHouse(new BulkTank()));
        System.out.println(farm);

        System.out.println(farm.getOwner() + " is a tough guy!");
</pre>

<p>
Expected print output:
</p>

<pre>
Farm owner: Esko
CowHouse bulk tank: 0.0/2000.0
No cows.
Esko is a tough guy!
</pre>


<pre class="sh_java">
        Farm farm = new Farm("Esko", new CowHouse(new BulkTank()));
        farm.addCow(new Cow());
        farm.addCow(new Cow());
        farm.addCow(new Cow());
        System.out.println(farm);
</pre>


<p>
Expected print output:
</p>

<pre>
Farm owner: Esko
CowHouse bulk tank: 0.0/2000.0
Animals:
        Naatti 0.0/19.0
        Hilke 0.0/30.0
        Sylkki 0.0/29.0
</pre>

<pre class="sh_java">
        Farm farm = new Farm("Esko", new CowHouse(new BulkTank()));

        farm.addCow(new Cow());
        farm.addCow(new Cow());
        farm.addCow(new Cow());

        farm.liveHour();
        farm.liveHour();
</pre>

<p>
Expected print output:
</p>

<pre>
Farm owner: Esko
CowHouse bulk tank: 0.0/2000.0
Animals:
        Heluna 2.0/17.0
        Rima 3.0/32.0
        Ilo 3.0/25.0
</pre>

<pre class="sh_java">
        Farm farm = new Farm("Esko", new CowHouse(new BulkTank()));
        MilkingRobot robot = new MilkingRobot();
        farm.installMilkingRobot(robot);

        farm.addCow(new Cow());
        farm.addCow(new Cow());
        farm.addCow(new Cow());


        farm.liveHour();
        farm.liveHour();

        farm.manageCows();

        System.out.println(farm);
</pre>

<p>
Expected print output:
</p>

<pre>
Farm owner: Esko
CowHouse bulk tank: 18.0/2000.0
Animals:
        Hilke 0.0/30.0
        Sylkki 0.0/35.0
        Hento 0.0/34.0
</pre>
</div>
</div>


<h3>An Abstract Class</h3>

        <p>Abstract classes combine interfaces and inheritance. They do not produce instances, but you can create instances of their subclasses. An abstract class can contain both normal and abstract methods, the first containing the method body, the second having only the method definition. The implementation of the abstract methods is left to the inheriting class. In general, we use abstract classes when the object they represent is not a clear, self-defined concept. In such cases, it is not possible to create instances of it.</p>

        <p>Both when we define abstract classes and abstract methods, we use the keyword <code>abstract</code>. An abstract class is defined by the statement <code>public abstract class <em>ClassName</em></code>, whereas an abstract method is defined by <code>public abstract <em>returnType</em> <em>methodName</em></code>. Let's consider the following abstract class <code>Operation</code>, which provides a framework for operations, and their excecutions.</p>

<pre class="sh_java">
public abstract class Operation {

    private String name;

    public Operation(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    public abstract void execute(Scanner reader);
}
</pre>

        <p>The abstract class <code>Operation</code> works as a framework to excetute different operations. For instance, an addition can be implemented by inheriting the class <code>Operation</code> in the following way.</p>

<pre class="sh_java">
public class Addition extends Operation {

    public Addition() {
        super("Addition");
    }

    @Override
    public void execute(Scanner reader) {
        System.out.print("Give the first number: ");
        int first = Integer.parseInt(reader.nextLine());
        System.out.print("Give the second number: ");
        int second = Integer.parseInt(reader.nextLine());

        System.out.println("The sum is " + (first + second));
    }
}
</pre>

        <p>Because all classes which descend from <code>Operation</code> are also Operation-type, we can create a user interface based on <code>Operation</code>-type variables. The following class <code>UserInterface</code> contains a list of operations and a reader. The operations can be added dynamically in the user interface.</p>

<pre class="sh_java">
public class UserInterface {

    private Scanner reader;
    private List&lt;Operation&gt; operations;

    public UserInterface(Scanner reader) {
        this.reader = reader;
        this.operations = new ArrayList&lt;Operation&gt;();
    }

    public void addOperation(Operation operation) {
        this.operations.add(operation);
    }

    public void start() {
        while (true) {
            printOperations();
            System.out.println("Choice: ");

            String choice = this.reader.nextLine();
            if (choice.equals("0")) {
                break;
            }

            executeOperation(choice);
            System.out.println();
        }
    }

    private void printOperations() {
        System.out.println("\t0: Quit");
        for (int i = 0; i &lt; this.operations.size(); i++) {
            String operationName = this.operations.get(i).getName();
            System.out.println("\t" + (i + 1) + ": " + operationName);
        }
    }

    private void executeOperation(String choice) {
        int operation = Integer.parseInt(choice);

        Operation chosen = this.operations.get(operation - 1);
        chosen.execute(reader);
    }
}
</pre>

        <p>The user interface works in the following way:</p>

<pre class="sh_java">
        UserInterface ui = new UserInterface(new Scanner(System.in));
        ui.addOperation(new Addition());

        ui.start();
</pre>

<pre>
Operations:
        0: Quit
        1: Addition
Choice: <font color="red">1</font>
Give the first number: <font color="red">8</font>
Give the second number: <font color="red">12</font>
The sum is 20

Operations:
        0: Quit
        1: Addition
Choice: <font color="red">0</font>
</pre>

        <p>The difference between interfaces and abstract classes is that abstract classes provide the program with more structure. Because it is possible to define the functionality of abstract classes, we can use them to define the default implementation, for instance. The user interface above made use of a definition of the abstract class to store the operation name.</p>


<div class="tehtavat">
    <div class="tehtava">
  <h3>Different Boxes</h3>

  <p>Together with the exercise body, you find the classes <code>Thing</code> and <code>Box</code>. The class <code>Box</code> is abstract, and it is programmed so that adding things always implies calling the method <code>add</code>. The <code>add</code> method, resposible of adding one thing, is abstract, and any box which inherits the class <code>Box</code> has to implement the method <code>add</code>. Your task is modifying the class <code>Thing</code> and implementing various different boxes based on <code>Box</code>.</p>

  <p>Add all new classes to the package <code>boxes</code>.</p>


<pre class="sh_java">
package boxes;

import java.util.Collection;

public abstract class Box {

    public abstract void add(Thing thing);

    public void add(Collection&lt;Thing&gt; things) {
        for (Thing thing : things) {
            add(thing);
        }
    }

    public abstract boolean isInTheBox(Thing thing);
}
</pre>

<h4>Modifications to Thing</h4>

  <p>Add an inspection to the constructor of <code>Thing</code>, to make sure that the thing's weight is never negative (weight 0 is accepted). If the weight is negative, the constructor has to throw an <code>IllegalArgumentException</code>. Also implement the methods <code>equals</code> and <code>hashCode</code> in the class <code>Thing</code>, allowing you to use the <code>contains</code> method of different lists and collections. Implement the methods without taking into consideration the value of the object variable <code>weight</code>. <em>Of course, you can use NetBeans functionality to implement equals and hashCode.</em></p>

<h4>Maximum Weight Box</h4>

  <p>Implement the class <code>MaxWeightBox</code> in the package <code>boxes</code>; the class inherits <code>Box</code>. MaxWeightBox has the constructor <code>public MaxWeightBox(int maxWeight)</code>, which determines the box maximum weight. Things can be added to MaxWeightBox if and only if the thing weight does not exceed the box weight.</p>

<pre class="sh_java">
        MaxWeightBox coffeeBox = new MaxWeightBox(10);
        coffeeBox.add(new Thing("Saludo", 5));
        coffeeBox.add(new Thing("Pirkka", 5));
        coffeeBox.add(new Thing("Kopi Luwak", 5));

        System.out.println(coffeeBox.isInTheBox(new Thing("Saludo")));
        System.out.println(coffeeBox.isInTheBox(new Thing("Pirkka")));
        System.out.println(coffeeBox.isInTheBox(new Thing("Kopi Luwak")));
</pre>

<pre>
true
true
false
</pre>

<h4>One-Thing Box and Black-Hole Box</h4>

        <p>Next, implement the class <code>OneThingBox</code> in the package <code>boxes</code>; the class inherits <code>Box</code>. OneThingBox has the constructor <code>public OneThingBox()</code>, and only one thing can fit there. If the box already contains one thing, this should not be changed. The weight of the added thing is not important.</p>

<pre class="sh_java">
        OneThingBox box = new OneThingBox();
        box.add(new Thing("Saludo", 5));
        box.add(new Thing("Pirkka", 5));

        System.out.println(box.isInTheBox(new Thing("Saludo")));
        System.out.println(box.isInTheBox(new Thing("Pirkka")));
</pre>

<pre>
true
false
</pre>


        <p>Next, implement the class <code>BlackHoleBox</code> in the package <code>boxes</code>; the class inherits <code>Box</code>. BlackHoleBox has the constructor <code>public BlackHoleBox()</code>; any thing can be added to a black-hole box, but none will be found when you'll look for them. In other words, adding things must always work, but the method <code>isInTheBox</code> has to return always false.</p>

<pre class="sh_java">
        BlackHoleBox box = new BlackHoleBox();
        box.add(new Thing("Saludo", 5));
        box.add(new Thing("Pirkka", 5));

        System.out.println(box.isInTheBox(new Thing("Saludo")));
        System.out.println(box.isInTheBox(new Thing("Pirkka")));
</pre>

<pre>
false
false
</pre>


</div>
</div>

<h3>Removing Objects from an ArrayList</h3>

<p>In the following exercise we see what you may end up to, when you want to remove a part of the list objects while parsing an ArrayList:</p>

<pre class="sh_java">
   // somewhere, with a definition like:
   // ArrayList&lt;Object&gt; list = new ...

   for ( Object object : list ) {
      if ( hasToBeRemoved(object) ) {
         list.remove(object);
      }
   }
</pre>

<p>The solution does not work and it throws a <code>ConcurrentModificationException</code>, because it is not possible to modify a list while parsing it with a <em>foreach</em> iterator. We will come back to the topic better on week 12. If you run into such a situation, you can handle it in the following way:</p>

<pre class="sh_java">
   // somewhere, with a definition like:
   // ArrayList&lt;Object&gt; list = new ...

   ArrayList&lt;Object&gt; toBeRemoved = new ArrayList&lt;Object&gt;();

   for ( Object object : list ) {
      if ( hasToBeRemoved(object) ) {
         toBeRemoved.add(object);
      }
   }

   list.removeAll(toBeRemoved);
</pre>

<p>The objects which have to be deleted are gathered together while we parse the list, and the remove operation is executed only after parsing the list.</p>

<div class="tehtavat">

    <div class="tehtava">

<h3>Dungeon</h3>


  <p><em>This exercise is worth four points.</em> Attention! Implement all the functionality in the package <code>dungeon</code>.</p>

<p><b>Attention: you can create only one Scanner object to make your tests work. Do not use Scandinavian letters in the class names. Also, do not use static variables, the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</b></p>


<p>In this exercise, you implement a dungeon game. In the game, the player is in a dungeon full of vampires. The player has to stub the vampires before his lamp runs out of battery and the vampires can suck his blood in the darkness. The player can see the vampires with a blinking of their lamp, after which they have to move blind before the following blinking. With one move, the player can walk as many steps as they want.</p>

<p>The game situation, i.e. the dungeon, the player and the vampires are shown in text form. The first line in the print output tells how many moves the player has left (that is to say, how much battery the lamp has). After that, the print output shows player and vampire positions, which in turn are followed by the game map. In the example below, you see the player (<code>@</code>) and three vampires (<code>v</code>); in this case, the player has enough light for fourteen moves.</p>

<pre>
14

@ 1 2
v 6 1
v 7 3
v 12 2

.................
......v..........
.@.........v.....
.......v.........
</pre>

<p>The example above shows the lamp has enough battery for 14 blinkings. The player <code>@</code> is located at <code>1 2</code>. Note that the coordinates are calculated starting from the high left corner of the game board. In the map below, the character <code>X</code> is located at <code>0 0</code>, <code>Y</code> is at <code>2 0</code> and <code>Z</code> is at <code>0 2</code>.</p>

<pre>
X.Y..............
.................
Z................
.................
</pre>



<p>The user can move by giving a sequence of commands and pressing Enter. The commands are:</p>
<ul>
  <li><code>w</code> go up</li>
  <li><code>s</code> go down</li>
  <li><code>a</code> go left</li>
  <li><code>d</code> go right</li>
</ul>

<p>When the user commands are executed (the user can give many commands at once), a new game situation is drawn. If the lamp charge reaches 0, the game ends and the text <code>YOU LOSE</code> is printed on the board.
</p>

<p>The vampires move randomly in the game, and they take one step for each step the player takes. If the player and a vampire run into each other (even momentarily) the vampire is destroyed. If a vampire tries to step outside the board, or into a place already occupied by another vampire, the move is not executed. When all the vampires are destroyed, the game ends and it prints <code>YOU WIN</code>.</p>

<p>In order to help the tests, create the class <code>Dungeon</code> in your game, with:</p>

<p>
  <ul>
    <li>the constructor <strong><code>public Dungeon(int length, int height, int vampires, int moves, boolean vampiresMove)</code></strong>
      <p>the values <code>length</code> and <code>height</code> represent the dimension of the dungeon (always a square); <code>vampires</code> stands for the initial number of vampires (the positions of the vampires can be decided randomly); <code>moves</code> determines the initial number of moves; and if <code>vampiresMove</code> is <code>false</code>, the vampires do not move.</p></li>
    <li>the method <strong><code>public void run()</code></strong>, which starts the game</li>
  </ul>
</p>

<p><em>Attention!</em> The player starts the game in the position 0,0!</p>
<p><em>Attention!</em> Player and vampires can not move out of the dungeon and two vampires cannot step into the same place!</p>
</ul>

  <p>Below, you find a couple of examples to help you to understand the situation better:</p>

<pre>
14

@ 0 0
v 1 2
v 7 8
v 7 5
v 8 0
v 2 9

@.......v.
..........
.v........
..........
..........
.......v..
..........
..........
.......v..
..v.......

<font color="red">ssd</font>
13

@ 1 2
v 8 8
v 7 4
v 8 3
v 1 8

..........
..........
.@........
........v.
.......v..
..........
..........
..........
.v......v.
..........

<font color="red">ssss</font>
12

@ 1 6
v 6 9
v 6 5
v 8 3

..........
..........
..........
........v.
..........
......v...
.@........
..........
..........
......v...

<font color="red">dd</font>
11

@ 3 6
v 5 9
v 6 7
v 8 1

..........
........v.
..........
..........
..........
..........
...@......
......v...
..........
.....v....

<font color="red">ddds</font>
10

@ 6 7
v 6 6
v 5 0

.....v....
..........
..........
..........
..........
..........
......v...
......@...
..........
..........

<font color="red">w</font>
9

@ 6 6
v 4 0

....v.....
..........
..........
..........
..........
..........
......@...
..........
..........
..........

<font color="red">www</font>
8

@ 6 3
v 4 0

....v.....
..........
..........
......@...
..........
..........
..........
..........
..........
..........

<font color="red">aa</font>
7

@ 4 3
v 4 2

..........
..........
....v.....
....@.....
..........
..........
..........
..........
..........
..........

<font color="red">w</font>
YOU WIN
</pre>



</div>
</div>
</div>
The material continues here: <a href="http://mooc.cs.helsinki.fi/programming-part2/material/week-11">Week 5</a>
</section>

<section class="viikkoraja" id="5" >
  <div class="viikkoraja">Week5</div>
  <div class="viikkoraja-mooc" id="Week 11" deadline="unlocks when 85% of week 10 done " data-first-chapter-index="50" data-first-exercise-index="141" data-first-week-index="11"  data-first-chapter-index-mooc="50" data-first-exercise-index-mooc="141" data-first-week-index-mooc="11" tekija="Arto Vihavainen, Matti Luukkainen">

<h2 id="tiedostostoon_kirjoitus">Writing to a File</h3>

<p>In section 15, we learnt that reading from a file happened with the help of the classes <code>Scanner</code> and <code>File</code>. The class <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileWriter.html">FileWriter</a></code> provides the functionality to write to a file. The <code>FileWriter</code> constructor is given as parameter a String illustrating the file location.</p>

<pre class="sh_java">
        FileWriter writer = new FileWriter("file.txt");
        writer.write("Hi file!\n"); // the line break has to be written, too!
        writer.write("Adding text\n");
        writer.write("And more");
        writer.close(); // the call closes the file and makes sure the written text goes to the file</pre>

    <p>In the example we write the string "Hi file!" to the file "file.txt"; that is followed by a line break, and by more text. Note that when you use the <code>write</code> method, it does not produce line breaks, but they have to be added later manually.</p>

    <p>Both the <code>FileWriter</code> constructor and the <code>write</code> method may throw an exception, which has to be either handled or the responsibility has to be delegated to the calling method. The method which is given as parameter the file name and the text to write into it can look like the following.</p>

<pre class="sh_java">
public class FileHandler {

    public void writeToFile(String fileName, String text) throws Exception {
        FileWriter writer = new FileWriter(fileName);
        writer.write(text);
        writer.close();
    }
}
</pre>

    <p>In the above <code>writeToFile</code> method, we first create a <code>FileWriter</code> object, which writes into the <code>fileName</code> file stored at the location specified as parameter. After this, we write into the file using the <code>write</code> method. The exception the constructor and <code>write</code> method can possibly throw has to be handled either with the help of a <code>try-catch</code> block or delegating the responsibility. In the method <code>writeToFile</code> the responsibility was delegated.</p>

    <p>Let's create a <code>main</code> method where we call the <code>writeToFile</code> method of a <code>FileHandler</code> object. The exception does not have to be handled in the <code>main</code> method either, but the method can declare to throw possibly an exception throw the definition <code>throws Exception</code>.</p>

<pre class="sh_java">
    public static void main(String[] args) throws Exception {
        FileHandler handler = new FileHandler();
        handler.writeToFile("diary.txt", "Dear Diary, today was a nice day.");
    }
</pre>

    <p>When we call the method above, we create the file "diary.txt", where we write the text "Dear Diary, today was a nice day.". If the file exists already, the old content is erased and the new one is written. The method <code>append()</code> allows us to add text at the end of the already existing file, without erasing the existing text. Let's add the method <code>appendToFile()</code> to the class <code>FileHandler</code>; the method appends the text received as parameter to the end of the file.</p>

<pre class="sh_java">
public class FileHandler {
    public void writeToFile(String fileName, String text) throws Exception {
        FileWriter writer = new FileWriter(fileName);
        writer.write(text);
        writer.close();
    }

    public void appendToFile(String fileName, String text) throws Exception {
        FileWriter writer = new FileWriter(fileName);
        writer.append(text);
        writer.close();
    }
}
</pre>

    <p>In most of the cases, instead of writing text at the end of a file with the method <code>append</code>, it is easier to write all the file again.</p>

<div class="tehtavat">
    <div class="tehtava">
<h3>File Manager</h3>

<p>Together with the exercise body, you find the class <code>FileManager</code>, which contains the method bodies to read a write a file.</p>

<h4>File Reading</h4>

<p>Implement the method <code>public ArrayList&lt;String&gt; read(String file)</code> to return the lines of the parameter file in ArrayList form, each file line being a String contained by the ArrayList.
</p>

<p>There are two text files to help testing the project: <code>src/testinput1.txt</code> and <code>src/testinput2.txt</code>. The methods are supposed to be used in the following way:
</p>

<pre class="sh_java">
    public static void main(String[] args) throws FileNotFoundException, IOException {
        FileManager f = new FileManager();

        for (String line : f.read("src/testinput1.txt")) {
            System.out.println(line);
        }
    }
</pre>

<p>The print output should look like the following</p>

<pre>
first
second
</pre>


<h4>Writing a Line</h4>

<p>Modify the method <code>public void save(String file, String text)</code> so that it would write the string of the second argument into the file of the first argument. If the file already exists, the string is written over the old version.
</p>


<h4>Writing a List</h4>

<p>Modify the method <code>public void save(String file, ArrayList<String> texts)</code> so that it would write the strings of the second argument into the file of the first argument; each string of the array list has to go to its own line. If the file already exists, the strings are written over the old version.

</p>
</div>
<div class="tehtava">
    <h3>Two-Direction Dictionary</h3>

    <p>With this exercise, we develop the dictionary we implemented earlier, so that words can be both read and written into the file. Also, the dictionary has to translate in both directions, from Finnish into English and from English into Finnish (in this exercise, we suppose unofficially that Finnish and English do not have words which are spellt the same). Your task is creating the dictionary in the class <code>MindfulDictionary</code>. The class has to be implemented in the package <code>dictionary</code>.</p>

<h4>Forgetful Basic Functionality</h4>

<p>Create a parameterless constructor, as well as the methods:</p>

 <ul>
        <li><code>public void add(String word, String translation)</code></li> adds a word to the dictionary. Each word has only one translation; if the same word is added twice, nothing happens.<br/>
        <li><code>public String translate(String word)</code></li> returns the word translation; if the word isn't recognised, it returns null<br/>
 </ul>

<p>At this point, the dictionary has to work in the following way:</p>

<pre class="sh_java">
MindfulDictionary dict = new MindfulDictionary();
dict.add("apina", "monkey");
dict.add("banaani", "banana");
dict.add("apina", "apfe");

System.out.println( dict.translate("apina") );
System.out.println( dict.translate("monkey") );
System.out.println( dict.translate("programming") );
System.out.println( dict.translate("banana") );
</pre>

<p>Prints:</p>

<pre>
monkey
apina
null
banaani
</pre>

<p>As you notice from the example, after adding a pair the dictionary can translate in both directions.</p>

<h4>Removing Words</h4>

<p>Add the method <code>public void remove(String word)</code></li>, which removes the given word and its translation from your dictionary.</p>

<p>At this point, the dictionary has to work in the following way:</p>

<pre class="sh_java">
MindfulDictionary dict = new MindfulDictionary();
dict.add("apina", "monkey");
dict.add("banaani", "banana");
dict.add("ohjelmointi", "programming");
dict.remove("apina");
dict.remove("banana");

System.out.println( dict.translate("apina") );
System.out.println( dict.translate("monkey") );
System.out.println( dict.translate("banana") );
System.out.println( dict.translate("banaani") );
System.out.println( dict.translate("ohjelmointi") );
</pre>

<p>Prints</p>

<pre>
null
null
null
null
programming
</pre>

<p>As you see, the delection happens in both ways: whether you remove a word or its translation, the dictionary loses the both the pieces of information. </p>



<h4>Loading a File</h4>

<p>Create the constructor <code>public MindfulDictionary(String file)</code> and the method <code>public boolean load()</code>, which loads a file whose name is given as parameter in the dictionary constructor. If opening or reading the file does not work, the method returns false and otherwise true.</p>

<p>Each line of the dictionary file contains a word and its translation, divided by the character ":". Together with the exercise body, you find a dictionary file meant to help the tests. It looks like the following: </p>

<pre>
apina:monkey
alla oleva:below
olut:beer
</pre>

<p>Read the dictionary file line by line with the reader method <code>nextLine</code>. You can split the lines with the String method <code>split</code>, in the following way:</p>

<pre class="sh_java">
Scanner fileReader = new ...
while ( fileReader.hasNextLine() ){
    String line = fileReader.nextLine();
    String[] parts = line.split(":");   // the line is split at :

    System.out.println( parts[0] );     // the part of the line before :
    System.out.println( parts[1] );     // the part of the line after :
}
</pre>

<p>The dictionary is used in the following way:</p>

<pre class="sh_java">
MindfulDictionary dict = new MindfulDictionary("src/words.txt");
dict.load();

System.out.println( dict.translate("apina") );
System.out.println( dict.translate("ohjelmointi") );
System.out.println( dict.translate("alla oleva") );
</pre>

<p>Printing</p>

<pre>
monkey
null
below
</pre>


<h4>Saving Data</h4>

    <p>Create the method <code>public boolean save()</code>; when the method is called, the dictionary contents are written into the file whose name was given as parameter to the constructor. The method returns false if the file can't be saved; otherwise it returns true. Dictionary files have to be saved in the form described above, meaning that the program has to be able to read its own files.</p>

<p><strong>Attention:</strong> even though the dictionary can translate in both directions, only one direction has to be stored into the dictionary file. For instance, if the dictionary knows that <em>tietokone = computer</em>, you have to write either the line:</p>

<pre>
tietokone:computer
</pre>

<p>or the line</p>

<pre>
computer:tietokone
</pre>

<p>but not both!</p>

    <p>It may be useful to write the new translation list over the old file; in fact, the <code>append</code> command which came out in the material should not be used.</p>

<p>The final version of your dictionary should be used in the following way:</p>

<pre class="sh_java">
MindfulDictionary dict = new MindfulDictionary("src/words.txt");
dict.load();

// using the dictionary

dict.save();
</pre>

<p>At the beginning we load the dictionary from our file, and we save it back in the end, so that the changes made to the dictionary will be available next time, too.</p>
</div>
</div>


<h2 id="kalit">User Interfaces</h2>

<p><hr/></p>
<p><big><strong><strong>Attention!</strong> A part of the user interface tests opens a user interface and uses your mouse to click on the user interface components. When you are executing user interface tests, do not use your mouse!</strong></big></p>
<p><hr/></p>

<p>So far, our programs have only been composed of application logic and text user interface which made use of application logic. In a couple of exercises we have also got a graphical user interface, but they had usually been created for us. Next, we see how we can create graphical user interfaces in Java.</p>

<p>User interfaces are windows which contain different types of buttons, text boxes, and menus. When we program user interfaces we use Java's
<a href="http://docs.oracle.com/javase/tutorial/uiswing/components/index.html" target="_blank">Swing</a> component library, which provides us with classes to create and handle user interfaces.</p>

<p>The basic element of a user interface is the class <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFrame.html" target="_blank">JFrame</a></code>, and we create the user interface components in its component section. Orthodox user interfaces implement the interface <code>Runnable</code>, and they are started in the main program. In this course, we use the following user interface body:</p>

<pre class="sh_java">
import java.awt.Container;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class UserInterface implements Runnable {

    private JFrame frame;

    public UserInterface() {
    }

    @Override
    public void run() {
        frame = new JFrame("Title");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        createComponents(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }

    private void createComponents(Container container) {
    }

    public JFrame getFrame() {
        return frame;
    }
}
</pre>

<p>Let's have a closer look the the user interface code above.</p>

<pre class="sh_java">
public class UserInterface implements Runnable {
</pre>

<p>The class <code>UserInterface</code> implements Java's <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Runnable.html" target="_blank">Runnable</a> interface, which allows us to execute a threaded program. Executing a threaded program means that we execute different parts of the program at the same time. We do not dig deeper into threads, but a further information on threads is provided by the course <em>Operating Systems</em>.</p>

<pre class="sh_java">
    private JFrame frame;
</pre>

<p>The user interface contains a <code>JFrame</code> object as variable, which is the basic element of a visible user interface. All user interface components are added to the <code>JFrame</code> object component container. Note that <strong>object variables cannot be initiated outside the methods</strong>. For instance, an initialisation of the object variable <coded>JFrame</code> with the class definition <code>"private JFrame frame = new JFrame()"</code> would evade user interface thread execution order, and it can lead to a breakdown.</p>

<pre class="sh_java">
    @Override
    public void run() {
        frame = new JFrame("Title");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        createComponents(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }
</pre>

<p>The interface <code>Runnable</code> defines the method <code>public void run()</code>, which has to be implemented by all classes which implement the interface. With the method <code>public void run()</code>, we first create a new JFrame whose title is <code>"Title"</code>. After this, we define the frame size whose width is 200 pixels and height is 100 pixels. The statement <code>frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</code> tells to the JFrame object that the user interface has to close when the user presses the cross icon.</p>

<p>Afterwards, we call the method <code>createComponents</code> which is defined lower down in the class. The method is given <code>JFrame</code>'s <em><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Container.html" target="_blank">Container</a></em> object as parameter, where we can add user interface components.</p>

<p>Finally, we call the method <code>frame.pack()</code> which packs the JFrame object as defined before and sorts the user interface components of the Container object contained by JFrame. At the end, we call the method <code>frame.setVisible(true)</code>, to show the user interface to the user.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
    }
</pre>

<p>In the method <code>createComponents</code> we add user interface components to the <code>JFrame</code>'s container. In our example there is no UI component in addition to our JFrame window. The class <code>UserInterface</code> has also the method <code>getFrame</code> which we can use to retrieve the JFrame object which is encapsulated in the class.</p>

<p>Swing user interfaces are started through the method <code>invokeLater</code>, which is provided by the class <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingUtilities.html" target="_blank">SwingUtilities</a></code>. <code>invokeLater</code> receives as parameter an object which implements the interface <code>Runnable</code>. The method adds the <code>Runnable</code> object to the execution queue and calls it as soon as possible. With the class<code>SwingUtilities</code>, we can start new threads when we need them.</p>

<pre class="sh_java">
import javax.swing.SwingUtilities;

public class Main {

    public static void main(String[] args) {
        UserInterface ui = new UserInterface();
        SwingUtilities.invokeLater(ui);
    }
}
</pre>


<p>When we execute the main method above, the user interface we have defined in the class <code>UserInterface</code> appears in our screen.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/first-ui.png"/></p>


<h3>UI Components</h3>


<p>User Interfaces are composed of a background window (JFrame) and a component Container, as well as the UI components which are set into the container. UI components are different kinds of buttons, texts, and other items. Every component has its own class. It's useful to get accustomed to Oracle visual sequence of components at the address <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/index.html" target="_blank">http://docs.oracle.com/javase/tutorial/uiswing/components/index.html</a>.</p>

<h4>Text</h4>

<p>Text can be displayed with the help of the class <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JLabel.html" target="_blank">JLabel</a></code>. <code>JLabel</code> provides a UI component which can be assigned text and whose text can be modified. The text is assigned either in the constructor, or separately, with the <code>setText</code> method.</p>

<p>Let's modify our UI container to display text. We create a new JLabel text component within the method <code>createComponents</code>. Then we retrieve the <code>Container</code> object from our <code>JFrame</code> object, and we add JLabel to Container using its <code>add</code> method.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        JLabel text = new JLabel("Text field!");
        container.add(text);
    }
</pre>

<p>As you see from the code above, JLabel shall display the text <code>"Text field!"</code>. When we execute the user interface, we see the following window.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/text-field.png"/></p>


<div class="tehtavat">
    <div class="tehtava">
<h3>Greeter</h3>

<p>Implement a user interface which displays the text "Hi!". The width of the user interface (i.e. of the JFrame object) has to be at least 400px, its height 200px, and its title should be "Swing on". The JFrame object should be created and become visible inside the method <code>run()</code>, and the text components are added to the user interface with the method <code>createComponents(Container container)</code>.</p>

<p><strong>ATTENTION: The ui object variables have to be initiated in the methods or in the constructor! Do not initiate an object variable directly in its definition.</strong></p>
</div>
</div>

<h4>Buttons</h4>

<p>You can add buttons to your user interface using the class <code>JButton</code>. Adding a JButton object to your user interface is similar to adding a JLabel object.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        JButton button = new JButton("Click!");
        container.add(button);
    }
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/click.png"/></p>

<p>Next, we try to add both text and a button to our user interface.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        JButton button = new JButton("Click!");
        container.add(button);
        JLabel text = new JLabel("Text.");
        container.add(text);
    }
</pre>

<p>When we execute the program we see the following user interface.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/text.png"/></p>

<p>Only the last component we have added is visible, and our program does not work as we would expect. What is the problem, in fact?</p>

<h3>Setting up UI Components</h3>

<p>All UI components have got their own location in the user interface. The component location is defined by the UI <em>Layout Manager</em>. Before, when we tried to add many different components to our <code>Container</code> object, only one component became visible. Every <code>Container</code> object has a default UI layout manager: <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/BorderLayout.html" target="_blank">BorderLayout</a></code>.</p>

<p>BorderLayout places the UI components to five areas: the user interface centre and the four compass points.  When we use the Container's <code>add</code> method, we can give it another parameter, clarifying where we would like to place the component. the BorderLayout class has five class variables available for use: <code>BorderLayout.NORTH</code>, <code>BorderLayout.EAST</code>, <code>BorderLayout.SOUTH</code>, <code>BorderLayout.WEST</code>, ja <code>BorderLayout.CENTER</code>.</p>

<p>The UI layout manager we want to use is assigned to the <code>Container</code> object in the parameter of the method <code>setLauout</code>. In addition to the UI component, the method <code>add</code> can also be assigned the location wehere the component should be placed. In the example below, we assign a component to every BorderLayout location.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        // the following line is not essential in this case, because BorderLayout is default in JFrame
        container.setLayout(new BorderLayout());

        container.add(new JButton("North"), BorderLayout.NORTH);
        container.add(new JButton("East"), BorderLayout.EAST);
        container.add(new JButton("South"), BorderLayout.SOUTH);
        container.add(new JButton("West"), BorderLayout.WEST);
        container.add(new JButton("Center"), BorderLayout.CENTER);

        container.add(new JButton("Default (Center)"));
    }
</pre>

<p>Notice that the button <code>"Center"</code> is not visible in our user interface because the button <code>"Default (Center)"</code> is assigned to its place by default. A container with the code above will look like the following after increasing its size manually.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/layout-override.png"/></p>

<p>As for UI components, there are also many UI layout managers. Oracle has a visual guide to learn more about UI layout managers at <a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank">http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html</a>. Below, we introduce the layout manager <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/BoxLayout.html" target="_blank">BoxLayout</a></code>.</a>

<h4>BoxLayout</h4>

<p>When we use BoxLayout, UI components are added into the user interface either horizontally or vertically. The BoxLayout constructor is given a Container object as parameter -- where we have been adding the UI components -- and the layout direction of the UI components. The layout direction can be either <code>BoxLayout.X_AXIS</code>, i.e. components are set up horizontally, or <code>BoxLayout.Y_AXIS</code>, i.e. the componets are set up vertically. Differently than BorderLayout, BoxLayout does not have a limited number of places. In other words, you can add to your Container as many components as you want.</p>

<p>Arranging the user interface with <code>BoxLayout</code> works as using <code>BorderLayout</code>. We first create the layout manager and we assign it to the <code>Container</code> object using its method <code>setLayout</code>. After this, we can add components to the <code>Container</code> object using the <code>add</code> method. We don't need a further parameter specifying the location. Below, you find an example of components placed in horizontal order.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.X_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("First!"));
        container.add(new JLabel("Second!"));
        container.add(new JLabel("Third!"));
    }
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/layout-xaxis.png"/></p>

<p>Setting up the components vertically does not require major changes. We modify the direction parameter of the <code>BoxLayout</code> constructor: <code>BoxLayout.Y_AXIS</code>.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("First!"));
        container.add(new JLabel("Second!"));
        container.add(new JLabel("Third!"));
    }
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/layout-yaxis.png"/></p>

<p>Using the different layout managers, we can create user interfaces where the components are set up appropriately. Below, there is an example of user interface where the components are placed vertically. First there is some text, and then an optional selection. You can create a multiple-exclusion scope for a set of buttons -- meaning that turning "on" one of those buttons turns off all the others in the group -- using <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/ButtonGroup.html" target="_blank">ButtonGroup</a></code> and <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JRadioButton.html" target="_blank">JRadioButton</a></code>.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Choose meat or fish:"));

        JRadioButton meat = new JRadioButton("Meat");
        JRadioButton fish = new JRadioButton("Fish");

        ButtonGroup buttonGroup = new ButtonGroup();
        buttonGroup.add(meat);
        buttonGroup.add(fish);

        container.add(meat);
        container.add(fish);
    }
</pre>


    <p>Once the UI is launched, and Meat is selected, the UI looks as follows.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/buttongroup.png"/></p>


<div class="tehtavat">
    <div class="tehtava">


<h3>Survey</h3>

<p>Implement a user interface in the exercise body; the interface has to look like the following:</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/survey.png"/></p>

<p>Use <code>BoxLayout</code> as layout manager for your user interface; the components are the classes <code>JLabel</code>, <code>JRadioButton</code>, <code>JCheckBox</code> and <code>JButton</code>.</p>

<p>Use the class <code>ButtonGroup</code> to make sure the options <code>"No reason."</code> and <code>"Because it is fun!"</code> cannot be chosen at the same time.</p>

<p>Make sure that the user interface is big enough so that the user can click the buttons without resizing the interface. For instance, you can use 200 pixels for the width and 300 pixels for the height.</p>
</div>
</div>

<h3>Managing Action Events</h3>

<p>So far, even though our user interfaces are beautiful, they are quite boring: they do not react in any way according to the actions done on the interfaces.
Such unresponsiveness does not depend on our user interface components, but on the fact we haven't provided them with any way to listen to action events.</p>

<p>Action event listeners <em>listen</em> the UI components they are assigned to. Always when we perform an action on our UI components -- pressing a button, for instance -- the UI component calls a particular method of all the action event listeners assigned to it. Action event listeners are classes which implement a particular interface, and whose instances can be assigned to UI components. When an action event happens, the UI component goes through all its action event listeners, and calls the method defined by the interface.</p>

<p>The most used action event listener interface with Swing user interfaces is <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionListener.html">ActionListener</a></code>. The interface <code>ActionListener</code> defines the method <code>void actionPerformed(ActionEvent e)</code>, which receives an <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionEvent.html" target="_blank">ActionEvent</a></code> object as parameter.</p>

<p>Let's implement our first own action event listener, which has to print a message only when we press the relative button. The class <code>MessageListener</code> implements <code>ActionListener</code> and prints the message <code>"Message received!"</code> when the method <code>actionPerformed</code> is called.</p>

<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class MessageListener implements ActionListener {

    @Override
    public void actionPerformed(ActionEvent ae) {
        System.out.println("Message received!");
    }
}
</pre>

<p>Next, we create the a <code>JButton</code> for our user interface, and we add a instance of <code>MessageListener</code> to it. The class <code>JButton</code> can be added an action event listener by using the method defined in its parent class <code>AbstractButton</code>: <code>public void addActionListener(ActionListener actionListener)</code>.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        JButton button = new JButton("Send!");
        button.addActionListener(new MessageListener());

        container.add(button);
    }
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/send.png"/></p>

<p>When we press the button in our user interface we see the following message.</p>

<pre>
Message received!
</pre>

<h4>Handling Objects in the Action Event Listeners</h4>

<p>Often, we want that an action event listener modified the state of an object. In order to have access to the object in the action event listener, the action event listener constructor has to be assigned a reference to the obejct concerned. Action eventlisteners are exactly similar to other Java's class, and we can program their whole functionality.</p>

<p>Let's take the following user interface, which has two <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextArea.html" target="_blank">JTextArea</a></code>s -- where the user can input text, and a <code>JButton</code>. The user interface makes use of <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/GridLayout.html" target="_blank">GridLayout</a></code>, which makes the user interface look like a coordinate system. In the GridLayout constructor, we defined one line and three columns.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaLeft = new JTextArea("The Copier");
        JTextArea textAreaRight = new JTextArea();
        JButton copyButton = new JButton("Copy!");

        container.add(textAreaLeft);
        container.add(copyButton);
        container.add(textAreaRight);
    }
</pre>

    <p>After a manual resize, the UI looks like the following.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/copier.png"/></p>

<p>We want to implement our user interface so that the text in the left area would be copied into the right area when we press the <code>JButton</code>. This is possible by implementing an action event listener. Let's create the class <code>AreaCopier</code> which implements <code>ActionListener</code> and copies the text from one to the other JTextArea.</p>


<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JTextArea;

public class AreaCopier implements ActionListener {

    private JTextArea origin;
    private JTextArea destination;

    public AreaCopier(JTextArea origin, JTextArea destination) {
        this.origin = origin;
        this.destination = destination;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        this.destination.setText(this.origin.getText());
    }
}
</pre>

<p>Adding the new action event listener to the <code>JButton</code> object is possible using the method <code>addActionListener</code>.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaLeft = new JTextArea("The Copier");
        JTextArea textAreaRight = new JTextArea();
        JButton copyButton = new JButton("Copy!");

        AreaCopier copier = new AreaCopier(textAreaLeft, textAreaRight);
        copyButton.addActionListener(copier);

        container.add(textAreaLeft);
        container.add(copyButton);
        container.add(textAreaRight);
    }
</pre>


<p>When we press the button, the text in the left area is copied into the right one.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/copier2.png"/></p>

<div class="tehtavat">
    <div class="tehtava">

<h3>Notice Board</h3>

<p>Implement a user interface in the exercise body; the interface has to look like the following:</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/noticeboard.png"/></p>

<p>The program has to be composed of the following classes, which are contained in the package <code>noticeboard</code>. The class <code>NoticeBoard</code> is the user interface class, and it is started from the <code>Main</code> class. The notice board has various different components: <code>JTextField</code>, <code>JButton</code>, and <code>JLabel</code>. You can manage the layout of the ui components with <code>GridLayout</code>: the call <code>new GridLayout(3, 1)</code> creates a new layout manager, which sets up three ui elements vertically.</p>

<p>The application also has to contain the class <code>ActionEventListener</code>, which implements the interface <code>ActionListener</code>. The action event listener is connected to the button, and when pressed, it has to copy the contents of the JTextField into JLabel. At the same time, it wipes the JTextField by setting its contents as "".</p>

<p>Make sure that the user interface is big enough to click on each button.</p>
</div>
</div>

<h3>Separating Application and UI Logic</h3>

<p>Mixing the application logic (the functionality to print or compute, for instance) and the user interface together in the same classes is usually a bad thing. It makes much more difficult to test and modify a program, and it makes the code much more difficult to read. As the single responsibility principle states: each class should have only one clear responsibility. Separating the application logic from the UI logic works smoothly planning your interfaces appropriately. Let's suppose, that we have got a the class <code>PersonRecord</code>, and we want to implement a user interface to record people.</p>

<pre class="sh_java">
public interface PersonRecord {
    void record(Person person);
    Person get(String id);

    void delete(Person person);
    void delete(String id);
    void deleteAll();

    Collection&lt;Person&gt; getAll();
}
</pre>

<h4>UI Implementation</h4>

<p>When we implement our user interface, a good start is adding the components to it. If we want to record people, we need fields for their name and their ID number, as well as a button to add the person. We use Java's <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextField.html" target="_blank">JTextField</a></code> to input text, and the class <code>JButton</code> to implement our button. In addition, we also create <code>JLabel</code> textual descriptions which tell the user what to do.</p>

<p>For our UI layout, we use <code>GridLayout</code>. There are three lines and two columns in our user interface. We add the action event listener later. The UI method <code>createComponents</code> looks like the following.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel textName = new JLabel("Name: ");
        JTextField nameField = new JTextField();
        JLabel textID = new JLabel("ID: ");
        JTextField idField = new JTextField();

        JButton addButton = new JButton("Add!");
        // event listener

        container.add(textName);
        container.add(nameField);
        container.add(textID);
        container.add(idField);
        container.add(new JLabel(""));
        container.add(addButton);
    }
</pre>

<p>After adding the information, our user interface looks like the following.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/persondetails.png"/></p>

<p>The action event listener has to know about the recording functionality (<code>PersonRecord</code> interface), as well as the fields it uses. Let's create the class <code>PersonRecordListener</code> which implements <code>ActionListener</code>. As constructor parameter, the class is assigned an object which implements the interface <code>PersonRecord</code>, as well as two <code>JTextField</code> objects which stand for the name and ID fields. In the method <code>actionPerformed</code> we create a new <code>Person</code> object and we record it using the <code>record</code> method of our <code>PersonRecord</code> object.</p>

<pre class="sh_java">
public class PersonRecordListener implements ActionListener {

    private PersonRecord personRecord;
    private JTextField nameField;
    private JTextField idField;

    public PersonRecordListener(PersonRecord personRecord, JTextField nameField, JTextField idField) {
        this.personRecord = personRecord;
        this.nameField = nameField;
        this.idField = idField;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        Person person = new Person(nameField.getText(), idField.getText());
        this.personRecord.record(person);
    }
}
</pre>

<p>In order to retrieve a <code>PersonRecord</code> reference to <code>PersonRecordListener</code>, the user interface must have access to it. Let's add to our user interface the object variable <code>private PersonRecord personRecord</code> which is set up in the constructor. We also modify the constructor of the class <code>UserInterface</code>, which is assigned a class which implements the interface <code>PersonRecord</code>.</p>

<pre class="sh_java">
public class UserInteface implements Runnable {

    private JFrame frame;
    private PersonRecord personRecord;

    public UserInteface(PersonRecord personRecord) {
        this.personRecord = personRecord;
    }
    // ...


</pre>

<p>Now we can create the action event listener <code>PersonRecordListener</code>, which is given both a <code>PersonRecord</code> reference and the fields.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nameText = new JLabel("Name: ");
        JTextField nameField = new JTextField();
        JLabel idText = new JLabel("ID: ");
        JTextField idField = new JTextField();

        JButton addButton = new JButton("Add!");
        PersonRecordListener listener = new PersonRecordListener(personRecord, nameField, idField);
        addButton.addActionListener(listener);

        container.add(nameText);
        container.add(nameField);
        container.add(idText);
        container.add(idField);
        container.add(new JLabel(""));
        container.add(addButton);
    }
</pre>

<div class="tehtavat">
    <div class="tehtava">
<h3>Axe Click Effect</h3>

<p>In this exercise we implement a calculator to count the number of clicks. In the exercise, the application logic (counting) and the ui logic are divided from each other. The final application should look like the following, so far. </p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/clickeffect.png"/></p>

<h4>PersonalCalculator</h4>

<p>Implement the class <code>PersonalCalculator</code> in the package <code>clicker.applicationlogic</code>; the class implements the interface <code>Calculator</code>. At first, the method <code>giveValue</code> of <code>PersonalCalculator</code> returns 0. Whenever the method <code>increase</code> is called, the value increases by one.</p>

<p>If you want, you can test the class using the following program.</p>

<pre class="sh_java">
        Calculator calc = new PersonalCalculator();
        System.out.println("Value: " + calc.giveValue());
        calc.increase();
        System.out.println("Value: " + calc.giveValue());
        calc.increase();
        System.out.println("Value: " + calc.giveValue());
</pre>

<pre>
Value: 0
Value: 1
Value: 2
</pre>

<h4>ClickListener</h4>

<p>Implement the class <code>ClickListener</code> in the package <code>clicker.ui</code>; the class implements the interface <code>ActionListener</code>. <code>ClickListener</code> receives two objects as constructor parameters: an object which implements the interface <code>Calculator</code> and a <code>JLabel</code> object.</p>

<p>Implement the <code>actionPerformed</code> method so that the <code>Calculator</code> object increases by one at first, and after it, the calculator value is set as text of the <code>JLabel</code> object. The text of the <code>JLabel</code> object can be modified with the method <code>setText</code>.</p>

<h4>User Interface</h4>

<p>Modify the class <code>UserInterface</code>; now the user interface has to receive a <code>Calculator</code> object as constructor parameter: you need a new constructor. Add the necessary ui components to your UserInterface. Also, set the action event listener you implemented in the previous section to the button.</p>

<p>Use the functionality provided by the class <code>BorderLayout</code> to manage the layout of the ui components. Also, change the <code>Main</code> class so that the user interface is assigned a <code>PersonalCalculator</code> object. When the <code>"Click!"</code> button in the user interface has been pressed twice, the application looks like below, more or less.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/clickeffect2.png"/></p>

</div>
</div>


<h3>Nested Container Objects</h3>

<p>Sometimes we end up in a situation, where the <code>Container</code> object provided by <code>JFrame</code> is not suitable enough for our UI layout. We may want our user interface to look different or to group up UI components according to their use. For instance, building a user interface like the one below would not be so easy, using only the <code>Container</code> object provided by the class <code>JFrame</code>.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/nestedobjects.png"/></p>

<p>We can place Container objects inside each other. The class <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JPanel.html" target="_blank">JPanel</a></code> (see also <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html" target="_blank">How to Use Panels</a>) allows for nested <code>Container</code> objects. It is possible to add UI components to a <code>JPanel</code> instance in the same way we add components to the <code>Container</code> instance of <code>JFrame</code> class. Moreover, it is possible to add an instance of <code>JPanel</code> to a <code>Container</code> object. This makes possible to use many <code>Container</code> objects to develop one user interface.</p>

<p>Creating a user interface like the one above is easier with <code>JPanel</code>. Let's create a user interface with three buttons -- Execute, Test, and Send -- plus a text field. The buttons are a group on its own, and we assign them to a <code>JPanel</code> object which is placed in the lower part of the <code>Container</code> object which we have got from <code>JFrame</code> class.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        container.add(new JTextArea());
        container.add(createPanel(), BorderLayout.SOUTH);
    }

    private JPanel createPanel() {
        JPanel panel = new JPanel(new GridLayout(1, 3));
        panel.add(new JButton("Execute"));
        panel.add(new JButton("Test"));
        panel.add(new JButton("Send"));
        return panel;
    }
</pre>

<p>The JPanel class is given as constructor parameter the layout style to use. If in its constructor the layout style requires a reference to the <code>Container</code> object used, the <code>JPanel</code> class also has the method <code>setLayout</code>.</p>

<p>If our user interface has clear, separate, groups of components we can also inherit the <code>JPanel</code> class. For instance, the panel above could be implemented in the following way, too.</p>

<pre class="sh_java">
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JPanel;

public class MenuPanel extends JPanel {

    public MenuPanel() {
        super(new GridLayout(1, 3));
        createComponents();
    }

    private void createComponents() {
        add(new JButton("Execute"));
        add(new JButton("Test"));
        add(new JButton("Send"));
    }
}
</pre>

<p>Now we can create a <code>MenuPanel</code> instance in our user interface class.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        container.add(new JTextArea());
        container.add(new MenuPanel(), BorderLayout.SOUTH);
    }
</pre>

<p>Note that in case you need an action event listener, the class <code>MenuPanel</code> must be given all the objects its need as parameter.</p>

<div class="tehtavat">
    <div class="tehtava">
<h3>Calculator</h3>

<p>The goal of the exercise is creating a simple calculator. The calculator user interface has to look like the following:</p>

   <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/laskin.png"/></p>

   <p>Together with the exercise body, you find the main program which starts the calculator, as well as the class <code>GraphicCalculator</code> which contains a graphic user interface. The user interface has to follow exactly the following points, but you can plan the program structure as you wish. <b>Note:</b> <code>GraphicCalculator</code> provides empty methods <code>run</code>, <code>createComponents</code> and <code>getFrame</code>.</p>

<h4>The Layout</h4>

<p>You find a <code>JFrame</code> with the exercise body; you manage its layout using <code>GridLayout</code> with three lines and one column. <code>JTextField</code> has to be placed in the upper block and has to be used for the text output; it must be set off with the method call <code>setEnabled(false)</code>. The second block has to contain <code>JTextField</code> for the text input. Originally, the input field contains the text "0", and the input field is empty.</p>

<p>The lowest block has to contain <code>JPanel</code>, and this has to have the layout manager <code>GridLayout</code>, with one line and three columns. The panel has three <code>JButton</code>s, with texts "+", "-" and "Z".</p>

<h4>Basic Functionality</h4>

<p>The calculator basic functionality is the following. When the user writes a number n into the input field and presses <strong>+</strong>, the value of the output field is added n and the output field is updated with a new value. Accordingly, when the user writes a number n into the input field and presses <strong>-</strong>, the value of the output field is decreased by n, and the output field is updated with the new value. If the user presses <strong>Z</strong>, the output field value is reset to zero.</p>

<h4>Cozy Management</h4>

<p>Let's extend our program with the following features:</p>
<ul>
<li>If the output field is 0, the user can't press the <strong>Z</strong> button, i.e. the button has to be set off with the method call <code>setEnabled(false)</code>. Otherwise, the button has to be on.</li>
<li>When the user presses any of the buttons <strong>+, -, Z</strong> the input field is wiped.</li>
<li>If the input value is not an integer and the user presses one of the buttons <strong>+, -, Z</strong>, the input field is wiped and the value of the output field does not change (unless the button is <strong>Z</strong>).</li>
</ul>
</div>
</div>

<h2>Drawing</h2>

<p>Its <code>Container</code> functionality is not the only reason why we use the class <code>JPanel</code>: it is also used as drawing board, and the user inherits the <code>JPanel</code> class and overrides the method <code>protected void paintComponent(Graphics graphics)</code>. The user interface calls the method <code>paintComponent</code> whenever we want to draw again the UI component contents. The parameter of the method <code>paintComponent</code> receives from the user interface an object which implements the abstract class <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code>. Let's create the class <code>DrawingBoard</code> <code>JPanel</code> which inherits from <codeZ>JPanel</code> and which overrides the <code>paintComponent</code> method.</p>

<pre class="sh_java">
public class DrawingBoard extends JPanel {

    public DrawingBoard() {
        super.setBackground(Color.WHITE);
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
    }
}
</pre>

<p>The drawing board above does not contain concrete drawing functionality. In the constructor, we can define the colour of our drawing board to be white by calling its superclass' method <code>setBackground</code>. The method <code>setBackGround</code> receives an instance of the class <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Color.html" target="_blank">Color</a></code> as parameter. The class <code>Color</code> contains the most common colours as class variables; for instance, you get the white colour using the class variable <code>Color.WHITE</code>.</p>

<p>The overridden <code>paintComponent</code> method calls the superclass' <code>paintComponent</code> method, and it does not do anything else. Let's add the drawing board to the <code>createComponents</code> method of class <code>UserInterface</code>. We use the user interface which was defined at the beginning of the section <a href="#58">58. User Interfaces</a>.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        container.add(new DrawingBoard());
    }
</pre>

<p>When we start our user interface we see an empty screen, whose background colour is white. The size of the user interface below is set to 300x300 through the method <code>setPreferredSize</code>, and its title is <code>"Drawing Board"</code>.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/drawingboard.png"/></p>

<p>Drawing on the board is possible using the methods provides by the <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code> object. Let's modify the method <code>paintComponent</code> of <code>DrawingBoard</code> and let's draw two rectangles using the method <code>fillRect</code> of the <code>Graphics</code> object.</p>

<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.fillRect(50, 80, 100, 50);
        graphics.fillRect(200, 20, 50, 200);
    }
</pre>

<p>The method <code>fillRect</code> receives as parameter the <code>x</code> and <code>y</code> coordinates of a rectangle, plus the rectangle width and height. In fact, above we first draw a rectangle which starts with pixel whose coordinates are <code>(50, 80)</code>, which is 100 pixels long, and 50 pixels high. Afterwards, we draw a 50-pixel long, 100-pixel high rectangle which begins at <code>(200, 20)</code>.</p>

<p>As you notice from the picture, the coordinate system does not work as we are accustomed to.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/drawingboard-blocks.png"/></p>

<p>Java's <code>Graphics</code> object (and most of other programming language libraries) expects the value of the y axis to grow downwards. The coordinate system origin, i.e. the point <code>(0,0)</code> is in the upper left corner: the Graphics object always knows the UI component where we draw, and it is able to define the location of the point to draw based on it. The location of the UI origin can become clear with the help of the following program. First we draw a green 10-pixel long, 200-pixel high rectangle which starts from the point (0,0). Then we draw a black 200-pixel long, 10-pixel high rectangle which starts from the point (0,0). The drawing colour is defined by the method <code>setColor</code> of our <code>Graphics</code> object.</p>


<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.setColor(Color.GREEN);
        graphics.fillRect(0, 0, 10, 200);
        graphics.setColor(Color.BLACK);
        graphics.fillRect(0, 0, 200, 10);
    }
</pre>


    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/drawingboard-coordinates.png"/></p>

<p>Such coordinate system reversibility depends on the way user interface size is modified. When we modify the size of a user interface, this is reduced or increased by "dragging the bottom right corner"; in this way, the drawing on the screan would move while we change the UI size. Because the grid starts from the upper left corner, the drawing position is always the same, but the visible part changes.</p>

<div class="tehtavat">
    <div class="tehtava">

<h3>Drawing Board</h3>

<p>With the exercise body, you find a pre-made user interface, which is connected to the class <code>DrawingBoard</code>, which inherits <code>JPanel</code>. Modify the method <code>paintCOmponent</code> of <code>DrawingBoard</code> so that it would draw the following figure. You can only use the <code>fillRect</code> method of the <code>graphics</code> object, in this exercise.</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/smiley.gif"/></p>

<p>Attention! Do not use more than five <code>fillRect</code> calls. The figure does not have to be identical to the one above, the tests tell you when your figure is close enough to the required one.</p>

</div>
</div>

<p>Let's extend our previous example and draw an independent avatar-object in our user interface. Let's create the class <code>Avatar</code>; it has the coordinates of the point where it appears, and it is a circle with a 10-pixel diameter. The location of the avatar can be changed by calling its <code>move</code> method.</p>

<pre class="sh_java">
import java.awt.Graphics;

public class Avatar {

    private int x;
    private int y;

    public Avatar(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void move(int movingX, int movingY) {
        this.x += movingX;
        this.y += movingY;
    }

    public void draw(Graphics graphics) {
        graphics.fillOval(x, y, 10, 10);
    }
}
</pre>

<p>Let's modify our drawing board, giving it an instance of our <code>Avatar</code> as constructor parameter. The method <code>paintComponent</code> of <code>DrawingBoard</code> does not draw the character itself, but it delegates the responsibility to the instance of the class <code>Avatar</code>.</p>

<pre class="sh_java">
import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawingBoard extends JPanel {

    private Avatar avatar;

    public DrawingBoard(Avatar avatar) {
        super.setBackground(Color.WHITE);
        this.avatar = avatar;
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
        avatar.draw(graphics);
    }
}
</pre>

<p>Let's also give our avatar as parameter to our user interface. Avatar is an independent object in the user interface, and we only want to draw it in the user interface. It is essential to change our UI constructor so that it received a <code>Avatar</code> object. Moreover, in the method <code>createComponents</code> we give an instance of the class <code>Avatar</code> as parameter to our <code>DrawingBoard</code> object.</p>

<pre class="sh_java">
public class UserInterface implements Runnable {

    private JFrame frame;
    private Avatar avatar;

    public UserInterface(Avatar avatar) {
        this.avatar = avatar;
    }

// ...

    private void createComponents(Container container) {
        DrawingBoard drawingBoard = new DrawingBoard(avatar);
        container.add(drawingBoard);
    }
// ...
</pre>

<p>Now, our user interface can be started giving it an <code>Avatar</code> object as constructor parameter.</p>

<pre class="sh_java">
        UserInterface ui = new UserInterface(new Avatar(30, 30));
        SwingUtilities.invokeLater(ui);
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/drawingboard-avatar.png"/></p>

<p>In the user interface above, we see a ball-like Avatar.</p>

<p>Let's now add the functionality to move the avatar. We want to move it using our keyboard. When the user presses the left arrow, the avatar should move left. Pressing the right arrow should move the avatar right. We need an action event listener, which would listen to our keyboard. The interface <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> defines the functionality needed to listener to a keyboard.</p>

<p>The interface <code>KeyListener</code> calls for implementing the methods <code>keyPressed</code>, <code>keyReleased</code>, and <code>keyTyped</code>. We are only interested to the case in which the keyboard is pressed, so we can leave empty the methods <code>keyReleased</code> and <code>keyTyped</code>. Let's create the class <code>KeyboardListener</code>, which implements the interface <code>KeyListener</code>. The class receives as parameter a <code>Avatar</code> object, and the action event manager has to shift it.</p>

<pre class="sh_java">
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class KeyboardListener implements KeyListener {

    private Avatar avatar;

    public KeyboardListener(Avatar avatar) {
        this.avatar = avatar;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            avatar.move(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            avatar.move(5, 0);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>The method <code>keyPressed</code> receives as parameter an instance of <code>KeyEvent</code> from the user interface. The KeyEvent object knows the number related to the pressed key thanks to its method <code>getKeycode()</code>. Different keys have got different class variables in the <code>KeyEvent</code> class; for instance, the left arrow is <code>KeyEvent.VK_LEFT</code>.</p>

<p>We want to listen to the keystrokes directed to our user interface (we don't want to write to the text field, for instance), and therefore we assign our keyboard listener to the <code>JFrame</code> instance. Let's modify our user interface and add the keyboard listener to the JFrame object.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        DrawingBoard drawingBoard = new DrawingBoard(avatar);
        container.add(drawingBoard);

        frame.addKeyListener(new KeyboardListener(avatar));
    }
</pre>

<p>Our application now listens to keystrokes, and it leads them to the instance of the class <code>KeyboardListener</code>.</p>

<p>However, when we try out our user interface it does not work: the avatar does not move on the screen. What is the problem, in fact? We can check the keystrokes which are received by our <code>KeyboardListener</code> by adding a text printout to the beginning of our <code>keyPressed</code> method.</p>

<pre class="sh_java">
    @Override
    public void keyPressed(KeyEvent e) {
        System.out.println("Keystroke " + e.getKeyCode() +  " pressed.");

        // ...
</pre>

<p>If we start our program and press some keys we will notice the following output.</p>

<pre>
Keystroke 39 pressed.
Keystroke 37 pressed.
Keystroke 40 pressed.
Keystroke 38 pressed.
</pre>

<p>In fact, our keyboard listener works, but our drawing board does not update.</p>

<h3>Drawing Board Repainting</h3>

<p>User interface components usually have the functionality to repaint the component outer face, when needed. For instance, when we press the button, the instance of the class <code>JButton</code> is able to paint the button as if it was pressed, and to paint it normal again afterwards. The drawing board we have implemented does not have a pre-made update functionality; instead, we have to ask our drawing board to paint itself again when needed.</p>

<p>Each subclass of <code>Component</code> has the method <code>public void repaint()</code>, which repaints the component after it is called. We want that our <code>DrawingBoard</code> object would get repainted while the avatar moves. The avatar moves in the class <code>KeyboardListener</code>, and it is logic the repainting would happen there, too.</p>

<p>In order to be repainted, our keyboard listener needs a drawing board reference. Let's modify our class <code>KeyboardListener</code>, so that it would receive as parameter both an <code>Avatar</code> object and the <code>Component</code> object to repaint. We call the <code>repaint</code> method of the <code>Component</code> object after each <code>keyPressed</code> action event.</p>

<pre class="sh_java">
import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class KeyboardListener implements KeyListener {

    private Component component;
    private Avatar avatar;

    public KeyboardListener(Avatar avatar, Component component) {
        this.avatar = avatar;
        this.component = component;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            avatar.move(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            avatar.move(5, 0);
        }

        component.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Let's also modify the <code>createComponents</code> method of <code>UserInterface</code> and give an instance of <code>DrawingBoard</code> as parameter to our keyboard listener.</p>

<pre class="sh_java">
    private void createComponents(Container container) {
        DrawingBoard drawingBoard = new DrawingBoard(hahmo);
        container.add(drawingBoard);

        frame.addKeyListener(new KeyboardListener(avatar, drawingBoard));
    }
</pre>

<p>Now, our avatar's moves are visible also in the user interface. Whenever the user presses the keyboard, the user interface keyboard listener handles the call. At the end of each call, the <code>repaint</code> method of our drawing board is called, and the drawing board gets repainted.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/drawingboard-avatar-movement.png"/></p>

<div class="tehtavat">
    <div class="tehtava">
<h3>A Moving Figure</h3>

<p>We create a program which allows the user to move the figures drawn on a board using their keyboard. Together with the program you find the body of a user interface, which you can modify as your program proceeds.</p>

<p>At first, we create a couple of classes to manage the figures. Later on we will be able to draw the figures to our board. Create all the classes of the program in the package <code>movingfigure</code>.</p>

<p>In this exercise we make use of both inheritance and abstract classes: go back to sections 18.1, 18.2, and 18.5, if you need.</p>

<h4 class="req">Figure: an Abstract Class</h4>

<p>Create the abstract class <code>Figure</code>. Figures have the object variables <code>x</code> and <code>y</code>, which tell the figure position on the board; they also have the method <code>public void move(int dx, int dy)</code>, which moves the figures according to the parameter coordinate movements. For instance, if the position is  (100,100), at the beginning, after calling the method <code>move(10,-50)</code> the position will be (110,50). The class constructor <code>public Figure(int x, int y)</code> has to define the original position of the figure. Additionally, implement also the methods <code>public int getX()</code> and <code>public int getY()</code>.</p>

<p>The class also has to have the abstract method <code>public abstract void draw(Graphics graphics)</code>, which draws the figure on the drawing board. The figure drawing method is implemented in the classes which inherit <code>Figure</code>.</p>

<h4 class="req">Circle</h4>

<p>Create the class <code>Circle</code> which inherits Figure. Circle has a <code>diameter</code>, whose value is defined by the constructor <code>public Circle(int x, int y, int diameter)</code>. The Circle position is stored into the object variables defined in its parent class.
</p>

<p>The circle defines the method <code>draw</code> so that it would draw a circle of the right size, in the place defined by the coordinates, and using the method <code>fillOval</code> of the <code>Graphics</code> object; the first two parameters of the method are taken for the position of the circle. Take example from the relative method in the Avatar example. For more information about the methods of Graphics objects, you can have a look at <a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html">Java's API.</a>
</p>

<h4 class="req">Drawing Board</h4>

<p>Create the class <code>DrawingBoard</code> which inherits <code>JPanel</code>; you can take example from the drawing board in the previous exercise, for instance. DrawingBoard receives a <code>Figure</code> object as parameter. Override <code>JPanel</code>'s method <code>protected void paintComponent(Graphics g)</code> so that it first calls the superclass' <code>paintComponent</code> method, and then the <code>draw</code> method of the figure which was assigned to the drawing board.</p>

<p>Modify the class <code>UserInterface</code> so that it would receive a <code>Figure</code> object as constructor parameter. Assign your DrawingBoard to the user interface together with the <code>createComponents(Container container)</code> method, and assign to the drawing board the figure which was given to the user interface as constructor parameter.</p>

<p>Finally, test that the following sample code draws a circle on the screen.</p>

<pre class="sh_java">
        UserInterface ui = new UserInterface(new Circle(50, 50, 250));
        SwingUtilities.invokeLater(ui);
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/moving-circle.png"/></p>


        <h4 class="req">Keyboard Listener</h4>

<p>Let's extend our drawing board, so that we could move the figures using our keyboard arrows. Create the class <code>KeyboardListener</code> which implements the interface <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code>. The class <code>KeyboardListener</code> has two constructor parameters: an instance of the class <code>Component</code> and one of the class <code>Figure</code>.</p>

<p>The instance of Component is given to the keyboard listener so that the component would be updated each time the keyboard is pressed. The component is updated with the method call <code>repaint</code>, which is inherited from he class <code>Component</code>. The type of the class DrawingBoard is <code>Component</code>, because <code>Component</code> is the upper class of the class which inherits <code>JPanel</code>.</p>

<p>Implement the method <code>keyPressed(KeyEvent e)</code> of the interface <code>KeyListener</code>; when the user presses the left arrow, the figure moves one point left. Pressing right, the figure moves one point right. Pressing up it moves one point up, and pressing down the figure moves one point down. Note that the y axe grows from the upper side of the window downwards. The arrow key codes are <code>KeyEvent.VK_LEFT</code>, <code>KeyEvent.VK_RIGHT</code>, <code>KeyEvent.VK_UP</code>, and <code>KeyEvent.VK_DOWN</code>. Leave empty the other methods required by the interface <code>KeyListener</code>.</p>

<p>Always call class Component's method <code>repaint</code> in the end of keylistener event.</p>

<p>Add keylistener in the UserInterface's method <code>addListeners</code>. KeyListener must be connected to <code>JFrame</code>-object.</p>


        <h4 class="req">Square and Box</h4>


<p>Let <code>Square</code> and <code>Box</code> inherit the class <code>Figure</code>. Square has the constructor <code>public Square(int x, int y, int sideLength)</code>; the constructor of box is <code>public Box(int x, int y, int width, int height)</code>. Use the method <code>fillRect</code> of a graphic object to draw the figures.</p>

<p>Make sure that squares and boxes are drawn and move right on the DrawingBoard.</p>

<pre class="sh_java">
        UserInterface ui = new UserInterface(new Square(50, 50, 250));
        SwingUtilities.invokeLater(ui);
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/moving-box.png"/></p>

<pre class="sh_java">
        UserInterface ui = new UserInterface(new Box(50, 50, 100, 300));
        SwingUtilities.invokeLater(ui);
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/moving-box2.png"/></p>

        <h4 class="req">Compound Figure</h4>

        <p>Let <code>CompoundFigure</code> inherit <code>Figure</code>. Compound figure contains other figures which are stored in an ArrayList. CompoundFigure has the method <code>public void add(Figure f)</code>, which adds a new Figure object to the compound figure. Compound figures do not have their own position, and it is not important what values are assigned to x and y coordinates. Compound figures draw themselves by asking their parts to draw themselves; the same thing happens when a compound figure moves. This means that the inherited method <code>move</code> has to be overwritten!</p>

        <p>You can test whether your compound figure moves and is drawn well using the following code:</p>

<pre class="sh_java">
        CompoundFigure truck = new CompoundFigure();

        truck.add(new Box(220, 110, 75, 100));
        truck.add(new Box(80, 120, 200, 100));
        truck.add(new Circle(100, 200, 50));
        truck.add(new Circle(220, 200, 50));

        UserInterface ui = new UserInterface(truck);
        SwingUtilities.invokeLater(ui);
</pre>


    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/moving-car.png"/></p>


        <p>Note how the <b>object responsibilities are shared here</b>. Each Figure is in charge of drawing and moving itself. Simple figures all move in the same way. Each simple figure has to manage their own drawing themselves. Compound figures move by asking their parts to move, and the same thing happens when it comes to be drawn. The drawing board knows a Figure object which, in fact, can be whatever simple figure or a compound figure: they are all drawn and moved in the same way. In fact, the drawing board works correctly regardless of the real type of the figure; the drawing board does not have to know the details of the figure. When the drawing board calls the method <code>draw</code> or <code>move</code> of the figure, the method of the real type of the figure is called, thanks to <b>polymorphism</b>.</p>

        <p>It's worth to notice that CompoundFigure can contain whatever Figure object, even another CompoundFigure! The class structure allows for highly complex figure formations, whereas figures move and draw themselves always in the same way.</p>

        <p>The class structure can also be expanded easily; for instance, a compound figure would work without needing changes even if we created new types which inherit Figure (say Triangle, Point, Line, exc.), and the same thing would apply to the drawing board and user interface.</p>

</div>
</div>

<h3>Pre-made Application Frameworks</h3>

<p>An application framework is a program which provides a baseline and a set of features to implement a particular application. One way to create an application framework is to create a class which provides pre-made features, so that classes can inherit it and build a particular application. Application frameworks are usually wide, and they are thought for a special purpose, for instance to program games or develop web-applications. Let's quickly get acquainted with a pre-made application library, by greating the application logic of a Game of Life.</p>

<div class="tehtavat">
    <div class="tehtava">
<h3>Game of Life</h3>

<p>In this exercise, we implement the application logic of a Game of Life, inheriting a pre-made application body.The application body is in a library which has been added to the project singularly, and its source codes are not visible.</p>

<p><b>ATTENTION:</b> your task won't be extremely difficult, but the exercise descriptions may look a bit confusing, at first. Read the instruction carefully, or ask for help if you can't get started. The exercise is definitely worth of your energies, because the result is beautiful!</p>

<p>Game of Life is a simple "population simulator" which was developed by the mathematician John Conway; see <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</a>.</p>

<p>Game of Life rules:</p>
<ul>
<li>Every living cell dies if they have less than two living neighbours.</li>
<li>Every living cell keeps on living during the following iteration (i.e. turn) if they have two or three living neighbours.</li>
<li>Every living cell dies if they have more than three living neighbours.</li>
<li>Every dead cell is turned back to life if they have exactly three living neighbours.</li>
</ul>

<p>The abstract class <code>GameOfLifeBoard</code> provides the following functionality</p>
<ul>
  <li><b>public GameOfLifeBoard(int length, int height)</b> creates a game board of the defined dimensions</li>
  <li><b>public boolean[][] getBoard()</b> provides access to the game board, which is a bidimensional table containing boolean values &ndash; as you may guess from the method return value! We come back to bidimensional boards later on when needed.</li>
  <li><b>public int getWidth()</b> returns the board width</li>
  <li><b>public int getHeight()</b> returns the board height</li>
  <li><b>public void playTurn()</b> simulates a turn of the game</li>
</ul>

<p>The class <code>GameOfLifeBoard</code> has also got the following abstract method, <b>which you will have to implement</b>.<p>

<ul>
  <li><b>public abstract void turnToLiving(int x, int y)</b> animates the cell whose coordinates are (x, y), that is to say it assigns the value <i>true</i> to it. If the coordinates are outside the board, nothing happens.</li>
  <li><b>public abstract void turnToDead(int x, int y)</b> kills the cell whose coordinates are (x, y), that is to say it assigns the value <i>false</i> to it. If the coordinates are outside the board, nothing happens.</li>
  <li><b>public abstract boolean isAlive(int x, int y)</b> tells whether the cell at (x, y) is alive. If the coordinates are outside the board, the method returns <i>false.</i></li>
  <li><b>public abstract void initiateRandomCells(double probabilityForEachCell)</b> initiates all the cells of the board: every cell is alive with a probability of <i>probabilityForEachCell.</i> The probability is a double value between [0, 1]. If a method is called with value 1, all the cells have to be alive. Accordingly, if the probability is 0, all the cells have to be dead.</li>
  <li><b>public abstract int getNumberOfLivingNeighbours(int x, int y)</b> tells the number of living neighbours for the cell at (x, y).</li>
  <li><b>public abstract void manageCell(int x, int y, int livingNeighbours)</b> managese the cell (x, y) according to the rules of the Game of Life.</li>
</ul>


<h4>GameOfLife implementation, Part 1</h4>

<p>Create the class <code>PersonalBoard</code> into the package <code>game</code>; PersonalBoard inherits the class <code>GameOfLifeBoard</code> which is in the package <code>gameoflife</code>. Note that the package <code>gameoflife</code> is not visible in your project, but it comes together with the class library. In the class <code>PersonalBoard</code>, implement the constructor <code>public PersonalBoard(int width, int height)</code>, which calls the superclass constructor with the given parameters:</p>

<pre class="sh_java">
import gameoflife.GameOfLifeBoard;

public class PersonalBoard extends GameOfLifeBoard {

    public PersonalBoard(int width, int height) {
        super(width, height);
    }

    // ..
</pre>

<p>You can first replace all the abstract methods with non-abstract ones, which do not do anything particular anyway, so far. However, because the methods are not abstract, this class can create instances, differently than the abstract class GameOfLifeBoard.</p>

<p>Implement the following methods</p>
<ul>
  <li><b>public abstract void turnToLiving(int x, int y)</b> animates the cell whose coordinates are (x, y), that is to say it assigns the value <i>true</i> to it. If the coordinates are outside the board, nothing happens.</li>
  <li><b>public abstract void turnToDead(int x, int y)</b> kills the cell whose coordinates are (x, y), that is to say it assigns the value <i>false</i> to it. If the coordinates are outside the board, nothing happens.</li>
  <li><b>public abstract boolean isAlive(int x, int y)</b> tells whether the cell at (x, y) is alive. If the coordinates are outside the board, the method returns <i>false.</i></li>
</ul>

<p><b>Hint:</b> You have access to the bidimensional table of the superclass through the superclass method <code>getBoard()</code>. Bidimensional tables are used as normal tables, but they are assigned two indexes. The first index tells

the row

and the second tells

the column. For instance, the following program chunk creates a 10 x 10 table, and prints the value at (3,1).</p>

<pre class="sh_java">
boolean[][] values = new boolean[10][10];
System.out.println(values[3][1]);
</pre>

<p>Accordingly, we can print the value at (x,y) of our PersonalBoard's superclass, in the following way:</p>

<pre class="sh_java">
boolean[][] board = getBoard();
System.out.println(board[x][y]);
</pre>

<p>And an index (x,y) can be assigned a value in the following way:</p>

<pre class="sh_java">
boolean[][] board = getBoard();
board[x][y] = true;
</pre>

<p>Or straight, using a helping variable:</p>

<pre class="sh_java">
getBoard()[x][y] = true;
</pre>


<p>Test your implementation with the following program.</p>
<pre class="sh_java">
package game;

public class Main {
    public static void main(String[] args) {
        PersonalBoard board = new PersonalBoard(7, 5);

        board.turnToLiving(2, 0);
        board.turnToLiving(4, 0);

        board.turnToLiving(3, 3);
        board.turnToLiving(3, 3);

        board.turnToLiving(0, 2);
        board.turnToLiving(1, 3);
        board.turnToLiving(2, 3);
        board.turnToLiving(3, 3);
        board.turnToLiving(4, 3);
        board.turnToLiving(5, 3);
        board.turnToLiving(6, 2);

        GameOfLifeTester tester = new GameOfLifeTester(board);
        tester.play();
    }
}
</pre>
<p>

The output should look like the following:

<pre>
Press enter to continue, otherwise quit: &lt;enter&gt;

  X X

X     X
 XXXXX

Press enter to continue, otherwise quit: <font color="red">stop</font>
Thanks!
</pre>
<p>

<h4>GameOfLife implementation, Part 2</h4>

<p>Implement the method <b>public abstract void initiateRandomCells(double probabilityForEachCell)</b> initiates all the cells of the board: every cell is alive with a probability of <i>probabilityForEachCell.</i> The probability is a double value between [0, 1]. </p>

<p>Test the method. Given the value 0.0, there should be no cell alive; given the value 1.0, all the cells should be alive (i.e. visible in the form of X characters). With the value 0.5, around fifty precent of the cells should be alive.</p>

<pre class="sh_java">
        PersonalBoard board = new PersonalBoard(3, 3);
        board.initiateRandomCells(1.0);

        GameOfLifeTester tester = new GameOfLifeTester(board);
        tester.play();
</pre>

<pre>
Press enter to continue, otherwise quit: &lt;enter&gt;

XXX
XXX
XXX
Press enter to continue, otherwise quit: <font color="red">stop</font>
Thanks!
</pre>


<h4>GameOfLife Implementation, part 3</h4>

<p>Implement the method <b>getNumberOfLivingNeighbours(int x, int y),</b> which calculates the number of neighbour cells which are alive. Central cells have eight neighbours, the ones on the side have five, and the ones in the corner have only three. </p>

<p>Test the method with the following sentences (of course, you can create your own test instances!):</p>

<pre class="sh_java">
PersonalBoard board = new PersonalBoard(7, 5);

board.turnToLiving(0, 1);
board.turnToLiving(1, 0);
board.turnToLiving(1, 2);
board.turnToLiving(2, 2);
board.turnToLiving(2, 1);

System.out.println("Neighbours alive (0,0): " + board.getNumberOfLivingNeighbours(0, 0));
System.out.println("Neighbours alive (1,1): " + board.getNumberOfLivingNeighbours(1, 1));
</pre>
<p>

The print output should look like the following:
<pre>
Neighbours alive (0,0): 2
Neighbours alive (1,1): 5
</pre>


<h4>GameOfLife Implementation, Part 4</h4>

<p>Only one method is missing: <b>manageCell(int x, int y, int livingNeighbours)</b>. Game of Life rules were the following:</p>

<ul>
<li>Every living cell dies if they have less than two living neighbours.</li>
<li>Every living cell keeps on living during the following iteration (i.e. turn) if they have two or three living neighbours.</li>
<li>Every living cell dies if they have more than three living neighbours.</li>
<li>Every dead cell is turned back to life if they have exactly three living neighbours.</li>
</ul>

<p>Implement the method <code>manageCell(int x, int y, int livingNeighbours)</code> according to the following rules. It's good to program and test one rule at one time!</p>

<p>When you are done with all the rule, you can test the program with the following graphic simulator.</p>

<pre class="sh_java">
package game;

import gameoflife.Simulator;

public class Main {

    public static void main(String[] args) {
        PersonalBoard board = new PersonalBoard(100, 100);
        board.initiateRandomCells(0.7);

        Simulator simulator = new Simulator(board);
        simulator.simulate();
    }
}
</pre>

</div>
</div>
</div>
The material continues here: <a href="http://mooc.cs.helsinki.fi/programming-part2/material/week-12">Week 6</a>
</section>


<section class="viikkoraja" id="6" >
  <div class="viikkoraja">Week6</div>
  <div class="viikkoraja-mooc" id="Week 12" deadline="unlocks when 85% of week 11 done " data-first-chapter-index="53" data-first-exercise-index="151" data-first-week-index="12"  data-first-chapter-index-mooc="53" data-first-exercise-index-mooc="151" data-first-week-index-mooc="12" tekija="Arto Vihavainen, Matti Luukkainen">

<h2>Some Useful Techniques</h2>

<p>Before the course comes to its end, we can still have a look at some useful particular features of Java.</p>

<h3>Regular Expressions</h3>

<p>A regular expression is a compact form to define a string. Regular expressions are often used to check the validity of strings. Let's have a look at an exercise where we have to check whether the student number given by the user is written in the valid form or not. Finnish student numbers start with the string "01" which is followed by seven numerical digits from 0 to 9.</p>

<p>We can check the validity of a student number parsing its each character with the help of the method <code>charAt</code>. Another way would be checking whether the first character is "0", and using the method <code>Integer.parseInt</code> to translate the string into a number. Then, we could check whether that number is smaller than 20000000.</p>

<p>Validity check with the help of regular expressions requires we define a suitable regular expression. Then we can use the <code>matches</code> method of the class <code>String</code>, which checks whether the string matches with the regular expression in parameter. In the case of a student number, a suitable regular expression is <code>"01[0-9]{7}"</code>, and you can check the validity of what the user has input in the following way:</p>

<pre class="sh_java">
System.out.print("Give student number: ");
String num = reader.nextLine();

if (num.matches("01[0-9]{7}")) {
    System.out.println("The form is valid.");
} else {
    System.out.println("The form is not valid.");
}
</pre>

<p>Next, we can go through the most commonly used regular expressions.</p>

<h4>Vertical Bar: Logical <em>or</em></h4>

<p>The vertical bar means that the parts of the regular expression are optional. For instance, the expression <code>00|111|0000</code> defines the strings <code>00</code>, <code>111</code> and <code>0000</code>. The method <code>matches</code> returns <code>true</code> if the string matches one of the alternatives defined.</p>

<pre class="sh_java">
    String string = "00";

    if(string.matches("00|111|0000")) {
        System.out.println("The string was matched by some of the alternatives");
    } else {
        System.out.println("The string not was matched by any of the alternatives");
    }
</pre>

<pre>
The string was matched by some of the alternatives
</pre>

<p>The regular expression <code>00|111|0000</code> requires the exactly same form of the string: its functionality is not like <em>"contains"</em>.</p>

<pre class="sh_java">
    String string = "1111";

    if(string.matches("00|111|0000")) {
        System.out.println("The string was matched by some of the alternatives");
    } else {
        System.out.println("The string not was matched by any of the alternatives");
    }
</pre>

<pre>
The string not was matched by any of the alternatives
</pre>

<h4>Round Brackets: a Delimited Part of the String</h4>

<p>With the help of round brackets it is possible to define what part of the regular expression is affected by the symbols. If we want to allow for the alternatives <code>00000</code> and <code>00001</code>, we can define it with the help of a vertical bar: <code>00000|00001</code>. Thanks to round brakers we can delimit the choice to only a part of the string. The expression <code>0000(0|1)</code> defines the strings <code>00000</code> and <code>00001</code>.</p>

<p>Accordingly, the regular expression <code>look(|s|ed)</code> defines the basic form of the verb to look (look), the third person (looks), and the past (looked).</p>


<pre class="sh_java">
System.out.print("Write a form of the verb to look: ");
String word = reader.nextLine();

if (word.matches("look(|s|ed|ing|er)")) {
    System.out.println("Well done!");
} else {
    System.out.println("Check again the form.");
}
</pre>

<h4>Repetitions</h4>

<p>We often want to know whether a substring repeats within another string. In regular expressions, we can use repetition symbols:</p>

<ul>
<li>The symbol <strong><code>*</code></strong> stands for a repetition from 0 to n times, for instance<br/>
<pre class="sh_java">
    String string = "trolololololo";

    if(string.matches("trolo(lo)*")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</pre>

<pre>
The form is right.
</pre>
</li>

<li>The symbol <strong><code>+</code></strong> stands for a repetition from 1 to n times, for instance<br/>
<pre class="sh_java">
    String string = "trolololololo";

    if(characterString.matches("tro(lo)+")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</pre>

<pre>
The form is right.
</pre>

<pre class="sh_java">
    String characterString = "nÃ¤nÃ¤nÃ¤nÃ¤nÃ¤nÃ¤nÃ¤nÃ¤ BÃ¤tmÃ¤Ã¤n!";

    if(characterString.matches("(nÃ¤)+ BÃ¤tmÃ¤Ã¤n!")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</pre>

<pre>
The form is right.
</pre>
</li>

<li>The symbol <strong><code>?</code></strong> stands for a repetition of 0 or 1 time, for instance<br/>
<pre class="sh_java">
    String string = "You have accidentally the whole name";

    if(characterString.matches("You have accidentally (deleted )?the whole name")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</pre>

<pre>
The form is right.
</pre>
</li>

<li>The symbol <strong><code>{a}</code></strong> stands for a repetition of <code>a</code> times, for instance<br/>
<pre class="sh_java">
    String string = "1010";

    if(string.matches("(10){2}")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</pre>

<pre>
The form is right.
</pre>
</li>

<li>The symbol <strong><code>{a,b}</code></strong> stands for a repetition from <code>a</code> to <code>b</code> times, for instance<br/>
<pre class="sh_java">
    String string = "1";

    if(string.matches("1{2,4}")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</pre>

<pre>
The form is wrong.
</pre>
</li>

<li>The symbol <strong><code>{a,}</code></strong> stands for a repetition from <code>a</code> to n times, for instance<br/>
<pre class="sh_java">
    String string = "11111";

    if(string.matches("1{2,}")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</pre>

<pre>
The form is right.
</pre>
</li>
</ul>

<p>You can also use various different repetition symbols within one regular expression. For instance, the regular expression <code>5{3}(1|0)*5{3}</code> defines strings which start and end with three fives. In between there can be an indefinite number of 1 and 0.</p>

<h4>Square Brackets: Character Groups</h4>

<p>With the help of square brackets we can quickly define groups of characters. The characters are written inside the brackets, and we can define an interval with the help of a hyphen (-). For instance, <code>[145]</code> means the same as <code>(1|4|5)</code>, whereas <code>[2-36-9]</code> means the same as <code>(2|3|6|7|8|9)</code>. Accordingly, <code>[a-c]*</code> defines a regular expression with a string made only of characters <code>a</code>, <code>b</code> and <code>c</code>.</p>

<div class="tehtavat">
    <div class="tehtava">
<h3>Regular Expressions</h3>

<p>Let's train to use regular expressions. The exercises are done in the <code>Main</code> class of the default package .</h3>

<h4 class="req">Week Days</h4>

<p>Create the method <code>public static boolean isAWeekDay(String string)</code> in the class <code>Main</code>, using regular expressions. The method returns <code>true</code> if its parameter string is the abbreviation of a week day (mon, tue, wed, thu, fri, sat or sun).</p>

<p>The following is a sample print output of the method:</p>

<pre>
Give a string: <font color="red">tue</font>
The form is fine.
</pre>

<pre>
Give a string: <font color="red">abc</font>
The form is wrong.
</pre>

<h4 class="req">Vowel Inspection</h4>

<p>Create the method <code>public static boolean allVowels(String string)</code> in the class <code>Main</code>, which makes use of regular expressions and checks whether the String argument contains only vowel characters. </p>

<p>The following is a sample print output of the method:</p>

<pre>
Give a string: <font color="red">aie</font>
The form is fine.
</pre>

<pre>
Give a string: <font color="red">ane</font>
The form is wrong.
</pre>

<h4 class="req">Clock Time</h4>

<p>Regual expressions suit in particular situations. In some cases, the expressions become too complicate and it may be useful to check the "regularity" of a string in a different way, or it may be appropriate to use regular expressions to manage only a part of the inspection.</p>

<p>Create the method <code>public static boolean clockTime(String string)</code> in the class <code>Main</code>, which makes use of regular expressions and checks whether the String argument conforms with the clock time <code>hh:mm:ss</code> (two-digit hours, minutes, and seconds). In this exercise you can use whatever tecnique, in addition to regular expressions.</p>

<p>The following is a sample print output of the method:</p>

<pre>
Give a string: <font color="red">17:23:05</font>
The form is fine.
</pre>

<pre>
Give a string: <font color="red">abc</font>
The form is wrong.
</pre>

<pre>
Give a string: <font color="red">33:33:33</font>
The form is wrong.
</pre>

</div>
</div>


<h3>Enum: Enumerated Type</h3>

<p>Previously, we implemented the class <code>Card</code> which represented a playing card:</p>

<pre class="sh_java">
public class Card {

    public static final int DIAMONDS = 0;
    public static final int SPADES = 1;
    public static final int CLUBS = 2;
    public static final int HEARTS = 3;

    private int value;
    private int suit;

    public Card(int value, int suit) {
        this.value = value;
        this.suit = suit;
    }

    @Override
    public String toString() {
        return suitName() + " "+value;
    }

    private String suitName() {
        if (suit == 0) {
            return "DIAMONDS";
        } else if (suit == 1) {
            return  "SPADES";
        } else if (suit == 2) {
            return "CLUBS";
        }
        return "HEARTS";
    }

    public int getSuit() {
        return suit;
    }
}
</pre>

<p>The card suit is stored as object variable integer. Indicating the suit is made easier by constants which help the legibility. The constants which represent cards and suits are used in the following way:</p>

<pre class="sh_java">
public static void main(String[] args) {
        Card card = new Card(10, Card.HEARTS);

        System.out.println(card);

        if (card.getSuit() == Card.CLUBS) {
            System.out.println("It's clubs");
        } else {
            System.out.println("It's not clubs");
        }

}
</pre>

<p>Representing the suit as a number is a bad solution, because the following absurd ways to use cards are possible:</p>

<pre class="sh_java">
        Card absurdCard = new Card(10, 55);

        System.out.println(absurdCard);

        if (absurdCard.getSuit() == 34) {
            System.out.println("The card's suit is 34");
        } else {
            System.out.println("The card's suit is not 34");
        }

        int suitPower2 = absurdCard.getSuit() * absurdCard.getSuit();

        System.out.println("The card's suit raised to the power of two is " + suitPower2);
</pre>

<p>If we already know the possible values of our variables, we can use a <code>enum</code> class to represent them: an enumerated type. In addition to being classes and interfaces, enumerated types are also a class type of their own. Enumerated types are defined with the keyword <code>enum</code>. For instance the following <code>Suit</code> enum class defines four values: <code>DIAMONDS</code>, <code>SPADES</code>, <code>CLUBS</code> and <code>HEARTS</code>.</p>

<pre class="sh_java">
public enum Suit {
    DIAMONDS, SPADES, CLUBS, HEARTS
}
</pre>

<p>In its most basic from, <code>enum</code> lists its constant values divided by a comma. Enum constants are usually written in capital letters.</p>

<p>Enums are usually created in their own file, in the same way as classes and interfaces. In Netbeans, you can create a enum by clicking to <em>new/other/java/java enum</em> on your project name. </p>

<p>The following <code>Card</code> class is represented with the help of enum:</p>

<pre class="sh_java">
public class Card {

    private int value;
    private Suit suit;

    public Card(int value, Suit suit) {
        this.value = value;
        this.suit = suit;
    }

    @Override
    public String toString() {
        return suit + " "+value;
    }

    public Suit getSuit() {
        return suit;
    }

    public int getValue() {
        return value;
    }
}
</pre>

<p>The new version of the card is used in the following way:</p>

<pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Card first = new Card(10, Suit.HEARTS);

        System.out.println(first);

        if (first.getSuit() == Suit.CLUBS) {
            System.out.println("It's clubs");
        } else {
            System.out.println("It's not clubs");
        }

    }
}
</pre>

<p>Prints:</p>

<pre>
HEARTS 10
It's not clubs
</pre>

<p>We notice that enum names are printed smoothly! Because card suits' type is <code>Suit</code>, absurd practices like the one above -- raising a suit to the power of two -- do not work. Oracle has a tutorial for <code>enum</code> type at <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.</p>

<h3>Iterator</h3>

<p>Let's have a look at the following class <code>Hand</code> which represents the cards a player has in his hand in a card game:</p>

<pre class="sh_java">
public class Hand {
    private ArrayList&lt;Card&gt; cards;

    public Hand() {
        cards = new ArrayList&lt;Hand&gt;();
    }

    public void add(Card card){
        cards.add(card);
    }

    public void print(){
        for (Card card : cards) {
            System.out.println( card );
        }
    }
}
</pre>

<p>The <code>print</code> method prints each card in the hand by using a "for each" statement. ArrayList and other "object containers" which implement the <em>Collection</em> interface indirectly implement the interface <em>Iterable</em>. Objects which implement <em>Iterable</em> can be parses, or better "iterated", with statements such as for <em>each</em>.</p>

<p>Object containers can also be iterated using a so called <em>iterator</em>, that is an object, which was thought to parse a particular object collection. Below, there is a version of an iterator used to print cards:</p>

<pre class="sh_java">
public void print() {
    Iterator&lt;Card&gt; iterator = cards.iterator();

    while ( iterator.hasNext() ){
        System.out.println( iterator.next() );
    }
}
</pre>

<p>The iterator is taken from the ArrayList <code>cards</code>. The iterator is like a finger, which always points out a specific object of the list, from the first to the second, to the third, and so on, till the finger has gone through each object.</p>

<p>The iterator provides a couple of methods. The method <code>hasNext()</code> asks whether there are still objects to be iterated. If there are, we can retrieve the following object using the method <code>next()</code>. The method returns the following object in the collection, and makes the iterator -- the "finger" -- point out the following object.</p>

<p>The object reference returned by the Iterator's next() method can be stored into a variable, of course; in fact, we could modify the method <code>print</code> in the following way:</p>

<pre class="sh_java">
public void print(){
    Iterator&lt;Card&gt; iterator = cards.iterator();

    while ( iterator.hasNext() ){
        Card nextCard = iterator.next();
        System.out.println( nextCard );
    }
}
</pre>

<p>We can create a method to delete the cards which are smaller than a specific value:</p>

<pre class="sh_java">
public class Hand {
    // ...

    public void deleteWorst(int value) {
        for (Card card : cards) {
            if ( card.getValue() &lt; value ) {
                cards.remove(card);
            }
        }
    }
}
</pre>

<p>We notice that running the method causes a strange error:</p>

<pre>
Exception in thread "main" java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
        at java.util.AbstractList$Itr.next(AbstractList.java:343)
        at Hand.deleteWorst(Hand.java:26)
        at Main.main(Main.java:20)
Java Result: 1
</pre>

<p>The reason is that you can't delete objects from a list while you are parsing it: the for each statement "gets all worked up".</p>

<p>If we want to delete a part of the objects while we parse our list, we have to use an iterator. If we call the <code>remove</code> method of our iterator object, we can neatly delete the value which was returned by the iterator with its previous <code>next</code> method call. The following method works fine:</p>

<pre class="sh_java">
public class Hand {
    // ...

    public void deleteWorst(int value) {
        Iterator&lt;Card&gt; iterator = cards.iterator();

        while (iterator.hasNext()) {
            if (iterator.next().getValue() &lt; value) {
                // delete the object returned by the iterator with its previous method call
                iterator.remove();
            }
        }
    }
}
</pre>


<div class="tehtavat">
<div class="tehtava">

<h3>Enum and Iterator</h3>

<p>Let's create a program to manage the staff personnel of a small business.</p>

<h4>Education</h4>

<p>Create the enumerated type, or enum, <code>Education</code> in the package <code>personnel</code>. The enum has the titles <code>D</code> (doctor), <code>M</code> (master), <code>B</code> (bachelor), <code>GRAD</code> (graduate).</p>

<h4>Person</h4>

<p>Create the class <code>Person</code> in <code>personnel</code>. Person is assigned a name and an education title as constructor parameters. Person has also a method to communicate their education, <code>public Education getEducation()</code>, as well as a <code>toString</code> method which returns the person information following the example below.</p>

<pre class="sh_java">
    Person arto = new Person("Arto", Education.D);
    System.out.println(arto);
</pre>

<pre>
Arto, D
</pre>


<h4>Employees</h4>

<p>Create the class <code>Employees</code> in <code>personnel</code>. An Employees object contains a list of Person objects. The class has a parameterless constructor plus the following methods:</p>

<ul>
  <li><code>public void add(Person person)</code> adds the parameter person to the employees</li>
  <li><code>public void add(List&lt;Person&gt; persons)</code> adds the parameter list of people to the employees</li>
  <li><code>public void print()</code> prints all the employees</li>
  <li><code>public void print(Education education)</code> prints all the employees, who have the same education as the one specified as parameter</li>
</ul>

<p><strong>ATTENTION:</strong> The <code>Print</code> method of the class <code>Employees</code> have to be implemented using an iterator!</p>

<h4>Firing</h4>

<p>Create the method <code>public void fire(Education education)</code> in the class <code>Employees</code>. The method deletes all the employees whose education is the same as the method argument.</p>

<p><strong>ATTENTION:</strong> implement the method using an iterator!</p>

<p>Below, you find an example of the class usage:</p>

<pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Employees university = new Employees();
        university.add(new Person("Matti", Education.D));
        university.add(new Person("Pekka", Education.GRAD));
        university.add(new Person("Arto", Education.D));

        university.print();

        university.fire(Education.GRAD);

        System.out.println("==");

        university.print();
}
</pre>

<p>Prints:</p>

<pre>
Matti, D
Pekka, GRAD
Arto, D
==
Matti, D
Arto, D
</pre>

</div>
</div>

<h3>Loops and continue</h3>

<p>In addition to the <code>break</code> statement, loops have also got the <code>continue</code> statement, which allows you to skip to the following loop stage.</p>

<pre class="sh_java">
    List&lt;String&gt; names = Arrays.asList("Matti", "Pekka", "Arto");

    for(String name: names) {
        if (name.equals("Arto")) {
            continue;
        }

        System.out.println(name);
    }
</pre>

<pre>
Matti
Pekka
</pre>

<p>The <code>continue</code> statement is used especially when we know the iterable variables have got values with which we do not want to handle at all. The classic manner of approach would be using an if statement, but the <code>continue</code> statement allows for another approach to handle with the values, which avoids indentations and possibly helps readability. Below, you find two examples, where we go through the numbers of a list. If the number is smaller than 5 and contains 100, or if it contains 40, it is not printed; otherwise it is.</p>

<pre class="sh_java">
    List&lt;Integer&gt; values = Arrays.asList(1, 3, 11, 6, 120);

    for(int num: values) {
        if (num > 4 && num % 100 != 0 && num % 40 != 0) {
            System.out.println(num);
        }
    }

    for(int num: values) {
        if (num &lt; 5) {
            continue;
        }

        if (num % 100 == 0) {
            continue;
        }

        if (num % 40 == 0) {
            continue;
        }

        System.out.println(num);
    }
</pre>

<pre>
11
6
11
6
</pre>

<h3>More about Enums</h3>

<p>Next, we create enums which contain object variables and implement an interface.</p>

<h4>Enumerated Type Constructor Parameters</h4>

<p>Enumerated types can contain object variables. Object variable values have to be set up in the constructor of the class defined by enumerated type. Enum-type classes cannot have <code>public</code> constructors.</p>

<pre class="sh_java">
public enum Colour {
    RED("red"), // the constructor parameters are defined as constant values when they are read
    GREEN("green"),
    BLUE("blue");

    private String name; // object variable

    private Colour(String name) { // constructor
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
</pre>

<p>The enumerated value <code>Colour</code> can be used in the following way:</p>
<pre class="sh_java">
    System.out.println(Colour.GREEN.getName());
</pre>

<pre>
green
</pre>


<div class="tehtavat">
<div class="tehtava">
<h3>Film Reference</h3>

<p>Recently, in October 2006 after arriving to Finland, <a href="https://signup.netflix.com/" target="_blank">Netflix</a> promised one million dollars to the person or group of people who developed a program, which would be 10% better than their own program. The challenge was met September 2009 (<a href="http://www.netflixprize.com/" target="_blank">http://www.netflixprize.com/</a>).</p>

<p>With this exercise, we create a program to recommend films. Below, you see how it should work:</p>

<pre class="sh_java">
    EvaluationRegister ratings = new EvaluationRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, theBridgesOfMadisonCounty, Rating.GOOD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.FINE);
    ratings.addRating(pekka, theBridgesOfMadisonCounty, Rating.BAD);
    ratings.addRating(pekka, eraserhead, Rating.MEDIOCRE);

    ratings.addRating(mikke, eraserhead, Rating.GOOD);


    Reference reference = new Reference(votes);
    System.out.println(thomas + "'s recommendation: " +
            reference.recommendFilm(thomas));
    System.out.println(mikke + "'s recommendation: " +
            reference.recommendFilm(mikke));
</pre>

<pre>
Thomas's recommendation: The Bridges of Madison County
Mikke's recommendation: Gone with the Wind
</pre>

<p>The program is able to recommend films both according to their common appraisal and according to the ratings given by a specific person. Let's start to build our program.</p>

<h4>Person and Film</h4>

<p>Create the package <code>reference.domain</code>, and there you add the classes <code>Person</code> and <code>Film</code>. Both classes have a public constructor <code>public <em>Class</em>(String name)</code>, as well as the method <code>public String getName()</code>, which returns the name received with the argument.</p>

<pre class="sh_java">
    Person p = new Person("Pekka");
    Film f = new Film("Eraserhead");

    System.out.println(p.getName() + " and " + f.getName());
</pre>

<pre>
Pekka and Eraserhead
</pre>

<p>Also add the method <code>public String toString()</code> which returns the name received with the argument, as well as the method <code>equals</code> and <code>hashCode</code>.</p>

<p>Override <code>equals</code> so that the equivalence is checked according to the object variable <code>name</code>. Look at the example in section 45.1. In Section 45.2 there are guidelines to override <code>hashCode</code> methods. At least, you'd better generate the HashCode automatically, following the instructions at the end of the section:</p>

<p>
<em>
NetBeans allows for the automatic creation of the <code>equals</code> and <code>hashCode</code> methods. From the menu Source -> Insert Code, you can choose <em>equals() and hashCode()</em>. After this, NetBeans asks which object variables the methods shall use.</em>
</p>

<p><strong>Attention:</strong> to help finding mistakes, you may want to implement toString methods to Person and Film, but the tests do not require them.</p>

<h4>Rating</h4>

<p>Create the enumerated type <code>Rating</code> in <code>reference.domain</code>. The enum class <code>Rating</code> has a public method <code>public int getValue()</code>, which returns the value of the rating. The value names and their grades have to be the following:</p>

<p>
<table style="padding-left:2em">
  <tr><th>Rating</th><th>Value</th></tr>
  <tr><td>BAD</td><td>-5</td></tr>
  <tr><td>MEDIOCRE</td><td>-3</td></tr>
  <tr><td>NOT_WATCHED</td><td>0</td></tr>
  <tr><td>NEUTRAL</td><td>1</td></tr>
  <tr><td>FINE</td><td>3</td></tr>
  <tr><td>GOOD</td><td>5</td></tr>
</table>
</p>

<p>The class could be used in the following way:</p>
<pre class="sh_java">
    Rating given = Rating.GOOD;
    System.out.println("Rating " + given + ", value " + given.getValue());
    given = Rating.NEUTRAL;
    System.out.println("Rating " + given + ", value " + given.getValue());
</pre>

<pre>
Rating GOOD, value 5
Rating NEUTRAL, value 1
</pre>

<h4>RatingRegister, Part 1</h4>

<p>Let's get started with the implementation necessary to store the ratings.</p>

<p>Create the class <code>RatingRegister</code> in the package <code>reference</code>; the class has the constructor <code>public RatingRegister()</code>, as well as the following methods:</p>

<ul>
  <li><code>public void addRating(Film film, Rating rating)</code> adds a new rating to the parameter film. The same film can have various same ratings.</li>
  <li><code>public List&lt;Rating&gt; getRatings(Film film)</code> returns a list of the ratings which were added in connection to a film.</li>
  <li><code>public Map&lt;Film, List&lt;Rating&gt;&gt; filmRatings()</code> returns a map whose keys are the evaluated films. Each film is associated to a list containing the ratings for that film.</li>
</ul>

<p>Test the methods with the following source code:</p>

<pre class="sh_java">
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");

    RatingRegister reg = new RatingRegister();
    reg.addRating(eraserhead, Rating.BAD);
    reg.addRating(eraserhead, Rating.BAD);
    reg.addRating(eraserhead, Rating.GOOD);

    reg.addRating(theBridgesOfMadisonCounty, Rating.GOOD);
    reg.addRating(theBridgesOfMadisonCounty, Rating.FINE);

    System.out.println("All ratings: " + reg.filmRatings());
    System.out.println("Ratings for Eraserhead: " + reg.getRatings(eraserhead));
</pre>

<pre>
All ratings: {The Bridges of Madison County=[GOOD, FINE], Eraserhead=[BAD, BAD, GOOD]}
Ratings for Eraserhead: [BAD, BAD, GOOD]
</pre>


<h4>RatingRegister, Part 2</h4>

<p>Let's make possible to add personal ratings.</p>

<p>Add the following methods to the class <code>RatingRegister</code>:</p>

<ul>
  <li><code>public void addRating(Person person, Film film, Rating rating)</code> adds the rating of a specific film to the parameter person. The same person can recommend a specific film only once. The person rating has also to be added to the ratings connected to all the films.</li>
  <li><code>public Rating getRating(Person person, Film film)</code> returns the rating the paramater person has assigned to the parameter film. If the person hasn't evaluated such film, the method returns <code>Rating.NOT_WATCHED</code>.</li>
 <li><code>public Map&lt;Film, Rating&gt; getPersonalRatings(Person person)</code> returns a HashMap which contains the person's ratings. The HashMap keys are the evaluated films, and their values are the ratings of these films.</li>
 <li><code>public List&lt;Person&gt; reviewers()</code> returns a list of the people who have evaluate the films.</li></ul>

<p>People's ratings should be stored into a HashMap, and the people should act as keys. The values of the HashMap is another HashMap, whose keys are films and whose values are ratings.</p>

<p>Test your improved <code>RatingRegister</code> with the following source code:</p>

<pre class="sh_java">
    RatingRegister ratings = new RatingRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film eraserhead = new Film("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.GOOD);
    ratings.addRating(pekka, eraserhead, Rating.GOOD);

    System.out.println("Ratings for Eraserhead: " + ratings.getRatings(eraserhead));
    System.out.println("Matti's ratings: " + ratings.getPersonalRatings(matti));
    System.out.println("Reviewers: " + ratings.reviewers());
</pre>

<pre>
Ratings for Eraserhead: [FINE, GOOD]
Matti's ratings: {Gone with the Wind=BAD, Eraserhead=FINE}
Reviewers: [Pekka, Matti]
</pre>

<p>Next, we create a couple of helping classes to help evaluation.</p>

<h4>PersonComparator</h4>

<p>Create the class <code>PersonComparator</code> in the package <code>reference.comparator</code>. The class <code>PersonComparator</code> has to implement the interface <code>Comparator&lt;Person&gt;</code>, and it has to have the constructor <code>public PersonComparator(Map&lt;Person, Integer&gt; peopleIdentities)</code>. The class <code>PersonComparator</code> is used later on to sort people according to their number.</p>

<p>Test the class with the following source code:</p>

<pre class="sh_java">
    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    Map&lt;Person, Integer&gt; peopleIdentities = new HashMap&lt;Person, Integer&gt;();
    peopleIdentities.put(matti, 42);
    peopleIdentities.put(pekka, 134);
    peopleIdentities.put(mikke, 8);
    peopleIdentities.put(thomas, 82);

    List&lt;Person&gt; ppl = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println("People before sorting: " + ppl);

    Collections.sort(ppl, new PersonComparator(peopleIdentities));
    System.out.println("People after sorting: " + ppl);
</pre>

<pre>
People before sorting: [Matti, Pekka, Mikke, Thomas]
People after sorting: [Pekka, Thomas, Matti, Mikke]
</pre>

<h4>FilmComparator</h4>


<p>Create the class <code>FilmComparator</code> in the package <code>reference.comparator</code>. The class <code>FilmComparator</code> has to implement the interface <code>Comparator&lt;Film&gt;</code>, and it has to have the constructor <code>public FilmComparator(Map&lt;Film, List&lt;Rating&gt;&gt; ratings)</code>. The class <code>FilmComparator</code> will be used later on to sort films according to their ratings.</p>

<p>The class FilmComparator has to allow for film sorting according to the average of the rating values they have received. The films with the greatest average should be placed first, and the ones with the smallest average should be the last.</p>

<p>Test the class with the following source code:</p>

<pre class="sh_java">
    RatingRegister ratings = new RatingRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, theBridgesOfMadisonCounty, Rating.GOOD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.FINE);
    ratings.addRating(pekka, theBridgesOfMadisonCounty, Rating.BAD);
    ratings.addRating(pekka, eraserhead, Rating.MEDIOCRE);

    ratings.addRating(mikke, eraserhead, Rating.BAD);

    Map&lt;Film, List&lt;Rating&gt;&gt; filmRatings = ratings.filmRatings();

    List&lt;Film&gt; films = Arrays.asList(goneWithTheWind, theBridgesOfMadisonCounty, eraserhead);
    System.out.println("The films before sorting: " + films);

    Collections.sort(films, new FilmComparator(filmRatings));
    System.out.println("The films after sorting: " + films);
</pre>

<pre>
The films before sorting: [Gone with the Wind, The Bridges of Madison County, Eraserhead]
The films after sorting: [The Bridges of Madison County, Gone with the Wind, Eraserhead]
</pre>


<h4>Reference, Part 1</h4>

<p>Implement the class <code>Reference</code> in the package <code>reference</code>. The class <code>Reference</code> receives a <code>RatingRegister</code> object as constructor parameter. Reference uses the ratings in the rating register to elaborate a recommendation.</p>

<p>Implement the method <code>public Film recommendFilm(Person person)</code>, which implements films to people. Hint: you need three things to find out the most suitable film. These are at least the class <code>FilmComparator</code> which you created earlier on; the method <code>public Map&lt;Film, List&lt;Rating&gt;&gt; filmRatings()</code> of the class <code>RatingRegister</code>; and a list of the existing films.</p>

<p>Test your program with the following source code:</p>

<pre class="sh_java">
    RatingRegister ratings = new RatingRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, theBridgesOfMadisonCounty, Rating.GOOD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.FINE);
    ratings.addRating(pekka, theBridgesOfMadisonCounty, Rating.BAD);
    ratings.addRating(pekka, eraserhead, Rating.MEDIOCRE);

    Reference ref = new Reference(ratings);
    Film recommended = ref.recommendFilm(mikke);
    System.out.println("The film recommended to Michael is: " + recommended);
</pre>

<pre>
The film recommended to Michael is: The Bridges of Madison County
</pre>

<p>Now, our first part works fine exclusively for people who have never evaluated any movie. In such cases, we can't say anything about their film tastes, and the best choice is recommending them the film which has received the hightest average among the ratings.</p>

<h4>Reference, Part 2</h4>

<p><em>Attention! The exercise is challenging. First you should do the previous exercises and coming back to this one later. You can return the sequence of exercises in TMC; even though you don't get the point for this part, you'd get the points for the perious ones, as it is with all the exercises.</em></p>

<p>Unfortunately, the error diagnostics of this part is not similar to the previous parts.</p>

<p>If people have added their own preferences to the reference service, we know something about their film tastes. Let's extend the functionality of our reference to create a personal recommendation if the person has evaluated films. The functionality implemented in the previous part has to be preserved: if a person hasn't evaluated any film, we recommend them a film according to film ratings.</p>

<p>Personal recommendations are based on the similarity between the person ratings and other people's ratings. Let's reason about it with the help of the following table; in the first line on the top there are films, and the people who have rated are on the left. The brackets describe the ratings given.</p>

<p>
    <table style="padding-left:2em">
      <tr><th>Person \ Film</th><td>Gone with the Wind</td><td>The Bridges of Madison County</td><td>Eraserhead</td><td>Blues Brothers</td></tr>
      <tr><td>Matti</td><td>BAD (-5)</td><td>GOOD (5)</td><td>FINE (3)</td><td>-</td></tr>
      <tr><td>Pekka</td><td>FINE (3)</td><td>-</td><td>BAD (-5)</td><td>MEDIOCRE (-3)</td></tr>
      <tr><td>Mikael</td><td>-</td><td>-</td><td>BAD (-5)</td><td>-</td></tr>
      <tr><td>Thomas</td><td>-</td><td>GOOD (5)</td><td>-</td><td>GOOD (5)</td></tr>
    </table>
</p>

<p>If we want to find the suitable film for Mikael, we can explore the similarity between Mikael's and other people's preferences. The similarity is calculated based on the ratings: as the sum of the products of the ratings for the films watched by both. For instance, Mikael and Thomas's similarity is 0, because they haven't watched the same films.</p>

<p>If we calculate Mikael and Pekka's similarity, we find out that the sum of the products of the films they have in common is 25. Mikael and Pekka have both watched only one film, and they have both given it the grade bad (-5).</p>

<pre>
-5 * -5 = 25
</pre>

<p>Mikael and Matti's similarity is -15. Mikael and Matti have also watched only one same film. Mikael gave the grade bad (-5) to the film, whereas Matti gave it the grade fine (3).</p>

<pre>
-5 * 3 = -15
</pre>

<p>Based on that Mikael can be recommended films according to Pekka's taste: the recommendation is Gone with the Wind.</p>


<p>On the other hand, if we want to find a suitable film for Matti, we have to find the similarity between Matti and everyone else. Matti and Pekka have watched two same films. Matti gave Gone with the Wind the grade bad (-5), Pekka the grade fine (3). Matti gave fine (3) to Eraserhead, and Pekka gave bad (-5). Matti and Pekka's similarity is -30.</p>

<pre>
-5 * 3 + 3 * -5 = -30
</pre>

<p>Matti and Mikael's similarity is -15, which we know according to out previous calculations. Similarities are symmetrical.</p>

<p>Matti and Thomas have watched Gone with the Wind, and they both gave it the grade good (5). Matti and Thomas's similarity is 25, then.</p>

<pre>
5 * 5 = 25
</pre>

<p>Matti has to be recommended a film according to Thomas' taste: the recommendation will be the Blues Brothers.</p>

<p>Implement the recommendation mechanism described above. The method <code>recommendFilm</code> should return <code>null</code> in two cases: if you cannot find any film to recommend; if you find a, say, person1 whose film taste is appropriate to recommend films to, say, person2, but person1 has rated bad, mediocre, or neutral, all the films person2 hasn't watched, yet. The approach described above has to work also if the person hasn't added any rating.</p>

<p>Do not suggest films which have already been watched.</p>

<p>You can test your program with the following source code:</p>

<pre class="sh_java">
    RatingRegister ratings = new RatingRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");
    Film bluesBrothers = new Film("Blues Brothers");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikael");
    Person thomas = new Person("Thomas");
    Person arto = new Person("Arto");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, theBridgesOfMadisonCounty, Rating.GOOD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.FINE);
    ratings.addRating(pekka, eraserhead, Rating.BAD);
    ratings.addRating(pekka, bluesBrothers, Rating.MEDIOCRE);

    ratings.addRating(mikke, eraserhead, Rating.BAD);

    ratings.addRating(thomas, bluesBrothers, Rating.GOOD);
    ratings.addRating(thomas, theBridgesOfMadisonCounty, Rating.GOOD);

    Reference ref = new Reference(ratings);
    System.out.println(thomas + " recommendation: " + ref.recommendFilm(thomas));
    System.out.println(mikke + " recommendation: " + ref.recommendFilm(mikke));
    System.out.println(matti + " recommendation: " + ref.recommendFilm(matti));
    System.out.println(arto + " recommendation: " + ref.recommendFilm(arto));
</pre>

<pre>
Thomas recommendation: Eraserhead
Mikael recommendation: Gone with the Wind
Matti recommendation: Blues Brothers
Arto recommendation: The Bridges of Madison County
</pre>

<p>Have we made one million bucks? Not yet, maybe. In the course Introduction to Artificial Intelligence and Machine Learning we learn more techniques to build learning programs.</p>

</div>
</div>

<h3>Variable Number of Method Parameters</h3>

<p>So far, we have been creating methods which had a clearly defined number of parameters. Java makes it possible to give an indefinite number of a specific type of parameters by placing an ellipsis after the parameter type. For instance the method <code>public int sum(int... values)</code> can be given as parameter as many integers (<code>int</code>) as the user wants. The parameter values can be handled as a table.</p>

<pre class="sh_java">
    public int sum(int... values) {
        int sum = 0;
        for (int i = 0; i &lt; values.length; i++) {
            sum += values[i];
        }
        return sum;
    }
</pre>

<pre class="sh_java">
    System.out.println(sum(3, 5, 7, 9));  // values = {3, 5, 7, 9}
    System.out.println(sum(1, 2));        // values = {1, 2}
</pre>

<pre>
24
3
</pre>

<p>Note that the parameter definition above <code>int... values</code> depends on the fact that the method has a table-like variable called <code>values</code>.</p>

<p>A method can be assigned only one parameter which receives an indefinite number of values, and this must be the first parameter in the method definition. For instance:</p>

<pre class="sh_java">
    public void print(String... characterStrings, int times) // right!
    public void print(int times, String... strings) // wrong!
</pre>

<p>An indefinite number of parameter values is used for instance when we want to create an interface which would not force the user to use a precise number of parameters. An alternative approach would be defining a list of that precise type as parameter. In this case, the objects can be assigned to the list before the method call, and the method can be called and given the list as parameter.</p>

<div class="tehtavat">
    <div class="tehtava">

<h3>Flexible Filtering Criteria</h3>

<p>In some exercises (see Library in Introduction to Programming, and Word Inspection in Advanced Programming), we have run into such situations where we had to filter out list objects according to particular criteria; for instance, in Word Inspection the methods <code>wordsContainingZ, wordsEndingInL, palindromes, wordsWhichContainAllVowels</code> all to the same same thing: they go through the file content one word after the other, and they make sure that the specific filtering criteria are satisfied, in which case they store the word. Because the method criteria are different, we haven't been able to get rid of this repetition, and the code of all those methods made wide use of copypaste.</p>

<p>With this exercise, we create a program to filter the lines of the books found on the <a href="">Project Guttenberg</a> pages. In the following example we analyze Dostojevski's Crime and Punishment. We want to have various different filtering criteria, and that it would be possible to filter according to different criteria combinations. The program structure should also allow for adding new criteria later on.</p>

<p>A suitable solution to the problem, is defining the filtering criteria as objects of their own which implement the interface <code>Criterion</code>. The interface definition is below:</p>

<pre class="sh_java">
public interface Criterion {
    boolean complies(String line);
}
</pre>

<p>A filtering class which implements the interface:</p>

<pre class="sh_java">
public class ContainsWord implements Criterion {

    String word;

    public ContainsWord(String word) {
        this.word = word;
    }

    @Override
    public boolean complies(String line) {
        return line.contains(word);
    }
}
</pre>

<p>The class objects are quite simple, in fact, and they only remember the word given as constructor parameter. The only method of the object can be asked whether the criterion complies to the parameter String; if so, this means that the object contains the word stored into the String object.</p>

<p>Together with the excercise body, you find the pre-made class <code>GutenbergReader</code>, which helps you to analyze book lines according to the filtering criteria given as parameter:</p>

<pre class="sh_java">
public class GutenbergReader {

    private List&lt;String&gt; lines;

    public GutenbergReader(String address) throws IllegalArgumentException {
        // the code which retrieves the book from the Internet
    }

    public List&lt;String&gt; linesWhichComplyWith(Criterion c){
        List&lt;String&gt; complyingLines = new ArrayList&lt;String&gt;();

        for (String line : lines) {
            if (c.complies(line)) {
                complyingLines.add(line);
            }
        }

        return complyingLines;
    }
}
</pre>

<p>With the following code, we print all the lines in Crime and Punishment which contain the word "beer":</p>

<pre class="sh_java">
public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion = new ContainsWord("beer");

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</pre>

<h4>All Lines</h4>

<p>Create the class <code>AllLines</code> which implements <code>Criterion</code>, which accepts all the lines. This and the other classes of the exercise have to be implemented in the package <code>reader.criteria</code>.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion = new AllLines();

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</pre>

<h4>Ends with Question or Exclamation Mark</h4>

<p>Implement class <code>EndsWithQuestionOrExclamationMark</code>, which implements the interface <code>Criterion</code> and accepts the lines whose last character is a question or an exclamation mark.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

     Criterion criterion = new EndsWithQuestionOrExclamationMark();

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</pre>

<p><strong>Reminder:</strong> you compare character in Java with the == operator:</p>

<pre class="sh_java">
String name = "pekka";

// ATTENTION: 'p' is a character, that is to say char p; differently, "p" is a String, whose only character is p
if ( name.charAt(0) == 'p' ) {
    System.out.println("beginning with p");
} else {
    System.out.println("beginning with something else than p");
}
</pre>

<h4>Length At Least</h4>

<p>Implement the class <code>LengthAtLeast</code>, which implements the interface <code>Criterion</code> and accepts the lines whose length is equal or greater than the number received as constructor parameter.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

     Criterion criterion = new LengthAtLeast(40);

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</pre>

<h4>Both</h4>

<p>Create the class <code>Both</code> which implements the interface <code>Criterion</code>. The objects of this class receive two objects as constructor parameter, both implementing the interface <code>Criterion</code>. <code>Both</code> objects accept the lines which comply with both the criteria received as constructor parameters. We print below all the lines which end with a question or an exclamation mark and that contain the word "beer".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion = new Both(
                    new EndsWithQuestionOrExclamationMark(),
                    new ContainsWord("beer")
                );

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</pre>

<h4>Negation</h4>

<p>Create the class <code>Not</code> which implement the interface <code>Criterion</code> and accepts the lines, which don't comply with the criterion received as parameter. We print below the lines whose length is less than 10.
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion = new Not( new LengthAtLeast(10) );

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</pre>

<h4>At Least One</h4>

<p>Create the class <code>AtLeastOne</code> which implements the interface <code>Criterion</code>. The objects of this class receive as parameter an optional amount of objects which implement the interface <code>Criterion</code>; this means that the constructor receives a list of variable length as parameter. <code>AtLeastOne</code> objects accept the lines which comply with at least one of the criteria received as constructor parameter. We print below the lines which contain one ot the words "beer", "milk" or "oil".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion =new AtLeastOne(
                    new ContainsWord("beer"),
                    new ContainsWord("milk"),
                    new ContainsWord("oil")
                );

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</pre>

<p>Note that the criteria can be combined as preferred. You find below a criterion which accepts the lines which have at least one of the words "beer", "milk" and "oil" and whose length is between 20-30 characters.</p>

<pre class="sh_java">
    Criterion words = new AtLeastOne(
                    new ContainsWord("beer"),
                    new ContainsWord("milk"),
                    new ContainsWord("oil")
                );

    Criterion rightLength = new Both(
                         new LengthAtLeast(20),
                         new Not( new LengthAtLeast(31))
                       );

    Criterion wanted = new Both(words, rightLength);
</pre>

</div>
</div>

<h3>StringBuilder</h3>

<p>We have got accustomed to building strings in the following way:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        int[] t = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(build(t));
    }

    public static String build(int[] t) {
        String str = "{";

        for (int i = 0; i &lt; t.length; i++) {
            str += t[i];
            if (i != t.length - 1) {
                str += ", ";

            }
        }

        return str + "}";
    }
</pre>

<p>Result:</p>

<pre>
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
</pre>

<p>This works, but it could be more effective. As we remember, strings are <em>immutable</em> objects. The result of a String operation is always a new String object. This means that in the interphases of previous example 10 String objects were created. If the dimension of the input was bigger, creating new objects in the various interphases would start to have an unpleasant impact on the program execution time.</p>

<div class="tehtavat">
  <div class="tehtava">
  <h3>String builder</h3>

  <p>In situations like the previous one, it is better to use <code>StringBuilder</code> objects when it comes to building strings. Differently from Strings, StringBuilders are not immutable, meaning StringBuilder-objects can be modified. Get acquainted with the description of the StringBuilder API (you'll find it by googling "stringbuilder java api 6") and modify the method in the exercise body, <code>public static String build(int[] t)</code>, so that it would use StringBuilder and work in the following way:</p>

  <pre>
{
1, 2, 3, 4,
5, 6, 7, 8,
9, 10
}
  </pre>

  <p>The curly brackets are on their own lines. There are up to four values in each line of the table, and the first value requires an initial space. Before each number, and after the comma there must be exactly one space.</p>

  </div>
</div>
<h2>Grande Finale</h2>

<p>The course is nearing the end, and it's time for the grande finale!</p>

<div class="tehtavat">
    <div class="tehtava">

<h3>Worm Game</h3>


<p>In this exercise, we create the structure and functionality for the following worm game. Unlike in the picture
   below, our worm game will be coloured differently: worm is black, apple is red and background is gray.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/week5/snakegame.png"/></p>

<h4>Piece and Apple</h4>

<p>Create the class <code>Piece</code> in <code>wormgame.domain</code>. The class <code>Piece</code> has the constructor <code>public Piece(int x, int y)</code>, which receives the position of the piece as parameter. Moreover, the class <code>Piece</code> has the following methods.</p>

<ul>
  <li><code>public int getX()</code> returns the x coordinate of the piece, which was assigned in the constructor.</li>
  <li><code>public int getY()</code> returns the y coordinate of the piece, which was assigned in the constructor.</li>
  <li><code>public boolean runsInto(Piece piece)</code> returns true if the object has the same coordinates as the Piece instance received as paramater.</li>
  <li><code>public String toString()</code> returns the piece position following the pattern <code>(x,y)</code>. For instance. <code>(5,2)</code> if the value of x is 5 and the value of y is 2.</li>
</ul>

<p>Also implement the class <code>Apple</code> in <code>wormgame.domain</code>, and let Apple inherit <code>Piece</code>.</p>


<h4>Worm </h4>

<p>Implement the class <code>Worm</code> in the package <code>wormgame.domain</code>. The class <code>Worm</code> has the constructor <code>public Worm(int originalX, int originalY, Direction originalDirection)</code>, which creates a new worm whose direction is the parameter <code>originalDirection</code>. Worm is composed of a list of instances of the class <code>Piece</code>. Attention: the pre-made enum <code>Direction</code> can be found in the package <code>wormgame</code>.</p>

<p>When it's created, Worm's length is one, but its "mature" length is three. Worm has to grow by one piece while it moves. When its length is three, Worm grows only by eating.</p>

<p>Implement the following methods</p>

<ul>
  <li><code>public Direction getDirection()</code> return's Worm's direction.</li>
  <li><code>public void setDirection(Direction dir)</code> sets a new direction for the worm. The worm starts to move in the new direction when the method <code>move</code> is called again.</li>
  <li><code>public int getLength()</code> returns the Worm's length. The Worm's length has to be equal to the length of the list returned by the method <code>getPieces()</code>.</li>
  <li><code>public List&lt;Piece&gt; getPieces()</code> returns a list of Piece objects which the worm is composed of. The pieces in the list are in order, with the worm head at the end of the list.</li>
  <li><code>public void move()</code> moves the worm one piece forward.</li>
  <li><code>public void grow()</code> grows the worm by one piece. The worm grows together with the following <code>move</code> method call; after the first move method call the worm does not grow any more.</li>
  <li><code>public boolean runsInto(Piece piece)</code> checks whether the worm runs into the parameter piece. If so -- that is, if a piece of the worm runs into the parameter piece -- the method returns the value <code>true</code>; otherwise it returns <code>false</code>.</li>
  <li><code>public boolean runsIntoItself()</code> check whether the worm runs into itself. If so -- that is, if one of the worm's pieces runs into another piece -- the method returns the value <code>true</code>. Otherwise it returns <code>false</code>.</li>
</ul>

<p>The functionality of <code>public void grow()</code> and <code>public void move()</code> has to be implemented so that the worm grows only with the following move.</p>

<p>Motion should be implemented in a way that the worm is always given a new piece. The position of the new piece depends on the moving direction: if moving left, the new piece location should on the left of the head piece, i.e. the x coordinate of the head should be smaller by one. If the location of the new piece is under the old head -- if the worm's direction is down, the y coordinate of the new piece should be by one bigger than the y coordinate of the head (when we draw, we will have to get accustometd to a coordinate system where the y axe is reverse).</p>

<p>When the worm moves, a new piece is added to the list, and the first piece is deleted from the beginning of the list. In this way, you don't need to update the coordinates of each single piece. Implement the growth so that the first piece is deleted if the <code>grow</code> method has just been called.</p>

<p>Attention! The worm has to grow constantly if its length is less than 3.</p>

<pre class="sh_java">
        Worm worm = new Worm(5, 5, Direction.RIGHT);
        System.out.println(worm.getPieces());
        worm.move();
        System.out.println(worm.getPieces());
        worm.move();
        System.out.println(worm.getPieces());
        worm.move();
        System.out.println(worm.getPieces());

        worm.grow();
        System.out.println(worm.getPieces());
        worm.move();
        System.out.println(worm.getPieces());

        worm.setDirection(Direction.LEFT);
        System.out.println(worm.runsIntoItself());
        worm.move();
        System.out.println(worm.runsIntoItself());
</pre>

<pre>
[(5,5)]
[(5,5), (6,5)]
[(5,5), (6,5), (7,5)]
[(6,5), (7,5), (8,5)]
[(6,5), (7,5), (8,5)]
[(6,5), (7,5), (8,5), (9,5)]
false
true
</pre>

<h4>Worm Game, Part 1</h4>

<p>Let's modify the class <code>WormGame</code> which is contained in <code>wormgame.game</code>, and encapsulates the functionality of the game. The class WormGame inherits the class <code>Timer</code>, which provides the time functionality to update the game. In order to work, the class <code>Timer</code> requires a class which implements the interface <code>ActionListener</code>, and we have implemented it in <code>WormGame</code>.</p>

<p>Modify the functionality of WormGame's constructor so that the game's <code>Worm</code> is created in the constructor. Create the worm so that the position of the worm depends on the parameters received in the constructor of the class WormGame. The worm's x coordinate has to be <code>width / 2</code>, the y coordinate <code>height / 2 </code>, and the direction <code>Direction.DOWN</code>.</p>

<p>Also create an apple inside the constructor. The apple coordinates have to be random, but the apple x coordinate has to be contained between <code>[0, width[</code>, and the y coordinate between <code>[0, height[</code>.</p>

<p>Also add the following methods to the WormGame:</p>
<ul>
  <li><code>public Worm getWorm()</code> returns the WormGame worm.</li>
  <li><code>public void setWorm(Worm worm)</code> sets on the game the method parameter worm. If the method <code>getWorm</code> is called after the worm has been set up, it has to return a reference to the <em>same</em> worm.</li>
  <li><code>public Apple getApple</code> returns the apple of the WormGame.</li>
  <li><code>public void setApple(Apple apple)</code> sets the method parameter apple on the worm game. If the method <code>getApple</code> is called after the apple has been set up, it has to return a reference to the <em>same</em> apple.</li>
</ul>



<h4>Worm Game, Part 2</h4>

<p>Modify the functionality of the method <code>actionPerformed</code> so that it would implement the following tasks in the given order.</p>

<ol>
  <li>Move the worm</li>
  <li>If the worm runs into the apple, it eats the apple and calls the grow method. A new apple is randomly created.</li>
  <li>If the worm runs into itself, the variable <code>continue</code> is assigned the value <code>false</code></li>
  <li>Call <code>update</code>, which is a method of the variable <code>updatable</code> which implements the interface <code>Updatable</code>.</li>
  <li>Call the <code>setDelay</code> method which is inherited from the Timer class. The game velocity should grow with respect to the worm length. The call <code>setDelay(1000 / <em>worm</em>.getLength());</code> will work for it: in the call we expect that you have defined the object variable <code>worm</code>.</li>
</ol>

<p>Let's start next to build our user interface components.</p>

<h4>Keyboard listener</h4>

<p>Implement the class <code>KeyboardListener</code> in <code>wormgame.gui</code>. The class has the constructor <code>public KeyboardListener(Worm worm)</code>, and it implements the interface <code>KeyListener</code>. Replace the method <code>keyPressed</code> so that the worm is assigned direction up when the up arrow key. Respectively, the worm is assigned the directions down, left, or right, when the user presses the down, left, or right arrow key.</p>

<h4>DrawingBoard</h4>

<p>Create the class <code>DrawingBoard</code> in <code>wormgame.gui</code>. The <code>DrawingBoard</code> inherits the class <code>JPanel</code>, and its constructor receives an instance of the class <code>WormGame</code> and the int variable <code>pieceLength</code> as parameters. The variable <code>pieceLength</code> tells the dimension of the pieces; length and height of the pieces are equal.</p>

<p>Replace the <code>paintComponent</code> method which was inherited from the class <code>JPanel</code> so that the method draws the worm and the apple. Use the Graphics object's <code>fill3DRect</code> method to draw the worm. The worm colour has to be black (<code>Color.BLACK</code>). The apple has to be drawn with the Graphics object's <code>fillOval</code> method, and its colour has to be red.</p>

<p>Also implement the interface <code>Updatable</code> in <code>DrawingBoard</code>. The method <code>update</code> of Updatable has to call the <code>repaint</code> method of the class JPanel.</p>

<h4>User Interface</h4>

<p>Modify the class <code>UserInterface</code> to contain DrawingBoard. In the method <code>createComponents</code>, you have to create an instance of DrawingBoard and add it into the Container object. Create an instance of <code>KeyboardListener</code> at the end of <code>createComponents</code>, and add it to the Frame object.</p>

<p>Also add the method <code>public Updatable getUpdatable()</code> to the class <code>UserInterface</code>, returning the drawing board which was created in <code>createComponents</code>.</p>

<p>You can start the user interface from the <code>Main</code> class in the following way. Before the game starts, we wait that the user interface is created. When the user interface is created, it gets connected to the worm game and the game gets started.</p>

<pre class="sh_java">
        WormGame game = new WormGame(20, 20);

        UserInterface ui = new UserInterface(game, 20);
        SwingUtilities.invokeLater(ui);

        while (ui.getUpdatable() == null) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                System.out.println("The drawing board hasn't been created yet.");
            }
        }

        game.setUpdatable(ui.getUpdatable());
        game.start();
</pre>

</div>
</div>
<h2>Course Feedback</h2>

<div class="tehtavat">
    <div class="tehtava">

<h3>Course Feedback</h3>

<p>We have received a lot of valuable feedback through TMC. Therefore, as your last task in the course we would like to have feedback on the course in general. Give feedback by filling out the comment section which appears when you have submitted the exercise.
If comment section doesn't pop up, please write your feedback in the <code>Main</code>-class of the downloaded exercise and submit it again.</p>

<p>In order to receive the points of this exercise submit the exercise to our server. </p>

</div>
</div>
</div>
</section>
<div class="viikkoraja-not-released">Retired</div>

<h3>Tiedostojen valitseminen kÃ¤yttÃ¶liittymÃ¤stÃ¤</h3>

<p>Silloin tÃ¤llÃ¶in eteen tulee tilanne, jossa kÃ¤yttÃ¤jÃ¤n pitÃ¤Ã¤ pystyÃ¤ valitsemaan tiedosto tiedostojÃ¤rjestelmÃ¤stÃ¤. Java tarjoaa tiedostojen valintaan valmiin kÃ¤yttÃ¶liittymÃ¤komponentin <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFileChooser.html" target="_blank">JFileChooser</a></code>.</p>

<p>JFileChooser poikkeaa tÃ¤hÃ¤n mennessÃ¤ kÃ¤yttÃ¤mistÃ¤mme kÃ¤yttÃ¶liittymÃ¤komponenteista siinÃ¤, ettÃ¤ se avaa uuden ikkunan. Avautuvan ikkunan ulkonÃ¤kÃ¶ riippuu hieman kÃ¤yttÃ¶jÃ¤rjestelmÃ¤stÃ¤, esimerkiksi hieman vanhemmassa <a href="http://fedoraproject.org/" target="_blank">Fedora</a>-kÃ¤yttÃ¶jÃ¤rjestelmÃ¤ssÃ¤ ikkuna on seuraavannÃ¤kÃ¶inen.</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/jfilechooser-kuva.png"/></p>

<p>JFileChooser-olio voidaan luoda missÃ¤ tahansa. Olion metodille <code>showOpenDialog</code> annetaan parametrina kÃ¤yttÃ¶liittymÃ¤komponentti, johon se liittyy, esimerkiksi <code>JFrame</code>-luokan ilmentymÃ¤. Metodi <code>showOpenDialog</code> avaa tiedostonvalintaikkunan, ja palauttaa <code>int</code>-tyyppisen statuskoodin riippuen kÃ¤yttÃ¤jÃ¤n valinnasta. Luokassa <code>JFileChooser</code> on mÃ¤Ã¤ritelty <code>int</code>-tyyppiset luokkamuuttujat, jotka kuvaavat statuskoodeja. Esimerkiksi onnistuneella valinnalla on arvo <code>JFileChooser.APPROVE_OPTION</code>.</p>

<p>Valittuun tiedostoon pÃ¤Ã¤see <code>JFileChooser</code>-oliosta kÃ¤siksi metodilla <code>getSelectedFile</code>.</p>

<pre class="sh_java">
    JFileChooser chooser = new JFileChooser();

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println("Valitsit tiedoston: " + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println("Et valinnut tiedostoa!");
    }
</pre>

<p>YllÃ¤ oleva esimerkki avaa valintaikkunan, ja tulostaa valitun tiedoston nimen jos valinta onnistuu. Jos valinta epÃ¤onnistuu, ohjelma tulostaa <code>"Et valinnut tiedostoa!"</code>.</p>

<h4>Tiedostojen filtterÃ¶inti</h4>

<p>Tiedostojen filtterÃ¶innillÃ¤ tarkoitetaan vain tietynlaisten tiedostojen nÃ¤yttÃ¤mistÃ¤ tiedostoikkunassa. JFileChooser-oliolle voi asettaa filtterin metodilla <code>setFileFilter</code>. Metodi <code>setFileFilter</code> saa parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileFilter.html" target="_blank">FileFilter</a></code>-ilmentymÃ¤n, esimerkiksi luokasta <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileNameExtensionFilter.html" target="_blank">FileNameExtensionFilter</a></code> tehdyn olion.</p>

<p>Luokka <code>FileNameExtensionFilter</code> mahdollistaa tiedostojen filtterÃ¶innin niiden pÃ¤Ã¤tteiden perusteella. Esimerkiksi pelkÃ¤t <code>txt</code>-pÃ¤Ã¤tteiset tekstitiedostot saa nÃ¤kyviin seuraavasti.</p>

<pre class="sh_java">
    JFileChooser chooser = new JFileChooser();
    chooser.setFileFilter(new FileNameExtensionFilter("Tekstitiedostot", "txt"));

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println("Valitsit tiedoston: " + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println("Et valinnut tiedostoa!");
    }
</pre>

<div class="tehtavat">


<NEXTWEEK></NEXTWEEK>
<h3>Nopeustesti</h3>



<p>Luodaan ohjelma, joka mittaa kliksutteluvauhtia. KÃ¤yttÃ¶liittymÃ¤ tulee nÃ¤yttÃ¤mÃ¤Ã¤n esimerkiksi seuraavalta.</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/169-nopeustesti.png"/></p>

<h4 class="req">Oma luokka JButtonille</h4>

<p>Toteuta pakkaukseen <code>nopeustesti</code> luokka <code>Nappi</code>, joka perii JButtonin. Luokalla <code>Nappi</code> tulee olla konstruktori <code>public Nappi(String text, Color aktiivinen, Color passiivinen)</code>. Konstruktorin parametrina saama characterString <code>text</code> tulee antaa parametrina ylÃ¤luokan konstruktorille (kutsu <code>super(text)</code>).</p>

<p>Korvaa luokasta JButton peritty metodi <code>protected void paintComponent(Graphics g)</code> siten, ettÃ¤ piirrÃ¤t metodissa napin kokoisen vÃ¤rillisen ympyrÃ¤n. Saat napin leveyden ja korkeuden JButton-luokalta perityistÃ¤ metodeista <code>getWidth()</code> ja <code>getHeight()</code>. Kutsu korvatun metodin alussa ylÃ¤luokan <code>paintComponent</code>-metodia.</p>

<p>YmpyrÃ¤n vÃ¤rin tulee riippua Napin tilasta: jos nappi on aktiivinen (metodi <code>isEnabled</code> palauttaa <code>true</code> tulee ympyrÃ¤n vÃ¤ri olla konstruktorin parametrina saatu <code>aktiivinenVari</code>. Muulloin kÃ¤ytetÃ¤Ã¤n vÃ¤riÃ¤ <code>passiivinenVari</code>.</p>

<h4 class="req">Perustoiminta</h4>

<p>Toteuta luokkaan <code>Nopeustesti</code> kÃ¤yttÃ¶liittymÃ¤, jossa on neljÃ¤ nappulaa ja teksti. KÃ¤ytÃ¤ asettelussa napeille omaa JPanel-alustaa, joka asetetaan BorderLayout-asettelijan keskelle. Teksti tulee BorderLayout-asettelijan alaosaan.</p>

<p>KÃ¤ytÃ¤ edellisessÃ¤ osassa luomaasi <code>Nappi</code>-luokkaa. Napeille tulee antaa konstruktorissa tekstit 1, 2, 3 ja 4.</p>

<h4 class="req">Nappuloiden aktiivisuus</h4>

<p>Vain yhden nappulan kerrallaan tulee olla painettavissa (eli aktiivisena). Voit tehdÃ¤ nappulasta ei-aktiivisen metodikutsulla <code>nappi.setEnabled(false)</code>. Vastaavasti nappi muutetaan aktiiviseksi kutsulla <code>nappi.setEnabled(true)</code>.</p>

<p>Kun aktiivisena olevaa nappulaa painetaan, tulee kÃ¤yttÃ¶liittymÃ¤n arpoa uusi aktiivinen nappi.</p>

<h4 class="req">Pisteytys</h4>

<p>TehdÃ¤Ã¤n peliin pisteytys: mitataan 20 painallukseen kuluva aika. Helpoin tapa ajan mittaamiseen on metodin <code>System.currentTimeMillis()</code> kutsuminen. Metodi palauttaa kokonaisluvunu, joka laskee millisekunteja (tuhannesosasekunteja) jostain tietysti ajanhetkestÃ¤ lÃ¤htien. SiispÃ¤ voit mitata kulunutta aikaa kutsumalla <code>currentTimeMillis</code> pelin alussa ja lopussa ja laskemalla erotuksen.</p>

<p>Toteuta siis seuraava: peli laskee napinpainallusten mÃ¤Ã¤rÃ¤n, ja 20. painalluksen jÃ¤lkeen asettaa kaikki nappulat epÃ¤aktiivisiksi ja nÃ¤yttÃ¤Ã¤ <code>JLabel</code>-komponentissa viestin <code>"Pisteesi: XXXX"</code>, jossa <code>XXXX</code> on painalluksiin kulunut aika (millisekunteina) jaettuna 20:lla. Pienempi pistemÃ¤Ã¤rÃ¤ on siis parempi.</p>

<h3>TiedostonnÃ¤ytin</h3>

<p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ toteutetaan ohjelma, joka lukee kÃ¤yttÃ¤jÃ¤n valitseman tiedoston ja nÃ¤yttÃ¤Ã¤ sen sisÃ¤llÃ¶n kÃ¤yttÃ¶liittymÃ¤ssÃ¤.</p>

<p>Ohjelmassa on eroteltu kÃ¤yttÃ¶liittymÃ¤Ã¤n ja sovelluslogiikka. TehtÃ¤vÃ¤pohjassa on valmiina sovelluslogiikan rajapinta <code>TiedostonLukija</code> sekÃ¤ kÃ¤yttÃ¶liittymÃ¤luokan runko <code>Kayttoliittyma</code>.</p>

<h4>KÃ¤yttÃ¶liittymÃ¤n rakentaminen</h4>

<p>TÃ¤ydennÃ¤ kÃ¤yttÃ¶liittymÃ¤luokan metodi <code>luoKomponentit</code>. Ohjelma tarvitsee toimiakseen kolme kÃ¤yttÃ¶liittymÃ¤komponenttia:</p>

<ul>
  <li><strong>JButton</strong>-nappi, jossa on teksti &quot;Valitse tiedosto...&quot;</li>
  <li><strong>JTextArea</strong>-tekstieditorin avulla nÃ¤ytetÃ¤Ã¤n tiedoston sisÃ¤ltÃ¶, komponentin editointimahdollisuus tulee kytkeÃ¤ pois pÃ¤Ã¤ltÃ¤ metodilla <code>setEditable</code>. <code>JTextArea</code> eroaa <code>JTextField</code>-komponentista siten, ettÃ¤ <code>JTextArea</code>-komponentissa voi olla tekstiÃ¤ useammalla rivillÃ¤.</li>
  <li><strong>JLabel</strong>-tietokenttÃ¤, joka sisÃ¤ltÃ¤Ã¤ nÃ¤ytettÃ¤vÃ¤n tiedoston nimen (ilman polkua!)</li>
</ul>

<p>Koska tÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ on vain kolme aseteltavaa komponenttia, riittÃ¤vÃ¤t asetteluun <code>BorderLayout</code>-asettelijan vaihtoehdot: <code>BorderLayout.NORTH</code>, <code>BorderLayout.CENTER</code> ja <code>BorderLayout.SOUTH</code>. KÃ¤yttÃ¶liittymÃ¤komponentti <code>JTextArea</code> kannattaa sijoittaa keskelle, jotta se saa mahdollisimman paljon tilaa tekstin nÃ¤yttÃ¤miselle.</p>

<p>KÃ¤yttÃ¶liittymÃ¤n pitÃ¤isi nÃ¤yttÃ¤Ã¤ suunnilleen seuraavalta. Alla olevassa esimerkissÃ¤ <code>JLabel</code>-oliossa ei ole mitÃ¤Ã¤n tekstiÃ¤.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/161-tiedostonnaytin-alku.png"/></p>


<h4>Tiedoston lukeminen</h4>

<p>Luo pakkaukseen <code>tiedostonnaytin.sovelluslogiikka</code> luokka <code>OmaTiedostonLukija</code>, joka toteuttaa rajapinnan <code>TiedostonLukija</code>. Rajapinnassa on yksi metodi, <code>lueTiedosto</code>, joka lukee sille annetun tiedoston kokonaisuudessaan characterStringon ja palauttaa tÃ¤mÃ¤n characterStringn.</p>

<p>Rajapinnan koodi:</p>

<pre class="sh_java">
package tiedostonnaytin.sovelluslogiikka;

import java.io.File;

public interface TiedostonLukija {
    String lueTiedosto(File tiedosto);
}
</pre>

<p><b>Huom:</b> Palautettavassa characterStringssa tulee sÃ¤ilyttÃ¤Ã¤ myÃ¶s rivinvaihdot <code>"\n"</code>. Esimerkiksi <code>Scanner</code>-lukijan metodi <code>nextLine()</code> poistaa palauttamistaan characterStringista rivinvaihdot, joten joudut joko lisÃ¤Ã¤mÃ¤Ã¤n ne takaisin tai lukemaan tiedostoa eri tavalla.</p>

<h4>KÃ¤yttÃ¶liittymÃ¤n kytkeminen sovelluslogiikkaan</h4>

<p>ViimeisessÃ¤ tehtÃ¤vÃ¤n osassa toteutetaan kÃ¤yttÃ¶liittymÃ¤n <code>JButton</code>-napille tapahtumankuuntelija. Saat itse pÃ¤Ã¤ttÃ¤Ã¤ luokalle sopivan nimen.</p>

<p>Tapahtumankuuntelijan tehtÃ¤vÃ¤nÃ¤ on nÃ¤yttÃ¤Ã¤ <code>JFileChooser</code>-tiedostonvalintaikkuna kun <code>JButton</code>-nappia painetaan. Kun kÃ¤yttÃ¤jÃ¤ valitsee tiedoston, tulee tapahtumankuuntelijan lukea tiedoston sisÃ¤ltÃ¶ ja nÃ¤yttÃ¤Ã¤ se <code>JTextArea</code>-kentÃ¤ssÃ¤. TÃ¤mÃ¤n jÃ¤lkeen tapahtumankuuntelijan tulee vielÃ¤ pÃ¤ivittÃ¤Ã¤ <code>JLabel</code>-kenttÃ¤Ã¤n nÃ¤ytetyn tiedoston nimi (ilman tiedostopolkua).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos kÃ¤yttÃ¤jÃ¤ valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa mÃ¤Ã¤riteltyÃ¤ <code>TiedostonLukija</code>-oliota apuna kÃ¤yttÃ¤en. Kannattaa luoda tapahtumankuuntelija siten, ettÃ¤ sille annetaan konstruktorissa kaikki tarvitut oliot.</p>

<p>Huomaa, ettÃ¤ valintaikkunan voi myÃ¶s sulkea valitsematta tiedostoa!</p>

<!--
<p><code>JButton</code>-nappiin tulee siis liittÃ¤Ã¤ <code>ActionListener</code>-rajapinnan toteuttava tapahtumankuuntelija, joten tehtÃ¤vÃ¤ssÃ¤ tÃ¤ytyy luoda tÃ¤tÃ¤ varten uusi luokka. <code>JFileChooser</code> palauttaa kÃ¤yttÃ¤jÃ¤n valitsemaa operaatiota vastaavan paluuarvon sekÃ¤ viitteen valittuun tiedostoon, jos kÃ¤yttÃ¤jÃ¤ valitsi tiedoston (eikÃ¤ peruuttanut valintaa).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos kÃ¤yttÃ¤jÃ¤ valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa mÃ¤Ã¤riteltyÃ¤ <code>TiedostonLukija</code>-oliota apuna kÃ¤yttÃ¤en. Kannattaa luoda tapahtumankuuntelija siten, ettÃ¤ sille annetaan konstruktorissa tarvitut oliot.</p>

<p>Kun kÃ¤yttÃ¤jÃ¤ valitsee tiedoston, tulee <code>JTextArea</code>-kentÃ¤n tekstisisÃ¤llÃ¶ksi asettaa tiedoston sisÃ¤ltÃ¶.</p>-->

<p>Kun tiedosto on avattu, tulee kÃ¤yttÃ¶liittymÃ¤n nÃ¤yttÃ¤Ã¤ esimerkiksi seuraavalta.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/161-tiedostonnaytin-avattu.png"/></p>

</div>


<div class="tehtavat">



<h3>Tekstiseikkailu</h3>


  <p>TehtÃ¤vÃ¤sarjassa tehdÃ¤Ã¤n laajennettava tekstiseikkailupelin runko. Seikkailu koostuu <em>kohdista</em>, joissa jokaisessa ruudulle tulee tekstiÃ¤. Kohdat voivat olla joko vÃ¤livaiheita, kysymyksiÃ¤, tai monivalintakohtia. Monivalinta-tyyppisen kohdan nÃ¤yttÃ¤mÃ¤ teksti voi olla esimerkiksi seuraavanlainen:</p>

<pre>
Huoneessa on kaksi ovea. Kumman avaat?

1. Vasemmanpuoleisen.
2. Oikeanpuoleisen.
3. Juoksen pakoon.
</pre>

  <p>KÃ¤yttÃ¤jÃ¤ vastaa kohdassa esitettÃ¤vÃ¤Ã¤n tekstiin. YllÃ¤ olevaan tekstiin voi vastata <code>1</code>, <code>2</code> tai <code>3</code>, ja vastauksesta riippuu, minne kÃ¤yttÃ¤jÃ¤ siirtyy seuraavaksi.</p>

  <p>Peliin tullaan toteuttamaan kohtia kuvaava rajapinta ja tekstikÃ¤yttÃ¶liittymÃ¤, jonka kautta peliÃ¤ pelataan.</p>

  <p><em>Huom!</em> Toteuta kaikki tehtÃ¤vÃ¤n vaiheet pakkaukseen "seikkailu"</p>

  <h4 class="req">Kohta ja VÃ¤livaihe</h4>

  <p>PelissÃ¤ voi olla hyvinkin erilaisia kohtia, ja edellÃ¤ olleessa esimerkissÃ¤ ollut monivalinta on vain erÃ¤s vaihtoehto.</p>

  <p>Toteuta kohdan kÃ¤yttÃ¤ytymistÃ¤ kuvaava rajapinta <code>Kohta</code>. Rajapinnalla <code>Kohta</code> tulee olla metodi <code>String teksti()</code>, joka palauttaa kohdassa tulostettavan tekstin. Metodin <code>teksti</code> lisÃ¤ksi kohdalla tulee olla metodi <code>Kohta seuraavaKohta(String vastaus)</code>, jonka toteuttavat luokat palauttavat seuraavan kohdan vastauksen perusteella.</p>

  <p>Toteuta tÃ¤mÃ¤n jÃ¤lkeen yksinkertaisin tekstiseikkailun kohta, eli ei-interaktiivinen tekstiruutu, josta pÃ¤Ã¤see etenemÃ¤Ã¤n millÃ¤ tahansa syÃ¶tteellÃ¤. Toteuta ei-interaktiivista tekstiruutua varten luokka <code>Valivaihe</code>, jolla on seuraavanlainen API.</p>

  <p>
    <ul>
      <li> Luokka toteuttaa rajapinnan <code>Kohta</code>. </li>
      <li> Konstruktori ottaa parametrikseen kÃ¤yttÃ¤jÃ¤lle nÃ¤ytettÃ¤vÃ¤n tekstin. </li>
      <li> <code>public String teksti()</code>-metodi palauttaa konstruktorissa annetun tekstin sekÃ¤ rivin <code>"(jatka painamalla enteriÃ¤)"</code>. (Rivinvaihto saadaan aikaan merkillÃ¤ "\n".)</li>
      <li> <code>public void asetaSeuraava(Kohta seuraava)</code>-metodilla voidaan asettaa <code>Kohta</code>-olio, jonka <code>seuraavaKohta(String vastaus)</code> aina palauttaa (vastauksesta riippumatta). </li>
    </ul>
  </p>

  <p>Testaa ohjelmaasi seuraavalla esimerkillÃ¤:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Valivaihe alkuteksti = new Valivaihe("Olipa kerran ohjelmoija.");
    Valivaihe johdanto = new Valivaihe("Joka alkoi ohjelmoimaan Javalla.");
    alkuteksti.asetaSeuraava(johdanto);

    Kohta nykyinen = alkuteksti;
    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(reader.nextLine());
    if (nykyinen == null) {
        System.out.println("Virhe ohjelmassa!");
    }

    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(reader.nextLine());
    if (nykyinen != null) {
        System.out.println("Virhe ohjelmassa!");
    }
</pre>

<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteriÃ¤)

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteriÃ¤)

</pre>


<h4>KÃ¤yttÃ¶liittymÃ¤</h4>

  <p>Pelin kÃ¤yttÃ¶liittymÃ¤ (luokka <code>Kayttoliittyma</code>) saa konstruktorin parametrina <code>Scanner</code>-olion ja <code>Kohta</code>-rajapinnan toteuttavan pelin aloittavan olion. Luokka tarjoaa metodin <code>public void start()</code>, joka kÃ¤ynnistÃ¤Ã¤ pelin suorituksen.</p>

  <p>KÃ¤yttÃ¶liittymÃ¤ kÃ¤sittelee kaikkia kohtia <code>Kohta</code>-rajapinnan kautta. KÃ¤yttÃ¶liittymÃ¤n tulee jokaisessa kohdassa kysyÃ¤ kohtaan liittyvÃ¤ltÃ¤ metodilta <code>teksti</code> tekstiÃ¤, joka kÃ¤yttÃ¤jÃ¤lle nÃ¤ytetÃ¤Ã¤n. TÃ¤mÃ¤n jÃ¤lkeen kÃ¤yttÃ¶liittymÃ¤ kysyy kÃ¤yttÃ¤jÃ¤ltÃ¤ vastauksen, ja antaa sen parametrina kohta-olion metodille <code>seuraavaKohta</code>. Metodi <code>seuraavaKohta</code> palauttaa vastauksen perusteella seuraavan kohdan, johon pelin on mÃ¤Ã¤rÃ¤ siirtyÃ¤. Peli loppuu, kun metodi <code>seuraavaKohta</code> palauttaa arvon <code>null</code>.</p>

  <p>Koska pÃ¤Ã¤ohjelma tulee kÃ¤yttÃ¤mÃ¤Ã¤n kohtia vain <code>Kohta</code>-rajapinnan kautta, voidaan peliin lisÃ¤tÃ¤ vaikka minkÃ¤laisia kohtia pÃ¤Ã¤ohjelmaa muuttamatta. RiittÃ¤Ã¤ tehdÃ¤ uusia <code>Kohta</code>-rajapinnan toteuttavia luokkia.</p>

  <p>Toteuta luokka <code>Kayttoliittyma</code>, ja testaa sen toimintaa seuraavalla esimerkillÃ¤</p>

<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);
        Valivaihe alku = new Valivaihe("Olipa kerran ohjelmoija.");
        Valivaihe johdanto = new Valivaihe("Joka alkoi ohjelmoimaan Javalla.");
        Valivaihe loppu = new Valivaihe("Ja pÃ¤Ã¤tti muuttaa Helsinkiin.");

        alku.asetaSeuraava(johdanto);
        johdanto.asetaSeuraava(loppu);

        new Kayttoliittyma(lukija, alku).start();
</pre>


<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteriÃ¤)
&gt;

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteriÃ¤)
&gt;

Ja pÃ¤Ã¤tti muuttaa Helsinkiin.
(jatka painamalla enteriÃ¤)
&gt;

</pre>

  <p>KÃ¤ytÃ¤ seuraavaa metodia kÃ¤yttÃ¶liittymÃ¤n <code>start</code>-metodina. YritÃ¤ piirtÃ¤Ã¤ paperille mitÃ¤ kÃ¤y kun kÃ¤yttÃ¶liittymÃ¤ kÃ¤ynnistetÃ¤Ã¤n.</p>

<pre class="sh_java">
    public void start() {
        Kohta nykyinen = alkukohta;

        while (nykyinen != null) {
            System.out.println(nykyinen.teksti());
            System.out.print("&gt; ");
            String vastaus = reader.nextLine();

            nykyinen = nykyinen.seuraavaKohta(vastaus);
            System.out.println("");
        }
    }
</pre>

  <p>KÃ¤yttÃ¶liittymÃ¤n <code>start</code>-metodi sisÃ¤ltÃ¤Ã¤ siis toistolauseen, jossa ensin tulostetaan kÃ¤siteltÃ¤vÃ¤n kohdan teksti. TÃ¤mÃ¤n jÃ¤lkeen kysytÃ¤Ã¤n kÃ¤yttÃ¤jÃ¤ltÃ¤ syÃ¶tettÃ¤. KÃ¤yttÃ¤jÃ¤n syÃ¶te annetaan vastauksena kÃ¤siteltÃ¤vÃ¤n kohdan <code>seuraavaKohta</code>-metodille. Metodi <code>seuraavaKohta</code> palauttaa kohdan, jota kÃ¤sitellÃ¤Ã¤n seuraavalla toiston kierroksella. Jos palautettu kohta oli <code>null</code>, lopetetaan toisto.</p>

    <h4>KysymyksiÃ¤</h4>

    <p>Tekstiseikkailussa voi olla kysymyksiÃ¤, joihin on annettava oikea vastaus ennen kuin pelaaja pÃ¤Ã¤see eteenpÃ¤in. Tee luokka <code>Kysymys</code> seuraavasti:</p>

    <p>
      <ul>
        <li> Luokka toteuttaa <code>Kohta</code>-rajapinnan. </li>
        <li> Konstruktori saa parametreina kysymystekstin ja oikean vastauksen. </li>
        <li> Seuraavan kohdan voi asettaa <code>asetaSeuraava</code>-metodilla. </li>
        <li> Jos <code>seuraavaKohta</code>-metodia kutsutaan oikealla vastauksella, metodi palauttaa seuraavan kohdan, muuten metodi ei pÃ¤Ã¤stÃ¤ etenemÃ¤Ã¤n ja palauttaa arvon <code>this</code>, eli viitteen tÃ¤hÃ¤n olioon. </li>
      </ul>
    </p>

    <p>Luokkaa voi testata seuraavalla pÃ¤Ã¤ohjelmalla:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Kysymys alku = new Kysymys("MinÃ¤ vuonna Javan ensimmÃ¤inen versio julkaistiin?", "1995");
    Valivaihe hyva = new Valivaihe("HyvÃ¤! LisÃ¤tietoa: Javan alkuperÃ¤inen ideoija on James Gosling.");

    alku.asetaSeuraava(hyva);

    new Kayttoliittyma(lukija, alku).start();
</pre>

<pre>
MinÃ¤ vuonna Javan ensimmÃ¤inen versio julkaistiin?
&gt; <font color="red">2000</font>

MinÃ¤ vuonna Javan ensimmÃ¤inen versio julkaistiin?
&gt; <font color="red">1995</font>

HyvÃ¤! LisÃ¤tietoa: Javan alkuperÃ¤inen ideoija on James Gosling.
(jatka painamalla enteriÃ¤)
&gt;
</pre>



<h4 class="req">Monivalintakysymykset</h4>

    <p>TÃ¤llÃ¤ hetkellÃ¤ tekstiseikkailu tukee vÃ¤livaiheita ja yksinkertaisia kysymyksiÃ¤. Tekstiseikkailu on siis lineaarinen, eli lopputulokseen ei voi kÃ¤ytÃ¤nnÃ¶ssÃ¤ vaikuttaa. LisÃ¤tÃ¤Ã¤n seikkailuun monivalintakysymyksiÃ¤, joiden avulla pelin kehittÃ¤jÃ¤ voi luoda vaihtoehtoista toimintaa.</p>

    <p>Esimerkki vaihtoehtoisesta toiminnasta:</p>

<pre>
Kello on 13:37 ja pÃ¤Ã¤tÃ¤t mennÃ¤ syÃ¶mÃ¤Ã¤n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">1</font>

Ruoka on loppu :(
(jatka painamalla enteriÃ¤)
&gt;
</pre>


<pre>
Kello on 13:37 ja pÃ¤Ã¤tÃ¤t mennÃ¤ syÃ¶mÃ¤Ã¤n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">2</font>

Mainio valinta!
(jatka painamalla enteriÃ¤)
&gt;
</pre>

    <p>Toteuta luokka <code>Monivalinta</code>, jonka API on seuraavanlainen</p>

    <p>
      <ul>
        <li> Toteuttaa rajapinnan <code>Kohta</code>. </li><br/>
        <li> <code>public Monivalinta(String teksti)</code></li> Luokan konstruktori saa parametrina nÃ¤ytettÃ¤vÃ¤n tekstin. <br/>
        <li> <code>public void lisaaVaihtoehto(String valinta, Kohta seuraava)</code></li> LisÃ¤Ã¤ vaihtoehdon ja siihen liittyvÃ¤n seuraavan kohdan. YhdessÃ¤ monivalintakysymyksessÃ¤ voi olla rajaton mÃ¤Ã¤rÃ¤ vaihtoehtoja.<br/>
        <li> <code>public String teksti()</code></li> Palauttaa characterStringna sekÃ¤ konstruktorissa annetun perustekstin ettÃ¤ kaikki valintavaihtoehdot. Valintavaihtoehdot tulee olla eritelty numeroilla.<br/>
        <li> <code>public Kohta seuraavaKohta(String valinta)</code></li> Palauttaa kÃ¤yttÃ¤jÃ¤n valitsemaa vaihtoehtoa vastaavan kohdan. KÃ¤yttÃ¤jÃ¤ valitsee aina kirjoittamalla numeron. Huom! Voit muuttaa characterStringn numeroksi luokan <code>Integer</code> luokkametodilla <code>parseInt</code>. <br/>
      </ul>
    </p>


    <p>Testaa ohjelmasi toimintaa seuraavalla pÃ¤Ã¤ohjelmalla:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Monivalinta lounas = new Monivalinta("Kello on 13:37 ja pÃ¤Ã¤tÃ¤t mennÃ¤ syÃ¶mÃ¤Ã¤n. Minne menet?");
    Monivalinta chemicum = new Monivalinta("Lounasvaihtoehtosi ovat seuraavat:");

    Valivaihe exactum = new Valivaihe("Exactumista on kaikki loppu, joten menet Chemicumiin.");

    exactum.asetaSeuraava(chemicum);

    lounas.lisaaVaihtoehto("Exactumiin", exactum);
    lounas.lisaaVaihtoehto("Chemicumiin", chemicum);

    Valivaihe nom = new Valivaihe("Olipas hyvÃ¤Ã¤");

    chemicum.lisaaVaihtoehto("Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta", nom);
    chemicum.lisaaVaihtoehto("Jauhelihakebakot, paprikakastiketta", nom);
    chemicum.lisaaVaihtoehto("Mausteista kalapataa", nom);

    new Kayttoliittyma(lukija, lounas).start();
</pre>

<pre>
Kello on 13:37 ja pÃ¤Ã¤tÃ¤t mennÃ¤ syÃ¶mÃ¤Ã¤n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">1</font>

Exactumista on kaikki loppu, joten menet Chemicumiin.
(jatka painamalla enteriÃ¤)
&gt;

Lounasvaihtoehtosi ovat seuraavat:
1. Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta
2. Jauhelihakebakot, paprikakastiketta
3. Mausteista kalapataa
&gt; <font color="red">2</font>

Olipas hyvÃ¤Ã¤
(jatka painamalla enteriÃ¤)
&gt;

</pre>

    <p><em>Luokan <code>Monivalinta</code> sisÃ¤inen toteutus saattaa olla haastava. Kannattaa esimerkiksi kÃ¤yttÃ¤Ã¤ listaa vastausvaihtoehtojen (characterStringjen) tallentamiseen, ja hajautustaulua kohtien tallentamiseen valintavaihtoehdon indeksillÃ¤. </em></p>

</div>


<div class="tehtavat">

  <h3>Tilastot kuntoon</h3>

  <p>NHL:ssÃ¤ pidetÃ¤Ã¤n pelaajista yllÃ¤ monenlaisia tilastotietoja. Teemme nyt oman ohjelman NHL-pelaajien tilastojen hallintaan.</p>

<h4>Pelaajalistan tulostus</h4>

  <p>Tee luokka <code>Pelaaja</code>, johon voidaan tallettaa pelaajan nimi, joukkue, pelatut ottelut, maalimÃ¤Ã¤rÃ¤, ja syÃ¶ttÃ¶mÃ¤Ã¤rÃ¤. Luokalla tulee olla konstruktori, joka saa edellÃ¤mainitut tiedot edellÃ¤ annetussa jÃ¤rjestyksessÃ¤.</p>

  <p>Tee kaikille edellÃ¤minituille arvoille myÃ¶s ns. getterimetodit, jotka palauttavat arvot:</p>

<ul>
  <li><code>String getName</code></li>
  <li><code>String getJoukkue</code></li>
  <li><code>int getOttelut</code></li>
  <li><code>int getMaalit</code></li>
  <li><code>int getSyotot</code></li>
  <li><code>int getPisteet</code> - laskee kokonaispistemÃ¤Ã¤rÃ¤n eli maalien ja syÃ¶ttÃ¶jen summan</li>
</ul>

<p>Talleta seuraavat pelaajat ArrayList:iin ja tulosta listan sisÃ¤ltÃ¶:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        pelaajat.add(new Pelaaja("Alex Ovechkin", "WSH", 71, 28, 46));
        pelaajat.add(new Pelaaja("Dustin Byfuglien", "ATL", 69, 19, 31));
        pelaajat.add(new Pelaaja("Phil Kessel", "TOR", 70, 28, 24));
        pelaajat.add(new Pelaaja("Brendan Mikkelson", "ANA, CGY", 23, 0, 2));
        pelaajat.add(new Pelaaja("Matti Luukkainen", "SaPKo", 1, 0, 0 ));

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
    }
</pre>

<p>Pelaajan <code>toString()</code>-metodin muodostaman tulostuksen tulee olla seuraavassa muodossa:</p>

<pre>
Alex Ovechkin WSH 71 28 + 46 = 74
Dustin Byfuglien ATL 69 19 + 31 = 50
Phil Kessel TOR 70 28 + 24 = 52
Brendan Mikkelson ANA, CGY 23 0 + 2 = 2
Matti Luukkainen SaPKo 1 0 + 0 = 0
</pre>

  <p>Ensin siis nimi, sitten joukkue, jonka jÃ¤lkeen ottelut, maalit, plusmerkki, syÃ¶tÃ¶t, yhtÃ¤suuruusmerkki ja kokonaispisteet eli maalien ja syÃ¶ttÃ¶jen summa.</p>

<h4>Tulostuksen siistiminen</h4>

  <p>Tee <code>Pelaaja</code>-luokkaan metodi <code>toSiisticharacterString()</code>, joka palauttaa samat tiedot siististi aseteltuna siten, ettÃ¤ jokaiselle muuttujalle on varattu tietty mÃ¤Ã¤rÃ¤ tilaa tulostuksessa.</p>

<p>Tulostuksen tulee nÃ¤yttÃ¤Ã¤ seuraavalta:</p>

<pre>
Alex Ovechkin             WSH             71  28 + 46 = 74
Dustin Byfuglien          ATL             69  19 + 31 = 50
Phil Kessel               TOR             70  28 + 24 = 52
Brendan Mikkelson         ANA, CGY        23   0 +  2 =  2
Matti Luukkainen          SaPKo            1   0 +  0 =  0
</pre>

  <p>Nimen jÃ¤lkeen joukkueen nimien tÃ¤ytyy alkaa samasta kohdasta. Saat tÃ¤mÃ¤n aikaan esim. muotoilemalla nimen tulostuksen yhteydessÃ¤ seuraavasti:</p>

<pre class="sh_java">
String nameJaTyhjaa = String.format("%-25s", nimi);
</pre>

  <p>Komento tekee characterStringn <code>nimiJaTyhjaa</code> joka alkaa characterStringn <code>nimi</code> sisÃ¤llÃ¶llÃ¤ ja se jÃ¤lkeen tulee vÃ¤lilyÃ¶ntejÃ¤ niin paljon ettÃ¤ characterStringn pituudeksi tulee 25. Joukkueen nimi tulee vastaavalla tavalla tulostaa 14 merkin pituisena characterStringna. TÃ¤mÃ¤n jÃ¤lkeen on otteluiden mÃ¤Ã¤rÃ¤ (2 merkkiÃ¤), jota seuraa 2 vÃ¤lilyÃ¶ntiÃ¤. TÃ¤mÃ¤n jÃ¤lkeen on maalien mÃ¤Ã¤rÃ¤ (2 merkkiÃ¤), jota seuraa characterString " + ". TÃ¤tÃ¤ seuraa syÃ¶ttÃ¶jen mÃ¤Ã¤rÃ¤ (2 merkkiÃ¤), characterString " = ", ja lopuksi yhteispisteet (2 merkkiÃ¤).</p>

  <p>Lukuarvot eli ottelu-, maali-, syÃ¶ttÃ¶- ja pistemÃ¤Ã¤rÃ¤ muotoillaan kahden merkin mittaisena, eli lukeman 0 sijaan tulee tulostua vÃ¤lilyÃ¶nti ja nolla. Seuraava komento auttaa tÃ¤ssÃ¤:</p>

<pre class="sh_java">
String maalitMerkkeina = String.format("%2d", maalit);
</pre>

<h4>PistepÃ¶rssin tulostus</h4>

  <p>LisÃ¤Ã¤ luokalle Pelaaja rajapinta <code>Comparable&lt;Pelaaja&gt;</code>, jonka avulla pelaajat voidaan jÃ¤rjestÃ¤Ã¤ kokonaispistemÃ¤Ã¤rÃ¤n mukaiseen <em>laskevaan</em> jÃ¤rjestykseen. JÃ¤rjestÃ¤ pelaajat Collections-luokan avulla ja tulosta pistepÃ¶rssi:</p>

<pre class="sh_java">
        Collections.sort(pelaajat);

        System.out.println("NHL pistepÃ¶rssi:\n");
        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
</pre>

<p>
Prints:
</p>

<pre>
NHL pistepÃ¶rssi:

Alex Ovechkin             WSH           71  28 + 46 = 74
Phil Kessel               TOR           70  28 + 24 = 52
Dustin Byfuglien          ATL           69  19 + 31 = 50
</pre>

  <p>Ohjeita tÃ¤hÃ¤n tehtÃ¤vÃ¤Ã¤n materiaalissa.</p>

<h4>Kaikkien pelaajien tiedot</h4>

  <p>Tilastomme on vielÃ¤ hieman vajavainen, siinÃ¤ on vaan muutaman pelaajan tiedot (ja nekin vastaavat 16.3. tilannetta). Kaikkien tietojen syÃ¶ttÃ¤minen kÃ¤sin olisi kovin vaivalloista. Onneksemme internetistÃ¤ osoitteesta <code>http://nhlstatistics.herokuapp.com/players.txt</code> lÃ¶ytyy pÃ¤ivittyvÃ¤, koneen luettavaksi tarkoitettu lista pelaajatiedoista.</p>

  <p><b>Huom:</b> kun menet osoitteeseen ensimmÃ¤istÃ¤ kertaa, sivun latautuminen kestÃ¤Ã¤ muutaman sekunnin (sivu pyÃ¶rii virtuaalipalvelimella joka sammutetaan jos sivua ei ole hetkeen kÃ¤ytetty). Sen jÃ¤lkeen sivu toimii nopeasti.</p>

  <p>Datan lukeminen internetistÃ¤ on helppoa. Projektissasi on valmiina luokka <code>Tilasto</code>, joka lataa annetun verkkosivun.</p>

<pre class="sh_java">
import java.io.InputStream;
import java.net.URL;
import java.util.Scanner;

public class Tilasto {
    private static final String OSOITE =
            "http://nhlstatistics.herokuapp.com/players.txt";

    private Scanner lukija;

    public Tilasto() {
        this(OSOITE);
    }

    public Tilasto(String osoite) {
        try {
            URL url = new URL(osoite);
            lukija = new Scanner(url.openStream());
        } catch (Exception ex) {
        }
    }

    public Tilasto(InputStream in) {
        try {
            lukija = new Scanner(in);
        } catch (Exception ex) {
        }
    }

    public boolean onkoRivejaJaljella() {
        return reader.hasNextLine();
    }

    public String annaSeuraavaRivi() {
        String rivi = reader.nextLine();
        return rivi.trim();
    }
}
</pre>

  <p><code>Tilasto</code>-luokka lukee pelaajien tilastotiedot internetistÃ¤. Metodilla <code>annaSeuraavaRivi()</code> saadaan selville yhden pelaajan tiedot. Tietoja on tarkoitus lukea niin kauan kuin pelaajia riittÃ¤Ã¤, tÃ¤mÃ¤ voidaan tarkastaa metodilla <code>onkoRivejaJaljella()</code> </p>

  <p>Kokeile ettÃ¤ ohjelmasi onnistuu tulostamaan <code>Tilasto</code>-luokan hakemat tiedot:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Tilasto tilasto = new Tilasto();

        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            System.out.println(pelaajaRivina);
        }
    }
</pre>

  <p>Tulostus on seuraavan muodoinen:</p>

<pre>
Evgeni Malkin;PIT;62;39;46;54 <br/>

Steven Stamkos;TBL;70;50;34;64 <br/>

Claude Giroux;PHI;66;26;56;27 <br/>

Jason Spezza;OTT;72;29;46;30 <br/>
// ... ja yli 800:n muun pelaajan tiedot
</pre>

  <p><b>Huom:</b> tulostuksen alussa ja lopussa ja jokaisen pelaajan vÃ¤lissÃ¤ on html-tÃ¤gejÃ¤, esim. &lt;br/&gt; joka aiheuttaa www-sivulle rivin vaihtumisen.</p>

  <p>Tulostuksessa pelaajan tiedot on erotettu toisistaan puolipisteellÃ¤. Ensin nimi, sitten joukkue, ottelut, maalit, syÃ¶tÃ¶t ja laukaukset.</p>

  <p>Pelaajaa vastaava characterString on siis yksittÃ¤inen characterString. Saat pilkottua sen osiin <code>split</code>-komennolla seuraavasti:</p>

<pre class="sh_java">
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(";");
            for (int j = 0; j &lt; pelaajaOsina.length; j++) {
                System.out.print(pelaajaOsina[j] + " ");
            }
            System.out.println("");
        }
</pre>

  <p>Kokeile ettÃ¤ tÃ¤mÃ¤ toimii. Saat tÃ¤stÃ¤ tehtÃ¤vÃ¤stÃ¤ pisteet seuraavan tehtÃ¤vÃ¤n yhteydessÃ¤.</p>

  <h4>Kaikkien pelaajien pistepÃ¶rssi</h4>

  <p>Tee kaikista <code>Tilasto</code>-luokan hakemien pelaajien tiedoista Pelaaja-olioita ja lisÃ¤Ã¤ ne ArrayListiin. LisÃ¤Ã¤ tehtÃ¤vÃ¤Ã¤n luokka <code>PelaajatTilastosta</code>. KÃ¤ytÃ¤ alla olevaa koodia luokan runkona.</p>

<pre class="sh_java">
import java.util.ArrayList;

public class PelaajatTilastosta {
    public ArrayList&lt;Pelaaja&gt; haePelaajat(Tilasto tilasto) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(";");

            // LisÃ¤tÃ¤Ã¤n uusi pelaaja vain, jos syÃ¶tteessÃ¤ on kenttiÃ¤ riittÃ¤vÃ¤sti
            if (pelaajaOsina.length &gt; 4) {
                int ottelut = Integer.parseInt(pelaajaOsina[2].trim());
                // TÃ¤ydennÃ¤ koodia lukemalla kaikki pelaajaOsina-taulukon kentÃ¤t uuteen Pelaaja-olioon
                // ...
                // pelaajat.add(new Pelaaja( ... ));
            }
        }

        return pelaajat;
    }
}
</pre>

  <p>TehtÃ¤vÃ¤nÃ¤si on tÃ¤ydentÃ¤Ã¤ runkoa siten, ettÃ¤ jokaisesta luetusta rivistÃ¤ luodaan pelaaja, joka lisÃ¤tÃ¤Ã¤n pelaajat-listaan. Huom! <code>Tilasto</code>-luokka palauttaa characterStringja, joten joudut muuntamaan characterStringja myÃ¶s numeroiksi. Esimerkiksi numeromuotoinen <code>ottelut</code> on muutettava <code>int</code>:iksi <code>Integer.parseInt</code>-metodilla.</p>

  <p>Jos characterStringn metodi <code>split</code> ei ole tuttu, se jakaa characterStringn useampaan osaan annetun merkin kohdalta. Esimerkiksi komento <code>characterString.split(";");</code> palauttaa characterStringsta taulukon, jossa alkuperÃ¤isen characterStringn puolipisteellÃ¤ erotetut osat ovat kukin omassa taulukon indeksissÃ¤.</p>

  <p>Voit kÃ¤yttÃ¤Ã¤ testauksen apuna seuraavaa pÃ¤Ã¤ohjelmaa:</p>

<pre class="sh_java">
        Tilasto tilasto = new Tilasto();

        PelaajatTilastosta pelaajienHakija = new PelaajatTilastosta();
        ArrayList&lt;Pelaaja&gt; pelaajat = pelaajienHakija.haePelaajat(tilasto);

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println( pelaaja );
        }
</pre>

<h4>Maali ja syÃ¶ttÃ¶pÃ¶rssi</h4>

  <p>Haluamme tulostaa myÃ¶s maalintekijÃ¤pÃ¶rssin eli pelaajien tiedot maalimÃ¤Ã¤rÃ¤n mukaan jÃ¤rjestettynÃ¤ sekÃ¤ syÃ¶ttÃ¶pÃ¶rssin. <a href="http://www.nhl.com/ice/app?component=completePointLeadersList&page=statshome&service=direct">NHL:n</a> kotisivu tarjoaa tÃ¤mÃ¤nkaltaisen toiminnallisuuden, eli selaimessa nÃ¤ytettÃ¤vÃ¤ lista on mahdollista saada jÃ¤rjestettyÃ¤ halutun kriteerin mukaan.</p>

  <p>Edellinen tehtÃ¤vÃ¤ mÃ¤Ã¤ritteli pelaajien suuruusjÃ¤rjestyksen perustuvan kokonaispistemÃ¤Ã¤rÃ¤Ã¤n. Luokalla voi olla vain yksi <code>compareTo</code>-metodi, joten joudumme muunlaisia jÃ¤rjestyksiÃ¤ saadaksemme turvautumaan muihin keinoihin.</p>

        <p>Vaihtoehtoiset jÃ¤rjestÃ¤mistavat toteutetaan erillisten luokkien avulla. Pelaajien vaihtoehtoisten jÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokkien tulee toteuttaa <code>Comparator&lt;Pelaaja&gt;</code>-rajapinta. JÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokan olio vertailee kahta parametrina saamaansa pelaajaa. Metodeja on ainoastaan yksi <code>compare(Pelaaja p1, Pelaaja p2)</code>, jonka tulee palauttaa negatiivinen arvo, jos pelaaja <code>p1</code> on jÃ¤rjestyksessÃ¤ ennen pelaajaa <code>p2</code>, positiivinen arvo jos <code>p2</code> on jÃ¤rjestyksessÃ¤ ennen
<code>p1</code>:stÃ¤ ja 0 muuten.</p>

  <p>Periaatteena on luoda jokaista jÃ¤rjestÃ¤mistapaa varten oma vertailuluokka, esim. maalipÃ¶rssin jÃ¤rjestyksen mÃ¤Ã¤rittelevÃ¤ luokka:</p>

<pre class="sh_java">
import java.util.Comparator;

public class Maali implements Comparator&lt;Pelaaja&gt; {
    public int compare(Pelaaja p1, Pelaaja p2) {
        // maalien perusteella tapahtuvan vertailun koodi tÃ¤nne
    }
}
</pre>

  <p>Tee <code>Comparator</code>-rajapinnan toteuttavat luokat <code>Maali</code> ja <code>Syotto</code>, ja niille vastaavat maali- ja syÃ¶ttÃ¶pÃ¶rssien generoimiseen sopivat sopivat vertailufunktiot.</p>

  <p>JÃ¤rjestÃ¤minen tapahtuu edelleen luokan <code>Collections</code> metodin <code>sort</code> avulla. Metodi saa nyt toiseksi parametrikseen jÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokan olion:</p>

<pre class="sh_java">
Maali maalintekijat = new Maali();
Collections.sort(pelaajat, maalintekijat);
System.out.println("NHL parhaat maalintekijÃ¤t\n");

// tulostetaan maalipÃ¶rssi
</pre>

  <p>JÃ¤rjestyksen mÃ¤Ã¤rittelevÃ¤ olio voidaan myÃ¶s luoda suoraan sort-kutsun yhteydessÃ¤:</p>

<pre class="sh_java">
Collections.sort(pelaajat, new Maali());
System.out.println("NHL parhaat maalintekijÃ¤t\n");

// tulostetaan maalipÃ¶rssi
</pre>

  <p>Kun sort-metodi saa jÃ¤rjestyksen mÃ¤Ã¤rittelevÃ¤n olion parametrina, se kÃ¤yttÃ¤Ã¤ olion <code>compareTo()</code>-metodia pelaajia jÃ¤rjestÃ¤essÃ¤Ã¤n.</p>


</div>

<div class="tehtavat">

  <h3>Olioiden samuus</h3>

<p>
<b>pois?</b>
</p>

  <p>Kaikki oliot ovat tyyppiÃ¤ <code>Object</code>, joten minkÃ¤ tahansa tyyppisen olion voi antaa parametrina <code>Object</code>-tyyppisiÃ¤ parametreja vastaanottavalle metodille.</p>

  <p>TehtÃ¤vÃ¤n mukana tulee rajapinta <code>Vertaaja</code>. Toteuta pakkaukseen <code>samuus</code> luokka <code>OlioidenVertaaja</code>, joka toteuttaa rajapinnan <code>Vertaaja</code>. Metodien tulee toimia seuraavasti:</p>

  <ul>
    <li><strong>public boolean samaOlio(Object o1, Object o2)</strong> metodi palauttaa true, mikÃ¤li parametrina saatujen olioiden viitteet ovat samat, muutoin metodi palauttaa false. Olioiden viitteiden samuutta vertaillaan &quot;==&quot;-ilmaisulla.</li>
    <li><strong>public boolean vastaavat(Object o1, Object o2)</strong> metodi palauttaa true, mikÃ¤li parametrina saadut oliot ovat samanlaiset. Muutoin metodi palauttaa false. KÃ¤ytÃ¤ tÃ¤ssÃ¤ vertailussa <code>equals</code>-metodia. Tarkemmin <code>equals</code>-metodin toiminnasta <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)">Javan Object luokan APIsta</a>. Huomaa, ettÃ¤ <code>equals</code>-metodin toiminta riippuu siitÃ¤, onko verrattavan olion luokka korvannut <code>Object</code>-luokassa mÃ¤Ã¤ritellyn <code>equals</code>-metodin. </li>
    <li><strong>public boolean samacharacterStringEsitys(Object o1, Object o2)</strong> metodi palauttaa true, mikÃ¤li parametrina saatujen olioiden characterStringesitykset (metodin <code>toString</code>-palauttamat characterStringt) ovat samat. Muutoin metodi palauttaa false.</li>
  </ul>

  <p>TehtÃ¤vÃ¤n mukana tulee luokka <code>Person</code>, jossa <code>equals</code>- ja <code>compareTo</code>-metodit on korvattu. Kokeile toteuttamiesi metodien toimintaa seuraavalla esimerkkikoodilla.</p>

<pre class="sh_java">
   OlioidenVertaaja vertaaja = new OlioidenVertaaja();
   Person henkilo1 = new Person("221078-123X", "Pekka", "Helsinki");
   Person henkilo2 = new Person("221078-123X", "Pekka", "Helsinki");  // tÃ¤ysin samansisÃ¤ltÃ¶inen kuin eka
   Person henkilo3 = new Person("110934-123X", "Pekka", "Helsinki");  // eri pekka vaikka asuukin helsingissÃ¤

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo1));
   System.out.println(vertaaja.samaOlio(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo3));
   System.out.println(vertaaja.samacharacterStringEsitys(henkilo1, henkilo2));

   Person henkilo4 = new Person("221078-123X", "Pekka", "Savonlinna"); // henkilo1:n pekka mutta asuinpaikka muuttuu

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo4));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo4));
   System.out.println(vertaaja.samacharacterStringEsitys(henkilo1, henkilo4));
</pre>

  <p>YllÃ¤olevan koodin tulostuksen pitÃ¤isi olla seuraava:</p>

<pre>
true
false
true
false
true
false
true
false
</pre>


<h3>Kuviot</h3>

    <p>TehtÃ¤vÃ¤pohjan mukana tulee luokat <code>Ympyra</code>, <code>Suorakulmio</code> ja <code>TasasivuinenKolmio</code>. Luokat liittyvÃ¤t samaan aihepiiriin, ja niillÃ¤ on hyvin paljon yhteistÃ¤ toiminnallisuutta. Tutustu luokkiin ennenkuin lÃ¤hdet tekemÃ¤Ã¤n, jolloin hahmotat tarkemmin syyt muutoksille. Jos huomaat ettÃ¤ luokissa on alustavasti sisennys hieman pielessÃ¤, kannattaa sisennys hoitaa kuntoon luettavuuden helpottamiseksi.</p>

    <h4>Kuvio</h4>

    <p>Toteuta pakkaukseen <code>kuviot</code> abstrakti luokka <code>Kuvio</code>, jossa on kuvioihin liittyvÃ¤Ã¤ toiminnallisuutta. Luokan kuvio tulee sisÃ¤ltÃ¤Ã¤ konstruktori <code>public Kuvio(int x, int y)</code>, metodit <code>public int getX()</code>, <code>public int getY()</code>, sekÃ¤ abstraktit metodit <code>public abstract double pintaAla()</code> ja <code>public abstract double piiri()</code>.</p>


    <h4>Ympyra perii kuvion</h4>

    <p>Muuta luokan <code>Ympyra</code> toteutusta siten, ettÃ¤ se perii luokan <code>Kuvio</code>. Luokan <code>Ympyra</code> ulkoinen toiminnallisuus ei saa muuttua, eli sen tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code> avulla tai itse. Muistathan ettÃ¤ konstruktorikutsun <code>super</code> avulla voit kÃ¤yttÃ¤Ã¤ yliluokan konstruktoria. Kun metodi <code>public int getX()</code> on toteutettu jo yliluokassa se ei tarvitse erillistÃ¤ toteutusta luokassa <code>Ympyra</code>.</p>

<pre class="sh_java">
        Kuvio kuvio = new Ympyra(10, 10, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
</pre>

<pre>
X 10
Y 10
Pinta-ala 706.85834...
Piiri 94.24777...
</pre>

    <h4>Suorakulmio ja Tasakylkinen kolmio perii kuvion</h4>

    <p>Muuta luokkien <code>Suorakulmio</code> ja <code>TasakylkinenKolmio</code> toteutusta siten, ettÃ¤ ne perivÃ¤t luokan <code>Kuvio</code>. Luokkien ulkoinen toiminnallisuus ei saa muuttua, eli niiden tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code> avulla tai itse.</p>

<pre class="sh_java">
        Kuvio kuvio = new Suorakulmio(10, 10, 15, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
        System.out.println("");

        kuvio = new TasakylkinenKolmio(10, 10, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
</pre>

<pre>
X 10
Y 10
Pinta-ala 225.0
Piiri 60.0

X 10
Y 10
Pinta-ala 97.42785...
Piiri 45.0
</pre>


</div>



<h3>TreeMap</h3>

        <p>Joukkojen jÃ¤rjestyksessÃ¤ pitÃ¤minen onnistuu <code>Set</code> rajapinnan toteuttavan <code>TreeSet</code>-olion avulla. Aiemmassa <code>Tehtavakirjanpito</code>-esimerkissÃ¤ henkilÃ¶kohtaiset tehtÃ¤vÃ¤pisteet tallennettiin <code>Map</code>-rajapinnan toteuttavaan <code>HashMap</code>-olioon. Kuten <code>HashSet</code>, <code>HashMap</code> ei pidÃ¤ alkioita jÃ¤rjestyksessÃ¤. Rajapinnasta <code>Map</code> on olemassa toteutus <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html" target="_blank">TreeMap</a></code>, jossa hajautustaulun avaimia pidetÃ¤Ã¤n jÃ¤rjestyksessÃ¤. Muutetaan <code>Tehtavakirjanpito</code>-luokkaa siten, ettÃ¤ henkilÃ¶kohtaiset pisteet tallennetaan <code>TreeMap</code>-tyyppiseen hajautustauluun.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new TreeMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new TreeSet&lt;Integer&gt;());
        }

        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + ": " + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>

        <p>Muunsimme samalla <code>Set</code>-rajapinnan toteutukseksi <code>TreeSet</code>-luokan. Huomaa ettÃ¤ koska olimme kÃ¤yttÃ¤neet rajapintoja, muutoksia tuli hyvin pieneen osaan koodista. Etsi kohdat jotka muuttuivat!</p>

        <p>KÃ¤yttÃ¤jÃ¤kohtaiset tehtÃ¤vÃ¤t voidaan nyt tulostaa jÃ¤rjestyksessÃ¤.</p>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 4);
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 3);

        kirjanpito.lisaa("Pekka", 4);
        kirjanpito.lisaa("Pekka", 4);

        kirjanpito.lisaa("Matti", 1);
        kirjanpito.lisaa("Matti", 2);

        kirjanpito.tulosta();
</pre>

<pre>
Matti: [1, 2]
Mikael: [3, 4]
Pekka: [4]
</pre>


    <p>Luokka <code>TreeMap</code> vaatii ettÃ¤ <em>avaimena</em> kÃ¤ytetyn luokan tulee toteuttaa <code>Comparable</code>-rajapinta. Jos luokka ei toteuta rajapintaa <code>Comparable</code>, voidaan luokalle <code>TreeMap</code> antaa konstruktorin parametrina <code>Comparator</code>-luokan toteuttama olio aivan kuten <code>TreeSet</code>-luokalle.</p>



<div class="tehtavat">



  <h3>SÃ¤hkÃ¶posteja</h3>

  <p>TehtÃ¤vÃ¤nÃ¤si on toteuttaa sÃ¤hkÃ¶postiohjelmaan komponentti, joka sÃ¤ilÃ¶Ã¶ viestejÃ¤. TehtÃ¤vÃ¤pohjan mukana tulee luokka <code>Sahkoposti</code>, joka esittÃ¤Ã¤ sÃ¤hkÃ¶postiviestiÃ¤. Luokalla <code>Sahkoposti</code> on oliomuuttujat:</p>

  <p>
    <ul>
      <li>saapumisaika (yksinkertaisesti kokonaisluku)</li>
      <li>lÃ¤hettÃ¤jÃ¤</li>
      <li>otsikko</li>
      <li>sisÃ¤ltÃ¶</li>
    </ul>
  </p>

  <p>Toteutetaan tÃ¤ssÃ¤ luokka <code>Viestivarasto</code>, joka tarjoaa sÃ¤hkÃ¶postien hallintaan liittyviÃ¤ toimintoja.</p>

  <h4>Viestivarasto, lisÃ¤Ã¤minen ja hakeminen</h4>

<p>Luo pakkaukseen <code>posti</code> luokka <code>Viestivarasto</code>, ja lisÃ¤Ã¤ sille seuraavat metodit:</p>

<p>
  <ul>
    <li><code>public void lisaa(Sahkoposti s)</code> lisÃ¤Ã¤ viestin</li>
    <li><code>public Sahkoposti hae(String otsikko)</code> palauttaa viestin jolla on annettu otsikko tai <em>null</em> jos sellaista ei ole. </li>
  </ul>
</p>

<p>Voit olettaa ettÃ¤ millÃ¤Ã¤n kahdella viestillÃ¤ ei ole samaa otsikkoa.</p>



  <h4>Ajan perusteella hakeminen</h4>

  <p>LisÃ¤Ã¤ luokkaan <code>Viestivarasto</code> seuraavat metodit</p>

<p>
  <ul>
    <li><code>public Sahkoposti hae(int aika)</code> palauttaa viestin joka saapui annettuun aikaan tai <em>null</em> jos sellaista ei ole. Voit olettaa ettÃ¤ millÃ¤Ã¤n kahdella viestillÃ¤ ei ole samaa saapumisaikaa.</li>
    <li><code>public Sahkoposti haeUusinViesti()</code> hakee uusimman viestin (eli sen jonka saapumisaika on isoin) ai <em>null</em> jos sellaista ei ole.</li>
    <li><code>public Sahkoposti haeUusinViesti(int ylaraja)</code> hakee uusimman viestin joka ei ole saapunut annetun ajan <code>ylaraja</code> jÃ¤lkeen. Metodi palauttaa <em>null</em> jos tÃ¤llaista viestiÃ¤ ei ole.</li>
  </ul>
</p>

  <p><em>Huom!</em> Kannattaa kÃ¤yttÃ¤Ã¤ kahta erillistÃ¤ rakennetta viestien tallentamiseen. Otsikon perusteella tallentamiseen voit kÃ¤yttÃ¤Ã¤ <code>HashMap</code>pia, ja viestien tallentamiseen ajan mukaan <code>TreeMap</code>pia. NÃ¤in saat toteutettua hae-operaatiot tehokkaasti. Tutustu myÃ¶s <code>TreeMap</code>in metodeihin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#lastKey()" target="_blank">lastKey()</a></code> ja <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#floorKey()" target="_blank">floorKey()</a></code>.</p>

</div>


<h2>Ohjelmien automaattinen testaaminen</h2>

<p><em>Errare humanum est</em></p>

<p>Ihminen on erehtyvÃ¤inen ja paraskin ohjelmoija tekee virheitÃ¤. Ohjelman kehitysvaiheessa tapahtuvien virheiden lisÃ¤ksi huomattava osa virheistÃ¤ syntyy olemassa olevaa ohjelmaa muokattaessa. Ohjelman muokkauksen aikana tehdyt virheet eivÃ¤t vÃ¤lttÃ¤mÃ¤ttÃ¤ nÃ¤y muokattavassa osassa, vaan voivat ilmaantua vÃ¤lillisesti erillisessÃ¤ osassa ohjelmaa: osassa, joka kÃ¤yttÃ¤Ã¤ muutettua osaa.</p>

<p>Ohjelmien automaattinen testaaminen tarkoittaa toistettavien testien luomista. TesteillÃ¤ varmistetaan ettÃ¤ ohjelma toimii halutusti, ja ettÃ¤ ohjelma sÃ¤ilyttÃ¤Ã¤ toiminnallisuutensa myÃ¶s muutosten jÃ¤lkeen. Sanalla <em>automaattinen</em> painotetaan sitÃ¤, ettÃ¤ luodut testit ovat toistettavia ja ettÃ¤ ne voidaan suorittaa aina haluttaessa -- ohjelmoijan ei tarvitse olla lÃ¤snÃ¤ testejÃ¤ suoritettaessa.</p>

<p>Otimme aiemmin askeleita kohti testauksen automatisointia antamalla Scanner-oliolle parametrina characterStringn, jonka se tulkitsee kÃ¤yttÃ¤jÃ¤n nÃ¤ppÃ¤imistÃ¶ltÃ¤ antamaksi syÃ¶tteeksi. Automaattisessa testaamisessa testaaminen viedÃ¤Ã¤n viedÃ¤ pidemmÃ¤lle: koneen tehtÃ¤vÃ¤nÃ¤ on myÃ¶s tarkistaa ettÃ¤ ohjelman tuottama vastaus on odotettu.</p>

<p>Automaattisen testauksen tÃ¤llÃ¤ kurssilla painotettu osa-alue on <em>yksikkÃ¶testaus</em>, jossa testataan ohjelman pienten osakokonaisuuksien -- metodien ja luokkien -- toimintaa. YksikkÃ¶testaamiseen kÃ¤ytetÃ¤Ã¤n Javalla yleensÃ¤ <a href="http://www.junit.org" target="_blank">JUnit</a>-testauskirjastoa.</p>

<h3>Pino ja automaattiset testit</h3>

<p>Pino on kaikille ihmisille tuttu asia. Esimerkiksi ravintola Unicafessa lautaset ovat yleensÃ¤ pinossa. Pinon pÃ¤Ã¤ltÃ¤ voi ottaa lautasen ja pinon pÃ¤Ã¤lle voi lisÃ¤tÃ¤ lautasia. On myÃ¶s helppo selvittÃ¤Ã¤ onko pinossa vielÃ¤ lautasia jÃ¤ljellÃ¤.</p>

<p>Pino on myÃ¶s ohjelmoinnissa usein kÃ¤ytetty aputietorakenne. Rajapintana lukuja sisÃ¤ltÃ¤vÃ¤ pino nÃ¤yttÃ¤Ã¤ seuraavalta.</p>

<pre class="sh_java">
public interface Pino {
    boolean tyhja();
    boolean taynna();
    void pinoon(int luku);
    int pinosta();
    int huipulla();
    int lukuja();
}
</pre>

<p>Rajapinnan mÃ¤Ã¤rittelemien metodien on tarkoitus toimia seuraavasti:</p>

<ul>
  <li><code>public boolean tyhja()</code> palauttaa true jos pino on tyhjÃ¤</li>
  <li><code>public boolean taynna()</code> palauttaa true jos pino on tÃ¤ynnÃ¤</li>
  <li><code>public void pinoon(int luku)</code> laittaa parametrina olevan luvun pinon pÃ¤Ã¤lle</li>
  <li><code>public int huipulla()</code> kertoo pinon huipulla olevan alkion</li>
  <li><code>public int pinosta()</code> poistaa ja palauttaa pinon pÃ¤Ã¤llÃ¤ olevan alkion</li>
  <li><code>public int lukuja()</code> kertoo pinossa olevien lukujen mÃ¤Ã¤rÃ¤n</li>
  <li><code>public int tilaa()</code> kertoo pinon vapaan tilan mÃ¤Ã¤rÃ¤n</li>
</ul>

<p>Toteutetaan rajapinnan <code>Pino</code> toteuttava luokka <code>OmaPino</code>, johon talletetaan lukuja. Pinoon mahtuvien lukujen mÃ¤Ã¤rÃ¤ annetaan pinon konstruktorissa. Toteutamme pinon hieman aiemmasta poikkeavasti -- emme testaa ohjelmaa pÃ¤Ã¤ohjelman avulla, vaan  kÃ¤ytÃ¤mme pÃ¤Ã¤ohjelman sijasta automatisoituja JUnit-testejÃ¤ ohjelman testaamiseen.</p>

<h4 class="req">Tutustuminen JUnitiin</h4>

<p>NetBeansissa olevat ohjelmamme ovat tÃ¤hÃ¤n asti sijainneet aina <em>Source Packages</em>issa tai sen sisÃ¤llÃ¤ olevissa pakkauksissa. Ohjelman lÃ¤hdekoodit tulevat aina kansioon <em>Source Packages</em>. Automaattisia testejÃ¤ luodessa testit luodaan valikon <em>Test Packages</em> alle. Uusia JUnit-testejÃ¤ voi luoda valitsemalla projektin oikealla hiirennapilla ja valitsemalla avautuvasta valikosta <code>New -> JUnit Test...</code>. Jos vaihtoehto JUnit test ei nÃ¤y listassa, lÃ¶ydÃ¤t sen valitsemalla <em>Other</em>.</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/testaus/new-junit-test.png"/></p>

<p>JUnit-testit sijaitsevat luokassa. Uutta testitiedostoa luodessa ohjelma pyytÃ¤Ã¤ testitiedoston nimen. Tyypillisesti nimeksi annetaan testattavan luokan tai toiminnallisuuden nimi. Luokan nimen tulee aina pÃ¤Ã¤ttyÃ¤ sanaan <code>Test</code>. Esimerkiksi alla luodaan testiluokka <code>PinoTest</code>, joka sijaitsee pakkauksessa <code>pino</code>. NetBeans haluaa luoda kÃ¤yttÃ¶Ã¶mme myÃ¶s valmista runkoa testiluokalle -- joka kÃ¤y hyvin.</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/testaus/pinotest.png"/></p>

<p>Jos NetBeans kysyy minkÃ¤ JUnit-version haluat kÃ¤yttÃ¶Ã¶si, valitse <code>JUnit 4.x</code>.</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/testaus/junit4.png"/></p>

<p>Kun testiluokka <code>PinoTest</code> on luotu, nÃ¤kyy se projektin valikon <em>Test Packages</em> alla.</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/testaus/pinotest-luotu.png"/></p>

<p>Luokka <code>PinoTest</code> nÃ¤yttÃ¤Ã¤ aluksi seuraavalta</p>

<pre class="sh_java">
package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    public PinoTest() {
    }

    @BeforeClass
    public static void setUpClass() throws Exception {
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
    }

    @Before
    public void setUp() {
    }

    @After
    public void tearDown() {
    }
    // TODO add test methods here.
    // The methods must be annotated with annotation @Test. For example:
    //
    // @Test
    // public void hello() {}
}
</pre>

<p>Meille oleellisia osia luokassa <code>PinoTest</code> ovat metodit <code>public void setUp</code>, jonka ylÃ¤puolella on merkintÃ¤ <code>@Before</code>, ja kommentoitu metodipohja <code>public void hello()</code>, jonka ylÃ¤puolella on merkintÃ¤ <code>@Test</code>. Metodit, joiden ylÃ¤puolella on merkintÃ¤ <code>@Test</code> ovat ohjelman toiminnallisuutta testaavia testimetodeja. Metodi <code>setUp</code> taas suoritetaan ennen jokaista testiÃ¤.</p>

<p>Muokataan luokkaa <code>PinoTest</code> siten, ettÃ¤ sillÃ¤ testataan rajapinnan <code>Pino</code> toteuttamaa luokkaa <code>OmaPino</code>. ÃlÃ¤ vÃ¤litÃ¤ vaikkei luokkaa <code>OmaPino</code> ole vielÃ¤ luotu. Pino on testiluokan oliomuuttuja, joka alustetaan ennen jokaista testiÃ¤ metodissa <code>setUp</code>.</p>

<pre class="sh_java">
package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    Pino pino;

    @Before
    public void setUp() {
        pino = new OmaPino(3);
    }

    @Test
    public void alussaTyhja() {
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisayksenJalkeenEiTyhja() {
        pino.pinoon(5);
        assertFalse(pino.tyhja());
    }

    @Test
    public void lisattyAlkioTuleePinosta() {
        pino.pinoon(3);
        assertEquals(3, pino.pinosta());
    }

    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisatytAlkiotTulevatPinostaOikeassaJarjestyksessa() {
        pino.pinoon(1);
        pino.pinoon(2);
        pino.pinoon(3);

        assertEquals(3, pino.pinosta());
        assertEquals(2, pino.pinosta());
        assertEquals(1, pino.pinosta());
    }

    @Test
    public void tyhjennyksenJalkeenPinoonLaitettuAlkioTuleeUlosPinosta() {
        pino.pinoon(1);
        pino.pinosta();

        pino.pinoon(5);

        assertEquals(5, pino.pinosta());
    }

    // ...
}
</pre>

<p>Jokainen testi, eli merkinnÃ¤llÃ¤ <code>@Test</code> varustettu metodi, alkaa tilanteesta, jossa on luotu uusi tyhjÃ¤ pino. Jokainen yksittÃ¤inen @Test-merkitty metodi on oma testinsÃ¤. YksittÃ¤isellÃ¤ testimetodilla testataan aina yhtÃ¤ pientÃ¤ osaa pinon toiminnallisuudesta. Testit suoritetaan toisistaan tÃ¤ysin riippumattomina, eli jokainen testi alkaa "puhtaaltÃ¤ pÃ¶ydÃ¤ltÃ¤", <code>setUp</code>-metodin alustamasta tilanteesta.</p>

<p>YksittÃ¤iset testit noudattavat aina samaa kaavaa. Ensin luodaan tilanne jossa tapahtuvaa toimintoa halutaan testata, sitten tehdÃ¤Ã¤n testattava toimenpide, ja lopuksi tarkastetaan onko tilanne odotetun kaltainen. Esimerkiksi seuraava testi testaa ettÃ¤ lisÃ¤yksen ja poiston jÃ¤lkeen pino on taas tyhjÃ¤ -- huomaa myÃ¶s kuvaava testimetodin nimentÃ¤:</p>

<pre class="sh_java">
    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }
</pre>

<p>YllÃ¤oleva testi testaa toimiiko metodi <code>tyhja()</code> jos pino on tyhjennetty. Ensin laitetaan pinoon luku metodilla <code>pinoon</code>, jonka jÃ¤lkeen pino tyhjennetÃ¤Ã¤n kutsumalla metodia <code>pinosta()</code>. TÃ¤llÃ¶in on saatu aikaan tilanne jossa pinon <em>pitÃ¤isi</em> olla tyhjennetty. ViimeisellÃ¤ rivillÃ¤ testataan, ettÃ¤ pinon metodi <code>tyhja()</code> palauttaa arvon <code>true</code> testausmetodilla <code>assertTrue()</code>. Jos metodi <code>tyhja()</code> ei palauta arvoa <code>true</code> nÃ¤emme testejÃ¤ suorittaessa virheen. </p>

<p>Jokainen testi pÃ¤Ã¤ttyy jonkun <code>assert</code>-metodin kutsuun. Esimerkiksi metodilla <code>assertEquals()</code> voidaan varmistaa onko metodin palauttama luku tai characterString haluttu, ja metodilla <code>assertTrue()</code> varmistetaan ettÃ¤ metodin palauttama arvo on <code>true</code>. Erilaiset <code>assert</code>-metodit saadaan kÃ¤yttÃ¶Ã¶n luokan alussa olevalla mÃ¤Ã¤rittelyllÃ¤ <code>import static org.junit.Assert.*;</code>.

<p>Testit suoritetaan joko painamalla <em>alt</em> ja <em>F6</em> tai valitsemalla <em>Run -> Test project</em>. (Macintosh-koneissa tulee painaa <em>ctrl</em> ja <em>F6</em>). Punainen vÃ¤ri ilmaisee ettÃ¤ testin suoritus epÃ¤onnistui -- testattava toiminnallisuus ei toiminut kuten toivottiin. VihreÃ¤ vÃ¤ri kertoo ettÃ¤ testin testaama toiminnallisuus toimi kuten haluttiin.</p>

<h4 class="req">Luokan OmaPino toteutus</h4>

<p>Pinon toteuttaminen testien avulla tapahtuisi askel kerrallaan siten, ettÃ¤ lopulta kaikki testit toimivat. Ohjelman rakentaminen aloitetaan yleensÃ¤ hyvin varovasti. Rakennetaan ensin luokka <code>OmaPino</code> siten, ettÃ¤ ensimmÃ¤inen testi <em>alussaTyhja</em> alkaa toimimaan. ÃlÃ¤ tee mitÃ¤Ã¤n kovin monimutkaista, "quick and dirty"-ratkaisu kelpaa nÃ¤in alkuun. Kun testi menee lÃ¤pi (eli nÃ¤yttÃ¤Ã¤ vihreÃ¤Ã¤), siirry ratkaisemaan seuraavaa kohtaa.</p>

<p>Testi <em>alussaTyhja</em> menee lÃ¤pi aina kun palautamme arvon <code>true</code> metodista <code>tyhja</code>.</p>

<pre class="sh_java">
package pino;

import java.util.ArrayList;
import java.util.List;

public class OmaPino implements Pino {

    public OmaPino(int maksimikoko) {
    }

    @Override
    public boolean tyhja() {
        return true;
    }

    // tyhjÃ¤t metodirungot
</pre>

<p>SiirrytÃ¤Ã¤n ratkaisemaan kohtaa <em>lisayksenJalkeenEiTyhja</em>. Tarvitsemme toteutuksen metodille <code>pinoon</code>. Yksi lÃ¤hestymistapa on muokata luokkaa <code>OmaPino</code> siten, ettÃ¤ se sisÃ¤ltÃ¤Ã¤ taulukon. Taulukkoa kÃ¤ytetÃ¤Ã¤n, ettÃ¤ pinottavat values talletetaan pinon taulukkoon yksi kerrallaan. Seuraava kuvasarja selkeyttÃ¤Ã¤ taulukossa olevien alkioiden pinoon laittamista ja pinosta ottamista.</p>

<pre>
<font color ="red">pino = new OmaPino(4);</font>

  0   1   2   3
-----------------
|   |   |   |   |
-----------------
alkioita: 0

<font color ="red">pino.pinoon(5);</font>

  0   1   2   3
-----------------
| 5 |   |   |   |
-----------------
alkiota: 1

<font color ="red">pino.pinoon(3);</font>

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2

<font color ="red">pino.pinoon(7);</font>

  0   1   2   3
-----------------
| 5 | 3 | 7 |   |
-----------------
alkiota: 3

<font color ="red">pino.pinosta();</font>

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2
</pre>

<p>Ohjelman tulee siis muistaa kuinka monta alkiota pinossa on. Uusi alkio laitetaan jo pinossa olevien perÃ¤Ã¤n. Alkion poisto aiheuttaa sen, ettÃ¤ taulukon viimeinen kÃ¤ytÃ¶ssÃ¤ ollut paikka vapautuu ja alkiomÃ¤Ã¤rÃ¤n muistavan muuttujan arvo pienenee.</p>

<p>Luokan <code>OmaPino</code> toteutusta jatketaan askel kerrallaan kunnes kaikki testit menevÃ¤t lÃ¤pi. Jossain vaiheessa ohjelmoija todennÃ¤kÃ¶isesti huomaisi, ettÃ¤ taulukko kannattaa vaihtaa <code>ArrayList</code>-rakenteeksi.</p>

<p>Huomaat todennÃ¤kÃ¶isesti yllÃ¤olevan esimerkin luettuasi ettÃ¤ olet jo tehnyt hyvin monta testejÃ¤ kÃ¤yttÃ¤vÃ¤Ã¤ ohjelmaa. Osa TMC:n toiminnallisuudesta rakentuu JUnit-testien varaan, ongelmat ovat varsinkin kurssin alkupuolella pilkottu pieniin testeihin, joiden avulla ohjelmoijaa on ohjattu eteenpÃ¤in. TMC:n mukana tulevat testit ovat kuitenkin usein monimutkaisempia kuin ohjelmien normaalissa automaattisessa testauksessa niiden tarvitsee olla. TMC:ssÃ¤ ja kurssilla kÃ¤ytettÃ¤vien testien kirjoittajien tulee muunmuassa varmistaa luokkien olemassaolo, jota normaalissa automaattisessa testauksessa harvemmin tarvitsee tehdÃ¤.</p>

<p>Harjoitellaan seuraavaksi ensin testien lukemista, jonka jÃ¤lkeen kirjoitetaan muutama testi.</p>

<div class="tehtavat" id="viikko11">



  <h3>TehtÃ¤vÃ¤lista</h3>

  <p>TehtÃ¤vÃ¤pohjassa on rajapinnan <code>Tehtavalista</code> toteuttava luokka <code>MuistiTehtavalist</code>. Ohjelmaa varten on koodattu valmiiksi testit, joita ohjelma ei kuitenkaan lÃ¤pÃ¤ise. TehtÃ¤vÃ¤nÃ¤si on tutustua testiluokkaan <code>TehtavalistaTest</code>, ja korjata luokka <code>MuistiTehtavalista</code> siten, ettÃ¤ ohjelman testit menevÃ¤t lÃ¤pi.</p>

  <p>Huom! TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ sinun ei tarvitse koskea  testiluokkaan <code>TehtavalistaTest</code>.</p>


  <h3>Lukutilasto</h3>

  <p><em>Huom!</em> TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ on jo mukana testiluokka, johon sinun tulee kirjoittaa lisÃ¤Ã¤ testejÃ¤. Vastauksen oikeellisuus testataan vasta TMC-palvelimella: tehtÃ¤vÃ¤stÃ¤ saa pisteet vasta kun <em>molemmat</em> tehtÃ¤vÃ¤t on suoritettu palvelimella hyvÃ¤ksytysti. Ole tarkka metodien nimennÃ¤n <em>ja</em> lisÃ¤ttyjen lukujen kanssa.</p>

  <p>TehtÃ¤vÃ¤ssÃ¤ tulee pakkauksessa <code>tilasto</code> sijaitseva luokka <code>Lukutilasto</code>.</p>

<ul>
  <li><code>public void lisaaLuku(int luku)</code><br/>LisÃ¤Ã¤ annetun luvun lukutilastoon.</li>
  <li><code>public int sum()</code><br/>Palauttaa tilastossa olevien lukujen summan.</li>
  <li><code>public int lukujenMaara()</code><br/>Palauttaa tilastossa olevien lukujen maaran.</li>
  <li><code>public boolean sisaltaa(int luku)</code><br/>Palauttaa totuusarvon, joka kertoo onko parametrina annettu luku tilastossa.</li>
</ul>

  <p>Testikansiossa olevassa pakkauksessa <code>tilasto</code> on luokka <code>LukutilastoTest</code>, johon sinun tulee lisÃ¤tÃ¤ uusia testimetodeja.</p>

  <h4>Lukujen mÃ¤Ã¤rÃ¤n kasvamisen tarkistus</h4>

  <p>LisÃ¤Ã¤ testiluokkaan testimetodi <code>public void lukujenMaaraKasvaaKahdellaKunLisataanKaksiLukua()</code>, jossa lukutilastoon lisÃ¤tÃ¤Ã¤n values 3 ja 5. TÃ¤mÃ¤n jÃ¤lkeen metodissa tarkistetaan ettÃ¤ lukutilastossa on kaksi lukua kÃ¤yttÃ¤en lukutilaston metodia lukujenMaara. KÃ¤ytÃ¤ <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>

  <h4>Summan tarkistus yhdellÃ¤ luvulla</h4>

  <p>LisÃ¤Ã¤ testiluokkaan testimetodi <code>public void summaOikeinYhdellaLuvulla()</code>, jossa lukutilastoon lisÃ¤tÃ¤Ã¤n luku 3. TÃ¤mÃ¤n jÃ¤lkeen metodissa tarkistetaan lukutilaston summa-metodin avulla ettÃ¤ tilastossa olevien lukujen summa on 3.  KÃ¤ytÃ¤ <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>
</div>



<h3>JÃ¤tkÃ¤nshakin sovelluslogiikka (pakollinen)</h3>

<p><em>Huom!</em> tÃ¤mÃ¤ tehtÃ¤vÃ¤ on pakollinen yliopistoon hakeville.</p>

<p><em>TÃ¤mÃ¤ tehtÃ¤vÃ¤ on kolmen yksittÃ¤isen tehtÃ¤vÃ¤pisteen arvoinen.</em> TehtÃ¤vÃ¤ssÃ¤ toteutetaan sovelluslogiikka jÃ¤tkÃ¤nshakille ja harjoitellaan ohjelmarakenteen osittaista omatoimista suunnittelua.</p>

<p>TehtÃ¤vÃ¤pohjassa tulee mukana kÃ¤yttÃ¶liittymÃ¤ <a href="http://fi.wikipedia.org/wiki/Ristinolla">jÃ¤tkÃ¤nshakille</a>, jossa pelilaudan koko on aina 3x3 ruutua. KÃ¤yttÃ¶liittymÃ¤ huolehtii ainoastaan pelilaudalla tehtyihin tapahtumiin reagoimisesta, sekÃ¤ pelilaudan ja pelitilanteen tietojen pÃ¤ivittÃ¤misestÃ¤. Pelin logiikka on erotettu <code>JatkanshakinSovelluslogiikka</code>-rajapinnan avulla omaksi luokakseen.</p>

<pre class="sh_java">
package jatkanshakki.sovelluslogiikka;

public interface JatkanshakinSovelluslogiikka {
    char getNykyinenVuoro();
    int getMerkkienMaara();

    void asetaMerkki(int sarake, int rivi);
    char getMerkki(int sarake, int rivi);

    boolean isPeliLoppu();
    char getVoittaja();
}
</pre>


<p>Rajapinnan <code>JatkanshakinSovelluslogiikka</code> lisÃ¤ksi tehtÃ¤vÃ¤pohjassa on apuluokka, joka mÃ¤Ã¤rittelee pelilaudan ruutujen mahdolliset tilat <code>char</code>-tyyppisinÃ¤ kirjaimina. Ruutu voi olla joko tyhjÃ¤, tai siinÃ¤ voi olla risti tai nolla. Apuluokassa <code>Jatkanshakki</code> on nÃ¤ille mÃ¤Ã¤rittelyt:</p>

<pre class="sh_java">
package jatkanshakki.sovelluslogiikka;

public class Jatkanshakki {
    public static final char RISTI = 'X';
    public static final char NOLLA = 'O';
    public static final char TYHJA = ' ';
}
</pre>

<p>TehtÃ¤vÃ¤nÃ¤si on tÃ¤ydentÃ¤Ã¤ pakkauksessa <code>jatkanshakki.sovelluslogiikka</code> olevaa rajapinnan <code>JatkanshakinSovelluslogiikka</code> toteuttavaa luokkaa <code>OmaJatkanshakinSovelluslogiikka</code>. Luokka <code>OmaJatkanshakinSovelluslogiikka</code> mahdollistaa jÃ¤tkÃ¤nshakin pelaamisen.</p>

<p>Rajapinta <code>JatkanshakinSovelluslogiikka</code> mÃ¤Ã¤rittelee seuraavat toiminnot, jotka luokan <code>OmaJatkanshakinSovelluslogiikka</code> tulee toteuttaa:</p>

  <ul>
    <li><strong>char getNykyinenVuoro()</strong> palauttaa pelaajan merkkiÃ¤ vastaavan arvon: <code>RISTI</code>, <code>NOLLA</code> tai pelin pÃ¤Ã¤tyttyÃ¤ <code>TYHJA</code></li>
    <li><strong>int getMerkkienMaara()</strong> palauttaa pelilaudalle tÃ¤hÃ¤n mennessÃ¤ asetettujen merkkien mÃ¤Ã¤rÃ¤n (vÃ¤lillÃ¤ 0-9)</li>
    <li><strong>void asetaMerkki(int sarake, int rivi)</strong> asettaa pelaajan vuoron mukaisen merkin annettuun ruutuun sarakkeen (0-2) ja rivin (0-2) perusteella ja antaa vuoron toiselle pelaajalle. Metodi heittÃ¤Ã¤ poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella tai ruudussa on jo merkki, ja poikkeuksen <code>IllegalStateException</code>, jos peli on jo loppu.</li>
    <li><strong>char getMerkki(int sarake, int rivi)</strong> palauttaa sarakkeen ja rivin mÃ¤Ã¤rittelemÃ¤n ruudun tilan, joka voi olla <code>TYHJA</code>, <code>RISTI</code> tai <code>NOLLA</code>. Metodi heittÃ¤Ã¤ poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella.</li>
    <li><strong>boolean isPeliLoppu()</strong> palauttaa arvon <code>true</code>, jos toinen pelaajista voitti pelin tai peli pÃ¤Ã¤ttyi tasapeliin, muutoin metodi palauttaa <code>false</code></li>
    <li><strong>char getVoittaja()</strong> palauttaa arvon <code>TYHJA</code>, jos peli on kesken tai peli pÃ¤Ã¤ttyi tasapeliin, muutoin metodi palauttaa voittajan merkin: <code>RISTI</code> tai <code>NOLLA</code></ul>

<p>EnsimmÃ¤inen pelivuoro on aina merkillÃ¤ <code>RISTI</code>. Pelin voittaa se pelaaja, joka saa ensimmÃ¤isenÃ¤ kolme merkkiÃ¤ vaakasuoraan, pystysuoraan tai vinottain. Tasapeli todetaan vasta, kun pelilauta on tÃ¤ynnÃ¤ merkkejÃ¤ eli tyhjiÃ¤ ruutuja ei enÃ¤Ã¤ ole.</p>

<p><b>Vinkki:</b> Pelilaudan tilanteen voi esittÃ¤Ã¤ esimerkiksi yhdeksÃ¤n alkion <code>char</code>-taulukolla, jonne talletetaan peliruutujen tilat. Sarakkeen ja rivin perusteella voidaan laskea taulukon indeksi: <code>rivi * 3 + sarake</code>.</p>

</div>



<!-- END SNIP -->

<!-- FLOATING MENU -->
<div id="fl_menu">
  <div class="label">Materiaali</div>
  <div class="menu" id="fl_menu_items">
  </div>
</div>



<script>
//config
$float_speed=0; //milliseconds
$float_easing="easeOutQuint";
$menu_fade_speed=0; //milliseconds
$closed_menu_opacity=0.5;

//cache vars
$fl_menu=$("#fl_menu");
$fl_menu_menu=$("#fl_menu .menu");
$fl_menu_label=$("#fl_menu .label");

$(window).load(function() {
    menuPosition=$('#fl_menu').position().top;
    FloatMenu();
    $fl_menu.hover(
      function(){ //mouse over
      $fl_menu_label.fadeTo($menu_fade_speed, 1);
      $fl_menu_menu.fadeIn($menu_fade_speed);
      },
      function(){ //mouse out
      $fl_menu_label.fadeTo($menu_fade_speed, $closed_menu_opacity);
      $fl_menu_menu.fadeOut($menu_fade_speed);
      }
      );
    });

$(window).scroll(function () {
    FloatMenu();
    });

function FloatMenu(){
  var scrollAmount=$(document).scrollTop();
  var newPosition=menuPosition+scrollAmount;
  if($(window).height()<$fl_menu.height()+$fl_menu_menu.height()){
    $fl_menu.css("top",menuPosition);
  } else {
    $fl_menu.stop().animate({top: newPosition}, $float_speed, $float_easing);
  }
}
</script>



</body>

</html>
